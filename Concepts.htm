<!DOCTYPE HTML>
<html lang="de">
<head>
<title>Konzepte und Konventionen | AutoHotkey v2</title>
<meta name="description" content="Erfahren Sie mehr über einige allgemeine Konzepte und Konventionen, die von AutoHotkey verwendet werden, wobei der Schwerpunkt eher auf Erklärungen als auf Code liegt." />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="robots" content="noindex, nofollow">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
<script src="static/ga.js" type="text/javascript"></script>
<script src="static/ga4.js" type="text/javascript"></script>
</head>
<body>
<h1>Konzepte und Konventionen</h1>
<p>Dieses Dokument behandelt einige allgemeine Konzepte und Konventionen, die von AutoHotkey verwendet werden, wobei der Schwerpunkt eher auf Erklärungen als auf Code liegt. Es wird nicht davon ausgegangen, dass der Leser über Vorkenntnisse in Scripting oder Programmierung verfügt, aber er sollte für neue Fachbegriffe offen sein.</p>
<p>Genauere Informationen zur Syntax finden Sie unter <a href="Language.htm">Skriptsprache</a>.</p>

<h2 id="toc">Inhaltsverzeichnis</h2>
<ul>
  <li><a href="#values">Werte</a>
  <ul>
    <li><a href="#strings">Zeichenketten (Strings)</a></li>
    <li><a href="#numbers">Zahlen</a></li>
    <li><a href="#boolean">Boolesche Werte</a></li>
    <li><a href="#nothing">Nichts</a></li>
    <li><a href="#objects">Objekte</a></li>
    <li><a href="#object-protocol">Objektorientierte Schnittstelle</a></li>
  </ul></li>
  <li><a href="#variables">Variablen</a>
  <ul>
    <li><a href="#uninitialized-variables">Nicht initialisierte Variablen</a></li>
    <li><a href="#built-in-variables">Interne Variablen</a></li>
    <li><a href="#environment-variables">Umgebungsvariablen</a></li>
    <li><a href="#variable-references">Variablenreferenzen (VarRef)</a></li>
    <li><a href="#caching">Caching</a></li>
  </ul></li>
  <li><a href="#functions">Funktionen</a>
  <ul>
    <li><a href="#methods">Methoden</a></li>
  </ul></li>
  <li><a href="#control-flow">Kontrollfluss</a></li>
  <li><a href="#details">Details</a>
  <ul>
    <li><a href="#string-encoding">Zeichenkettencodierung</a></li>
    <li><a href="#pure-numbers">Reine Zahlen</a></li>
    <li><a href="#names">Namen</a></li>
    <li><a href="#references-to-objects">Objektreferenzen</a></li>
  </ul></li>
</ul>
<!-- TODO:
Scope/declarations
Technical terms: dynamic, default
Classes
Exception handling
-->

<h2 id="values">Werte</h2>
<p>Ein <em>Wert</em> repräsentiert eine einzelne Information innerhalb eines Programms. Zum Beispiel wäre das der Name einer zu sendenden Taste oder eines zu startenden Programms, die Anzahl der Tastendrücke, der Titel eines zu aktivierenden Fensters, oder was auch immer innerhalb des Programms oder Skripts eine Bedeutung hat.</p>
<p>AutoHotkey unterstützt folgende Typen von Werten:</p>
<ul>
  <li><a href="#strings">Zeichenketten</a> (Strings)</li>
  <li><a href="#numbers">Zahlen</a> (Integer und Floating-Point-Zahlen)</li>
  <li><a href="#objects">Objekte</a></li>
</ul>
<p>Mit der <a href="commands/Type.htm">Type</a>-Funktion kann der Typ eines Wertes festgestellt werden.</p>
<p>Einige andere verwandte Konzepte:</p>
<ul>
  <li><a href="#boolean">Boolesche Werte</a></li>
  <li><a href="#nothing">Nichts</a></li>
</ul>

<h3 id="strings">Zeichenketten (Strings)</h3>
<p>Eine <em>Zeichenkette</em> ist einfach nur Text. Jede Zeichenkette ist eigentlich eine Sequenz, Folge oder <em>Kette</em> von Zeichen. Sie kann aber auch als einzelne Entität gesehen werden. Die <em>Länge</em> einer Zeichenkette repräsentiert die Anzahl der Zeichen in der Sequenz, während die <em>Position</em> eines Zeichens innerhalb der Zeichenkette lediglich die fortlaufende Nummer dieses Zeichens ist. Gemäß der Konvention von AutoHotkey befindet sich das erste Zeichen auf Position 1.</p>
<p id="numeric-strings"><strong>Numerische Zeichenketten:</strong> Eine Kette von Zahlen (oder von anderen unterstützten <a href="#numbers">Zahlenformaten</a>) wird automatisch als Zahl interpretiert, wenn eine mathematische Operation oder ein Vergleich dies erfordert.</p>
<p>Wie literaler (direkt geschriebener) Text innerhalb des Skripts geschrieben werden soll, hängt vom Kontext ab. Zum Beispiel müssen in einem Ausdruck <a href="Language.htm#strings">Zeichenketten</a> in Anführungszeichen gesetzt werden. In Direktiven (mit Ausnahme von #HotIf) und automatisch-ersetzenden Hotstrings werden Anführungszeichen nicht benötigt.</p>
<p>Eine genauere Erklärung der Funktionsweise von Zeichenketten finden Sie unter <a href="#string-encoding">Zeichenkettencodierung</a>.</p>

<h3 id="numbers">Zahlen</h3>
<p>AutoHotkey unterstützt folgende Zahlenformate:</p>
<ul>
  <li>Dezimale Integer (ganze Zahlen), wie z. B. <code>123</code>, <code>00123</code> oder <code>-1</code>.</li>
  <li>Hexadezimale Integer, wie z. B. <code>0x7B</code>, <code>0x007B</code> oder <code>-0x1</code>.</li>
  <li>Dezimale Floating-Point-Zahlen (Gleitkommazahlen), wie z. B. <code>3.14159</code>.</li>
</ul>
<p>Hexadezimale Zahlen müssen das <code>0x</code>- oder <code>0X</code>-Präfix verwenden, wenn nicht anders in der Dokumentation vermerkt. Dieses Präfix muss nach einem Vorzeichen wie <code>+</code> oder <code>-</code>, falls vorhanden, und vor beginnenden Nullen erfolgen. Zum Beispiel wäre <code>0x001</code> gültig, aber nicht <code>000x1</code>.</p>
<p>Zahlen, die mit einem Dezimalpunkt geschrieben werden, gelten immer als Floating-Point-Zahlen, auch wenn die Nachkommastelle eine Null ist. <code>42</code> und <code>42.0</code> beispielsweise sind in der Regel das gleiche, aber dies trifft nicht immer zu. Die wissenschaftliche Schreibweise wird ebenfalls erkannt (z. B. <code>1.0e4</code> und <code>-2.1E-4</code>), aber sie erzeugt immer eine Floating-Point-Zahl, egal ob ein Dezimalpunkt vorhanden ist oder nicht.</p>
<p>Das Dezimaltrennzeichen ist immer ein Punkt, auch wenn in den Ländereinstellungen des Benutzers ein Komma angegeben ist.</p>
<p id="number-default-format">Wenn eine Zahl in eine Zeichenkette umgewandelt wird, wird sie als Dezimalzahl formatiert. Floating-Point-Zahlen werden mit voller Präzision formatiert (wobei redundante Nullen am Ende verworfen werden), was in manchen Fällen zu einer <a href="#float-imprecision">Ungenauigkeit</a> führen kann. Verwenden Sie die <a href="commands/Format.htm">Format</a>-Funktion, um eine numerische Zeichenkette in einem anderen Format zu erzeugen. Floating-Point-Zahlen können auch mit der <a href="commands/Math.htm#Round">Round</a>-Funktion formatiert werden.</p>
<p>Details über den Bereich und die Genauigkeit von numerischen Werten finden Sie unter <a href="#pure-numbers">Reine Zahlen</a>.</p>

<h3 id="boolean">Boolesche Werte</h3>
<p>Ein <em>boolescher</em> Wert kann entweder <em>True</em> (wahr) oder <em>False</em> (falsch) sein. Boolesche Werte werden genutzt, um etwas wiederzugeben, das exakt zwei mögliche Zustände hat, wie z. B. die <em>Wahrheit</em> eines Ausdrucks. Der Ausdruck <code>(x &lt;= y)</code> beispielsweise wäre <em>True</em> bzw. wahr, wenn x kleiner gleich y ist. Ein boolescher Wert könnte auch <em>Yes</em> oder <em>No</em>, <em>On</em> oder <em>Off</em>, <em>Down</em> oder <em>Up</em> (z. B. bei <a href="commands/GetKeyState.htm">GetKeyState</a>) und so weiter repräsentieren.</p>
<p>AutoHotkey hat keinen spezifischen booleschen Wertetyp, deshalb verwendet es den Integer-Wert <code>0</code> für False und <code>1</code> für True. Wenn ein Wert entweder True oder False sein muss, wird ein leerer Wert oder ein Wert von 0 als False und alle anderen Werte als True angesehen. (Objekte werden immer als True angesehen.)</p>
<p>Die Wörter <code>True</code> und <code>False</code> sind <a href="#built-in-variables">interne Variablen</a>, die 1 und 0 enthalten. Sie können verwendet werden, um ein Skript besser lesbar zu machen.</p>

<h3 id="nothing">Nichts</h3>
<p>AutoHotkey hat keinen Wert, der eindeutig <em>nichts</em>, <em>null</em>, <em>nil</em> oder <em>undefined</em> repräsentiert, wie es in anderen Sprachen der Fall ist. Stattdessen hat oft eine leere Zeichenkette (eine Zeichenkette mit einer Länge von 0) diese Bedeutung.</p>
<p>Wenn eine <a href="#variables">Variable</a> oder ein Parameter als "leer" bezeichnet wird, meint man damit in der Regel eine leere Zeichenkette (eine Zeichenkette mit einer Länge von 0).</p>

<h3 id="objects">Objekte</h3>
<p>Das <em>Objekt</em> ist der zusammengesetzte bzw. abstrakte Datentyp von AutoHotkey. Ein Objekt besteht aus beliebig vielen <em>Eigenschaften</em> (die abgerufen oder gesetzt werden können) und <a href="#methods"><em>Methoden</em></a> (die aufgerufen werden können). Der Name und Effekt jeder Eigenschaft oder Methode hängt vom jeweiligen Objekt oder Objekttyp ab.</p>
<p>Objekte haben die folgenden Attribute:</p>
<ul>
  <li>Objekte werden nicht gespeichert, sondern <a href="#references-to-objects">referenziert</a>. <code>alpha := []</code> beispielsweise erstellt ein neues <a href="objects/Array.htm">Array</a> und speichert eine Referenz in <em>alpha</em>. <code>bravo := alpha</code> kopiert die Referenz (nicht das Objekt) nach <code>bravo</code>, so dass beide auf das gleiche Objekt verweisen. Die Aussage, dass Arrays oder Variablen ein Objekt enthalten, bedeutet eigentlich, dass sie eine Referenz zum Objekt enthalten.</li>
  <li>Zwei Objektreferenzen werden nur als gleich angesehen, wenn sie auf das gleiche Objekt verweisen.</li>
  <li>Bei Anweisungen wie <code>if obj</code>, <code>!obj</code> oder <code>obj ? x : y</code> ist der boolesche Wert eines Objekts immer <i>True</i>.</li>
  <li>Jedes Objekt hat eine einzigartige Adresse (Position im Speicher), die via <a href="Objects.htm#ObjPtr">ObjPtr</a>-Funktion abgerufen werden kann, aber normalerweise nicht direkt verwendet wird. Mit dieser Adresse ist das Objekt eindeutig identifizierbar, zumindest solange, bis das Objekt freigegeben wird.</li>
  <li>Ein Objekt wird in einigen Fällen als leere Zeichenkette behandelt, wenn es in einem Kontext verwendet wird, wo ein Objekt nicht erwartet wird. Zum Beispiel würde <code>MsgBox(meinObjekt)</code> eine leere MsgBox anzeigen. In anderen Fällen wird ggf. ein <a href="objects/Error.htm#TypeError">TypeError</a> ausgelöst (was in Zukunft die Norm sein wird).</li>
</ul>
<p class="note"><strong>Hinweis:</strong> Alle Objekte, die von <a href="objects/Object.htm">Object</a> abgeleitet werden, haben zusätzliche Verhaltensweisen, Eigenschaften und Methoden.</p>
<p>Ein Objekt kann für folgende Dinge verwendet werden:</p>
<ul>
  <li>Um eine Sammlung von <em>Elementen</em> zu enthalten. Zum Beispiel enthält ein <a href="objects/Array.htm">Array</a> eine Reihe von Elementen, während ein <a href="objects/Map.htm">Map</a>-Objekt Keys mit Werten assoziiert. Objekte ermöglichen es, eine Gruppe von Werten als einen Wert zu behandeln, einer einzelnen Variable zuzuweisen, an eine Funktion zu übergeben oder von einer Funktion zurückzugeben, und so weiter.</li>
  <li>Um etwas in realer oder begrifflicher Form darzustellen. Zum Beispiel: eine Position auf dem Bildschirm, mit den Eigenschaften X und Y; ein Kontakt in einem Adressbuch, mit Name, Telefonnummer, EMailAdresse und so weiter. Objekte können genutzt werden, um komplexere Gruppen von Informationen darzustellen, indem sie mit anderen Objekten kombiniert werden.</li>
  <li>Um einen Dienst oder eine Reihe von Diensten zu bündeln, so dass sich andere Teile des Skripts auf eine Aufgabe konzentrieren können und nicht darauf, wie diese Aufgabe ausgeführt wird. Ein <a href="objects/File.htm">File</a>-Objekt bietet beispielsweise Methoden zum Lesen von Daten aus einer Datei oder zum Schreiben von Daten in eine Datei. Wenn eine Skriptfunktion, die Informationen in eine Datei schreibt, ein File-Objekt als Parameter akzeptiert, muss sie nicht wissen, wie die Datei geöffnet wurde. Die gleiche Funktion kann wiederverwendet werden, um Informationen in ein anderes Ziel zu schreiben, wie z. B. ein TCP/IP-Socket oder WebSocket (via benutzerdefinierte Objekte).</li>
  <li>Eine Kombination der oben genannten Punkte. Zum Beispiel ein <a href="objects/Gui.htm">Gui</a>-Objekt, das ein GUI-Fenster repräsentiert; es stellt die Mittel bereit, um eine grafische Benutzeroberfläche zu erstellen und anzuzeigen; es enthält eine Sammlung von Steuerelementen und bietet Informationen über das Fenster via Eigenschaften wie Title und FocusedCtrl.</li>
</ul>
<p>Die richtige Verwendung von Objekten (und insbesondere von <a href="Objects.htm#Custom_Classes">Klassen</a>) kann zu einem <em>modularen</em> und <em>wiederverwendbaren</em> Code verhelfen. Modularer Code ist in der Regel einfacher zu testen, zu verstehen und zu pflegen. So kann man z. B. einen Codeabschnitt verbessern oder modifizieren, ohne die Details anderer Abschnitte kennen zu müssen und ohne entsprechende Änderungen an diesen Abschnitten vornehmen zu müssen. Wiederverwendbarer Code spart Zeit, weil er das Schreiben und Testen von Code für gleiche oder ähnliche Aufgaben überflüssig macht.</p>

<h3 id="object-protocol">Objektorientierte Schnittstelle</h3>
<p class="note">Dieser Abschnitt baut auf folgenden Konzepten auf, die in späteren Abschnitten behandelt werden: <a href="#variables">Variablen</a>, <a href="#functions">Funktionen</a></p>
<p>Objekte arbeiten nach dem Prinzip der <em>Meldungsübermittlung</em>. Sie wissen nicht, wo sich der Code oder die Variablen eines Objekts tatsächlich befinden, also müssen Sie eine Meldung an das Objekt übergeben, wie z. B. "gib mir <em>foo</em>" oder "gehe zu <em>bar</em>", und sich darauf verlassen, dass das Objekt auf die Meldung reagiert. Objekte in AutoHotkey unterstützen die folgenden grundlegenden Meldungen:</p>
<ul>
  <li><strong>Get</strong> - Abrufen einer Eigenschaft.</li>
  <li><strong>Set</strong> - Setzen einer Eigenschaft via <code>:=</code>.</li>
  <li><strong>Call</strong> - Aufrufen einer <a href="#methods">Methode</a> via <code>()</code>.</li>
</ul>
<p>Eine <em>Eigenschaft</em> ist ein Aspekt des Objekts, der gesetzt und/oder abgerufen werden kann. Zum Beispiel hat <a href="objects/Array.htm">Array</a> eine <a href="objects/Array.htm#Length">Length</a>-Eigenschaft, die die Anzahl der Elemente im Array widerspiegelt. Wenn Sie eine Eigenschaft definieren, kann ihr eine beliebige Bedeutung zugeschrieben werden. Grundsätzlich verhält sich eine Eigenschaft wie eine <a href="#variables">Variable</a>, aber ihr Wert kann beim Abrufen geändert und beim Setzen nirgendwo gespeichert werden.</p>
<p>Jede Meldung enthält Folgendes, das in der Regel beim <a href="#call">Aufrufen</a> der Eigenschaft oder Methode verwendet wird:</p>
<ul>
  <li>Der Name der Eigenschaft oder Methode.</li>
  <li>Keine oder mehr <a href="#parameters">Parameter</a>, die Einfluss darauf haben können, welche Aktion ausgeführt wird, wie ein Wert gespeichert wird oder welcher Wert zurückgegeben wird. Eine Eigenschaft kann beispielsweise einen Array-Index oder Key annehmen.</li>
</ul>
<p>Zum Beispiel:</p>
<pre>
meinObj.Methodenname(Param1)
Wert := meinObj.Eigenschaftsname[Param1]
</pre>
<p>Ein Objekt kann auch eine <em>Standard</em>-Eigenschaft haben; um diese aufzurufen, muss der Eigenschaftsname weggelassen und eckige Klammern verwendet werden. Zum Beispiel:</p>
<pre>Wert := meinObj[Param1]</pre>
<p>Im Allgemeinen hat <strong>Set</strong> die gleiche Bedeutung wie eine Zuweisung und verwendet daher den gleichen Operator:</p>
<pre>
meinObj.Name := Wert
meinObj.Name[Param1, Param2, ..., ParamN] := Wert
meinObj[Param1, Param2, ..., ParamN] := Wert
</pre>

<h2 id="variables">Variablen</h2>
<p>Eine Variable ermöglicht es Ihnen, einen Namen als Platzhalter für einen Wert zu verwenden. Diesen Wert können Sie jederzeit ändern, während das Skript läuft. Ein Hotkey könnte z. B. eine Variable <code>press_count</code> verwenden, um zu zählen, wie oft er gedrückt wurde, und jedes Mal eine andere Taste senden, wenn <code>press_count</code> ein Vielfaches von 3 ist (jeder dritte Tastendruck). Auch eine Variable, der nur einmal ein Wert zugewiesen wird, kann nützlich sein. Zum Beispiel können Sie die Variable <code>WebBrowserTitle</code> nutzen, um die Aktualisierung Ihres Codes zu erleichtern, wenn Sie Ihren bevorzugten Webbrowser ändern oder wenn sich der <a href="misc/WinTitle.htm">Titel</a> oder die <a href="misc/WinTitle.htm#ahk_class">Fensterklasse</a> durch ein Software-Update ändert.</p>
<p>In AutoHotkey werden Variablen erstellt, sobald man sie verwendet. Jede Variable ist <em>nicht</em> permanent auf einen einzelnen <a href="#values">Datentyp</a> beschränkt, sondern kann stattdessen einen Wert beliebigen Typs enthalten: Zeichenkette, Zahl oder Objekt. Der Versuch, eine Variable ohne zugewiesenen Wert zu lesen, wird als Fehler angesehen, daher ist es wichtig, <a href="#uninitialized-variables">Variablen zu initialisieren</a>.</p>
<p>Eine Variable hat drei Hauptaspekte:</p>
<ul>
  <li>Der <em>Name</em> der Variable.</li>
  <li>Die Variable selbst.</li>
  <li>Der <em>Wert</em> der Variable.</li>
</ul>
<p>Einem Variablennamen sind Beschränkungen auferlegt - siehe <a href="#names">Namen</a> für Details. Kurz gesagt, es ist am sichersten, sich an Namen zu halten, die aus ASCII-Buchstaben (nicht Groß-/Kleinschreibung-sensitiv), Ziffern und Unterstrichen bestehen, und Namen zu vermeiden, die mit einer Ziffer beginnen.</p>
<p id="scope">Ein Variablenname hat einen <strong><em>Gültigkeitsbereich</em></strong>, der definiert, wo im Code dieser Name genutzt werden kann, um auf diese bestimmte Variable zu verweisen; mit anderen Worten, wo die Variable <em>sichtbar</em> ist. Wenn eine Variable innerhalb eines bestimmten Gültigkeitsbereichs nicht sichtbar ist, kann derselbe Name auf eine andere Variable verweisen. Beide Variablen können zur gleichen Zeit existieren, aber nur eine ist für jeden Teil des Skripts sichtbar. <a href="Functions.htm#Global">Globale Variablen</a> sind im "globalen Bereich" (also außerhalb von Funktionen) sichtbar und können standardmäßig von Funktionen gelesen werden, müssen aber <a href="Functions.htm#Global">deklariert</a> werden, wenn ihnen innerhalb einer Funktion ein Wert zugewiesen werden soll. <a href="Functions.htm#Local">Lokale Variablen</a> sind nur innerhalb der Funktion sichtbar, die sie erzeugt hat.</p>
<p>Eine Variable kann als Container oder Speicherort für einen Wert angesehen werden. In der Dokumentation werden Sie häufig darauf stoßen, dass der Wert einer Variable als <em>Inhalt der Variable</em> bezeichnet wird. Bei einer Variable <code>x := 42</code> kann man auch sagen, dass die Variable x die Zahl 42 als Wert hat, oder dass der Wert von x eine 42 ist.</p>
<p>Es ist wichtig zu wissen, dass eine Variable und ihr Wert nicht dasselbe sind. Zum Beispiel könnten wir sagen: "<code>meinArray</code> ist ein Array", aber was wir wirklich meinen ist, dass meinArray eine Variable ist, die eine Referenz zu einem Array enthält. Wir nehmen eine Abkürzung, indem wir den Namen der Variable verwenden, um auf ihren Wert zu verweisen, aber "meinArray" ist eigentlich nur der Name der Variable; das Array-Objekt weiß nicht, dass es einen Namen hat, und könnte von vielen verschiedenen Variablen (bzw. von vielen Namen) angesprochen werden.</p>

<h3 id="uninitialized-variables"><span id="uninitialised-variables"></span>Nicht initialisierte Variablen</h3>
<p>Eine Variable zu <em>initialisieren</em> bedeutet, ihr einen Startwert zuzuweisen. Eine Variable, der noch kein Wert zugewiesen wurde, ist <em>nicht initialisiert</em>. Der Versuch, eine nicht initialisierte Variable zu lesen, wird als Fehler angesehen. Dies hilft, Fehler wie falsch geschriebene Namen und vergessene Zuweisungen aufzudecken.</p>
<p><a href="commands/IsSet.htm">IsSet</a> kann genutzt werden, um zu prüfen, ob eine Variable initialisiert wurde, z. B. um eine globale oder statische Variable bei der ersten Verwendung zu initialisieren.</p>

<h3 id="built-in-variables">Interne Variablen</h3>
<p>Eine Vielzahl von Variablen ist fest in das Programm integriert und normal abrufbar. Solche Variablen sind schreibgeschützt, sofern nicht anders angegeben; das heißt, dass man ihren Inhalt nicht ändern kann. Gemäß der Konvention beginnen die meisten dieser Variablen mit dem Präfix <code>A_</code>, daher ist es am besten, dieses Präfix nicht für eigene Variablen zu verwenden.</p>
<p>Einige Variablen wie <a href="Variables.htm#KeyDelay">A_KeyDelay</a> und <a href="Variables.htm#TitleMatchMode">A_TitleMatchMode</a> spiegeln Einstellungen wider, die das Verhalten des Skripts steuern, und separate Werte für jeden <a href="misc/Threads.htm">Thread</a> aufbewahren. Dadurch können Subroutinen, die von neuen Threads gestartet werden (z.B. für Hotkeys, Menüs, Timer und so weiter), Einstellungen ändern, ohne andere Threads zu beeinflussen.</p>
<p>Einige spezielle Variablen werden nicht periodisch aktualisiert, sondern ihr Wert wird abgerufen oder berechnet, wenn das Skript auf die Variable verweist. Eine solche Variable ist zum Beispiel <a href="misc/A_Clipboard.htm">A_Clipboard</a>, die den aktuellen Inhalt der Zwischenablage abruft, oder <a href="Variables.htm#TimeSinceThisHotkey">A_TimeSinceThisHotkey</a>, die die Anzahl der Millisekunden berechnet, die seit dem Drücken des Hotkeys vergangen sind.</p>
<p>Siehe auch: <a href="Variables.htm#BuiltIn">Liste von internen Variablen</a>.</p>

<h3 id="environment-variables">Umgebungsvariablen</h3>
<p>Umgebungsvariablen werden vom Betriebssystem verwaltet. Sie können sich eine Liste von Umgebungsvariablen anzeigen lassen, wenn Sie in der Windows-Konsole SET eingeben und ENTER drücken.</p>
<p>Mit <a href="commands/EnvSet.htm">EnvSet</a> kann eine neue Umgebungsvariable erstellt oder der Inhalt einer vorhandenen Umgebungsvariable geändert werden. Solche Ergänzungen und Änderungen sind nur für das Skript sichtbar und werden im restlichen System ignoriert. Allerdings erben alle Programme oder Skripte, die das Skript via <a href="commands/Run.htm">Run</a> oder <a href="commands/Run.htm">RunWait</a> startet, in der Regel eine Kopie der Umgebungsvariablen des übergeordneten Skripts.</p>
<p>Mit <a href="commands/EnvGet.htm">EnvGet</a> kann eine Umgebungsvariable abgerufen werden. Zum Beispiel:</p>
<pre>Pfad := EnvGet("PATH")</pre>

<h3 id="variable-references">Variablenreferenzen (VarRef)</h3>
<p>Innerhalb eines Ausdrucks wird jede Variablenreferenz automatisch in ihren Inhalt aufgelöst, sofern sie nicht das Ziel einer <a href="Variables.htm#AssignOp">Zuweisung</a> oder des <a href="Variables.htm#ref">Referenzoperators (&amp;)</a> ist. Mit anderen Worten: Ruft man <code>MeineFunktion(MeineVar)</code> auf, wird der Wert von <em>MeineVar</em> an <em>MeineFunktion</em> übergeben, nicht die Variable selbst. Die Funktion hätte dann eine eigene lokale Variable (den Parameter) mit dem gleichen Wert wie <em>MeineVar</em>, wäre aber nicht in der Lage, <em>MeineVar</em> einen neuen Wert zuzuweisen. Kurz gesagt, der Parameter wird <em>als Wert</em> übergeben.</p>
<p>Mit dem <a href="Variables.htm#ref">Referenzoperator (&amp;)</a> kann eine Variable wie ein Wert behandelt werden. <code>&amp;MeineVar</code> erzeugt eine VarRef, die wie jeder andere Wert verwendet werden kann: Sie kann einer anderen Variable oder Eigenschaft zugewiesen, in ein Array eingefügt, an eine Funktion übergeben oder von einer Funktion zurückgegeben werden, usw. Eine VarRef kann verwendet werden, um bei einer Zuweisung die ursprüngliche Zielvariable wiederzuverwenden oder ihren Wert per <a href="Variables.htm#deref">Dereferenzierung</a> abzurufen.</p>
<p>Um einen Funktionsparameter <a href="Functions.htm#ByRef">als Referenz</a> (ByRef) zu deklarieren, präfixieren Sie einfach den Parameternamen mit einem Und-Zeichen (&amp;). Dadurch wird erreicht, dass der Aufrufer eine VarRef übergibt und dass die Funktion selbst die VarRef "dereferenzieren" kann, indem sie einfach auf den Parameter verweist (ohne Prozentzeichen).</p>
<pre>class VarRef extends Any</pre>
<p>Die VarRef-Klasse hat aktuell keine vordefinierten Methoden oder Eigenschaften, aber Sie können mit <code>Wert is VarRef</code> testen, ob ein Wert eine VarRef ist.</p>
<p>Wenn eine VarRef als Parameter einer COM-Methode verwendet wird, wird das Objekt selbst nicht übergeben. Stattdessen wird ihr Wert in einen temporären VARIANT kopiert, der mit dem <a href="commands/ComObjType.htm#vt">Variantentyp</a> <code>VT_BYREF|VT_VARIANT</code> übergeben wird. Nach Abschluss der Methode wird der neue Wert an die VarRef zugewiesen.</p>

<h3 id="caching">Caching</h3>
<p>Obwohl eine Variable üblicherweise zum Speichern eines einzelnen Wertes gedacht ist, und dieser Wert einen bestimmten Typ (Zeichenkette, Zahl oder Objekt) hat, wandelt AutoHotkey automatisch zwischen Zahlen und Zeichenketten bei Fällen wie <code>"Wert ist " meineZahl</code> und <code>MsgBox meineZahl</code> um. Da solche Umwandlungen sehr häufig vorkommen können, wird jedes Mal, wenn eine Variable, die eine Zahl enthält, in eine Zeichenkette umgewandelt wird, das Ergebnis in der Variable <em>zwischengespeichert</em>.</p>
<p>Momentan wird AutoHotkey v2 eine reine Zahl nur zwischenspeichern, wenn eine reine Zahl in eine Variable gespeichert wird, nicht wenn sie gelesen wird. Dadurch bleibt die Möglichkeit erhalten, zwischen Zeichenketten und reinen Zahlen zu unterscheiden (z. B. bei der <a href="commands/Type.htm">Type</a>-Funktion oder bei der Übergabe von Werten an COM-Objekte).</p>

<h3 id="Related">Siehe auch</h3>
<ul>
  <li><a href="Variables.htm#Intro">Variablen</a>: Grundlegende Verwendung und Beispiele.</li>
  <li><a href="Variables.htm#cap">Kapazität und Speicher einer Variable</a>: Einzelheiten über die Limitierungen.</li>
</ul>

<h2 id="functions">Funktionen</h2>
<p>Eine <em>Funktion</em> ist das Werkzeug des Skripts, um <em>etwas zu tun</em>.</p>
<p>Funktionen haben unterschiedliche Einsatzmöglichkeiten. Einige Funktionen führen lediglich eine einfache Berechnung durch, während andere sofort sichtbare Effekte erzielen, wie z. B. das Verschieben eines Fensters. Eine der Stärken von AutoHotkey ist die Leichtigkeit, mit der Skripte andere Programme automatisieren und viele andere häufige Aufgaben erledigen können, indem man einfach nur ein paar Funktionen aufruft. Beispiele finden Sie in der <a href="commands/index.htm">Funktionsliste</a>.</p>
<p>In dieser Dokumentation werden einige gebräuchliche Wörter auf eine Art und Weise verwendet, die für jemanden ohne Vorkenntnisse nicht offensichtlich ist. Nachfolgend finden Sie einige solcher Wörter/Phrasen, die häufig in Bezug auf Funktionen genutzt werden:</p>
<dl>
  <dt id="call">Eine Funktion aufrufen</dt>
  <dd><p>Der <em>Aufruf</em> einer Funktion veranlasst das Programm, diese Funktion zu starten, auszuführen oder auszuwerten. Das heißt, dass ein <em>Funktionsaufruf</em> die Kontrolle des Skripts vorübergehend an die Funktion übergibt. Wenn die Funktion ihren Zweck erfüllt hat, gibt sie die Kontrolle via <em>Return</em> wieder an das Skript zurück. Das heißt, dass jeglicher Code nach dem Funktionsaufruf erst ausgeführt wird, wenn die Funktion ihr Ende erreicht hat.</p>
  <p>Manchmal ist es jedoch so, dass eine Funktion abgeschlossen ist, bevor ihre Auswirkungen für den Benutzer sichtbar werden. Zum Beispiel könnte die <a href="commands/Send.htm">Send</a>-Funktion bereits ihre Tastendrücke <em>gesendet</em> haben, bevor sie überhaupt ihr Ziel erreicht und ihre gewollte Wirkung erzielt haben.</p></dd>
  <dt id="parameters">Parameter</dt>
  <dd><p>Normalerweise akzeptiert eine Funktion einen oder mehrere <em>Parameter</em>, die vorschreiben, wie oder womit sie agieren soll. Jeder Parameter ist ein <a href="#values">Wert</a>, z. B. eine Zeichenkette oder Zahl. Die Parameter von <a href="commands/WinMove.htm">WinMove</a> beispielsweise bestimmen, welches Fenster wohin verschoben werden soll. Parameter werden auch als <em>Argumente</em> bezeichnet. Gängige Abkürzungen sind <em>Param</em> und <em>Arg</em>.</p></dd>
  <dt id="pass-parameters">Parameter übergeben</dt>
  <dd><p>Parameter werden an eine Funktion <em>übergeben</em>; das heißt, dass für jeden Parameter der Funktion beim Aufrufen ein Wert angegeben ist. Zum Beispiel kann man den Namen einer Taste an <a href="commands/GetKeyState.htm">GetKeyState</a> <em>übergeben</em>, um festzustellen, ob diese Taste gedrückt gehalten wird.</p></dd>
  <dt id="return-a-value">Einen Wert zurückgeben</dt>
  <dd><p>Funktionen geben ein Wert via <em>Return</em> zurück, deshalb wird das Ergebnis der Funktion oft als <em>Rückgabewert</em> bezeichnet. <a href="commands/StrLen.htm">StrLen</a> beispielsweise gibt die Anzahl der Zeichen zurück, die in einer Zeichenkette enthalten sind. Funktionen können Ergebnisse auch in Variablen ablegen, z. B. wenn sie mehr als ein Ergebnis zurückgeben müssen (siehe <a href="Functions.htm#return">Rückgabewerte</a>).</p></dd>
  <dt id="command">Befehl</dt>
  <dd><p>Ein Funktionsaufruf wird manchmal auch als <em>Befehl</em> bezeichnet, weil quasi dem Programm <em>befohlen</em> wird, eine bestimmte Aktion auszuführen. (Aus historischen Gründen kann der Begriff <em>Befehl</em> auf eine bestimmte Form des Funktionsaufrufs bezogen werden, wo die Klammern weggelassen werden und der Rückgabewert verworfen wird. Aber technisch gesehen ist das eine <a href="Language.htm#function-call-statements">Funktionsaufrufanweisung</a>.)</p></dd>
</dl>
<p>Funktionen erwarten normalerweise, dass Parameter in einer bestimmten Reihenfolge geschrieben werden, deshalb ist die Bedeutung der einzelnen Parameterwerte abhängig von ihrer Position in der via Komma getrennten Parameterliste. Einige Parameter können weg bzw. leer gelassen werden - in diesem Fall aber kann das darauffolgende Komma nur weggelassen werden, wenn alle übrigen Parameter ebenfalls weggelassen werden. Die Syntax für <a href="commands/ControlSend.htm">ControlSend</a> lautet zum Beispiel:</p>
<pre class="Syntax"><span class="func">ControlSend</span> Tasten <span class="optional">, Steuerelement, FensterTitel, FensterText, IgnoriereTitel, IgnoriereText</span>
</pre>
<p>Die eckigen Klammern signalisieren, dass die darin enthaltenen Parameter optional sind (die Klammern selbst sollten nicht im eigentlichen Code erscheinen). In der Regel muss man aber auch das Zielfenster angeben. Zum Beispiel:</p>
<pre>
ControlSend "^{Home}", "Edit1", "A"  <em>; Korrekt. Steuerelement ist angegeben.</em>
ControlSend "^{Home}", "A"           <em>; Falsch: Parameter stimmen nicht überein.</em>
ControlSend "^{Home}",, "A"          <em>; Korrekt. Steuerelement wurde weggelassen.</em>
</pre>

<h3 id="methods">Methoden</h3>
<p>Eine <em>Methode</em> ist eine Funktion, die einem bestimmten <a href="#objects">Objekt</a> oder Objekttyp zugeordnet ist. Um eine Methode aufzurufen, müssen Sie ein Objekt und einen Methodennamen angeben. Der Methodenname identifiziert die Funktion nicht eindeutig; es hängt vom Objekt ab, was beim Methodenaufruf passieren soll. Zum Beispiel könnte <code>x.Show()</code> <a href="objects/Menu.htm#Show">ein Menü anzeigen</a>, <a href="objects/Gui.htm#Show">eine GUI anzeigen</a>, einen Fehler auslösen oder etwas anderes tun, je nachdem, was <code>x</code> ist. Das heißt, dass ein Methodenaufruf einfach eine Meldung an das Objekt übergibt, damit es etwas tut. Weitere Informationen finden Sie unter <a href="#object-protocol">Objektorientierte Schnittstelle</a> und <a href="Language.htm#operators-for-objects">Operatoren für Objekte</a>.</p>

<h2 id="control-flow">Kontrollfluss</h2>
<p>Der <em>Kontrollfluss</em> ist die Reihenfolge, in der die einzelnen Anweisungen ausgeführt werden. Im Normalfall werden Anweisungen der Reihe nach von oben nach unten ausgeführt, allerdings kann dieses Verhalten mit einer Kontrollanweisung überschrieben werden, indem man Anweisungen z. B. wiederholt ausführen lässt, oder wenn eine bestimmte Bedingung erfüllt ist.</p>
<dl>
  <dt id="statement">Anweisung</dt>
  <dd><p>Eine <em>Anweisung</em> ist einfach gesagt das kleinste eigenständige Element der Sprache, das eine ausführende Aktion ausdrückt. In AutoHotkey sind Anweisungen Zuweisungen, Funktionsaufrufe und andere Ausdrücke. Direktiven, Zweifach-Doppelpunkt-Tags von Hotkeys und Hotstrings, und Deklarationen ohne Zuweisungen sind hingegen keine Anweisungen; sie werden verarbeitet, sobald das Programm startet und bevor das Skript <em>ausgeführt</em> wird.</p></dd>
  <dt id="execute">Ausführen</dt>
  <dd><p>Ausführen, Durchführen, Auswerten, Umsetzen und so weiter. <em>Ausführen</em> hat grundsätzlich die gleiche Bedeutung wie im normalen Sprachgebrauch.</p></dd>
  <dt id="cf-body">Körper</dt>
  <dd><p>Der <em>Körper</em> einer Kontrollanweisung ist die Anweisung oder Anweisungsgruppe, zu der sie gehört. Zum Beispiel wird der Körper einer <a href="commands/If.htm">if-Anweisung</a> nur ausgeführt, wenn eine bestimmte Bedingung erfüllt ist.</p></dd>
</dl>
<p>Schauen Sie sich zum Beispiel die folgenden Instruktionen an:</p>
<ol>
  <li>Öffne Notepad</li>
  <li>Warte, bis Notepad auf dem Bildschirm erscheint</li>
  <li>Schreibe "Hallo, Welt!"</li>
</ol>
<p>Wir machen einen Schritt nach dem anderen, und wenn dieser Schritt beendet ist, gehen wir zum nächsten Schritt über. Auf die gleiche Weise funktioniert üblicherweise der Kontrollfluss in einem Programm oder Skript - er geht die Anweisungen schrittweise durch. Aber was ist, wenn wir etwas in ein vorhandenes Notepad-Fenster schreiben wollen? Schauen Sie sich die folgenden überarbeiteten Instruktionen an:</p>
<ol>
  <li>Wenn Notepad nicht läuft:
<ol>
  <li>Öffne Notepad</li>
  <li>Warte, bis Notepad auf dem Bildschirm erscheint</li>
</ol>
</li>
  <li>Ansonsten:
<ol>
  <li>Aktiviere Notepad</li>
</ol>
</li>
  <li>Schreibe "Hallo, Welt!"</li>
</ol>
<p>Wir öffnen also entweder Notepad oder aktivieren Notepad, je nachdem, ob es bereits läuft. Punkt 1 ist eine <em>bedingte Anweisung</em>, auch bekannt als <em>if-Anweisung</em>; das heißt, dass wir ihren <em>Körper</em> (Punkt 1.1 bis Punkt 1.2) nur ausführen, wenn eine Bedingung erfüllt ist. Punkt 2 ist eine <em>else-Anweisung</em>; wir führen ihren Körper (Punkt 2.1) nur aus, wenn die Bedingung einer vorherigen <em>if-Anweisung</em> nicht erfüllt ist. Je nach Bedingung <em>läuft</em> die Steuerung auf zwei Arten ab: Punkt 1 (if true) → Punkt 1.1 → Punkt 1.2 → Punkt 3; oder Punkt 1 (if false) → Punkt 2 (else) → Punkt 2.1 → Punkt 3.</p>
<p>Die obigen Instruktionen können in den folgenden Code umgewandelt werden:</p>
<pre>if (not WinExist("ahk_class Notepad"))
{
    Run "Notepad"
    WinWait "ahk_class Notepad"
}
else
    WinActivate "ahk_class Notepad"
Send "Hallo, Welt!"
</pre>
<p>In unseren schriftlichen Instruktionen haben wir Einrückungen und Nummerierungen verwendet, um die Anweisungen zu gruppieren. Skripte funktionieren etwas anders. Obwohl die Einrückung den Code besser lesbar macht, hat sie in AutoHotkey keinen Einfluss auf die Gruppierung von Anweisungen. Stattdessen werden Anweisungen gruppiert, indem man sie, wie oben gezeigt, mit geschweiften Klammern umschließt. Dies wird als <a href="commands/Block.htm"><em>Block</em></a> bezeichnet.</p>
<p class="note">Details zur Syntax - also wie man Kontrollanweisungen in AutoHotkey schreibt oder erkennt - finden Sie unter <a href="Language.htm#control-flow">Kontrollfluss</a>.</p>

<h2 id="details">Details</h2>

<h3 id="string-encoding">Zeichenkettencodierung</h3>
<p>Jedes Zeichen in der Zeichenkette entspricht einer Zahl, auch <em>Ordinalzahl</em> genannt, oder einem <em>Zeichencode</em>. Der Wert "Abc" würde zum Beispiel wie folgt dargestellt werden:</p>
<table class="info" style="width: 8em; text-align: center">
  <tr><td>A</td><td>b</td><td>c</td></tr>
  <tr><td>65</td><td>98</td><td>99</td><td>0</td></tr>
</table>
<p><strong>Codierung:</strong> Die <em>Codierung</em> einer Zeichenkette definiert, wie Symbole mit den Ordinalzahlen und Ordinalzahlen mit den Bytes verknüpft werden. Es gibt viele verschiedene Codierungen, aber da alle Codierungen, die AutoHotkey unterstützt, ASCII als Untermenge enthalten, haben die Zeichencodes 0 bis 127 immer die gleiche Bedeutung. So hat zum Beispiel 'A' immer den Zeichencode 65.</p>
<p id="null-termination"><strong>Null-Terminierung:</strong> Jede Zeichenkette ist/wird mit einem "Nullzeichen" terminiert; solche Zeichen haben einen Ordinalwert von Null und markieren das Ende einer Zeichenkette. Die Länge der Zeichenkette kann anhand der Position des Nullterminators abgeleitet werden, aber AutoHotkey speichert die Länge auch, um die Leistung zu verbessern und um Nullzeichen innerhalb der Zeichenkette zu ermöglichen.</p>
<p class="warning"><strong>Hinweis:</strong> Aufgrund der Abhängigkeit von Null-Terminierung unterstützen viele interne Funktionen und die meisten Ausdrucksoperatoren keine Zeichenketten mit eingebetteten Nullzeichen und lesen eine Zeichenkette stattdessen nur bis zum ersten Nullzeichen. Es wird jedoch eine grundlegende Manipulation solcher Zeichenketten unterstützt; z. B. Verkettung, <code>==</code>, <code>!==</code>, <code>Chr(0)</code>, <a href="commands/StrLen.htm">StrLen</a>, <a href="commands/SubStr.htm">SubStr</a>, Zuweisungen, Parameterwerte und <a href="commands/Return.htm">return</a>.</p>
<p id="native-encoding"><strong>Native Codierung:</strong> Obwohl AutoHotkey Möglichkeiten bereitstellt, Texte mit unterschiedlichen Codierungen zu bearbeiten, gehen die internen Funktionen -- und bis zu einem gewissen Grad auch die Sprache selbst -- davon aus, dass Zeichenkettenwerte in einer bestimmten Codierung vorliegen. Dies wird als <em>native</em> Codierung bezeichnet. Die native Kodierung hängt von der Version von AutoHotkey ab:</p>
<ul>
  <li>
<p>Unicode-Versionen von AutoHotkey verwenden UTF-16. Das kleinste Element in einer UTF-16-Zeichenkette ist zwei Bytes (16 Bit) groß. Unicode-Zeichen im Bereich von 0 bis 65535 (U+FFFF) werden von einer einzigen 16-Bit-Codeeinheit des gleichen Wertes repräsentiert, während Zeichen im Bereich von 65536 (U+10000) bis 1114111 (U+10FFFF) von einem <em>Ersatzzeichenpaar</em> repräsentiert werden; also exakt zwei 16-Bit-Codeeinheiten zwischen 0xD800 und 0xDFFF. (weitere Details zu Ersatzzeichenpaaren und Methoden zum Codieren oder Decodieren solcher finden Sie im Internet.)</p>
</li>
  <li>
<p>ANSI-Versionen von AutoHotkey verwenden den Standard-ANSI-Zeichensatz des Systems, abhängig von den Sprach- und Regionseinstellungen des Systems oder von der Systemeinstellung "Sprache für Unicode-inkompatible Programme". Das kleinste Element einer ANSI-Zeichenkette ist ein Byte groß. Einige Zeichensätze enthalten jedoch Zeichen, die durch Sequenzen von mehreren Bytes repräsentiert werden (das sind immer ASCII-fremde Zeichen).</p>
</li>
</ul>
<p class="note"><strong>Hinweis:</strong> AutoHotkey v2 verwendet von sich aus Unicode und verfügt nicht über eine ANSI-Version.</p>
<p id="character"><strong>Zeichen:</strong> In der Regel verwenden andere Bereiche dieser Dokumentation den Begriff "Zeichen" für die kleinste Einheit einer Zeichenkette; Bytes für ANSI-Zeichenketten und 16-Bit-Codeeinheiten für Unicode-Zeichenketten (UTF-16). Aus praktischen Gründen werden die Länge einer Zeichenkette und die Positionen innerhalb einer Zeichenkette anhand dieser festen Größen gemessen, auch wenn es sich dabei möglicherweise nicht um vollständige Unicode-Zeichen handelt.</p>
<p><a href="commands/FileRead.htm">FileRead</a>, <a href="commands/FileAppend.htm">FileAppend</a>, <a href="commands/FileOpen.htm">FileOpen</a> und das <a href="objects/File.htm">File-Objekt</a> bieten Möglichkeiten, um den Text von Dateien mit einer bestimmten Codierung zu lesen und zu schreiben.</p>
<p>Die Funktionen <a href="commands/StrGet.htm">StrGet</a> und <a href="commands/StrPut.htm">StrPut</a> können genutzt werden, um Zeichenketten zwischen der nativen Codierung und einer anderen angegebenen Codierung umzuwandeln. Diese Funktionen sind jedoch in der Regel nur in Kombination mit Datenstrukturen und der <a href="commands/DllCall.htm">DllCall</a>-Funktion sinnvoll. Zeichenketten, die direkt an oder von <a href="commands/DllCall.htm">DllCall</a> übergeben werden, können mithilfe der Parametertypen <code>AStr</code> oder <code>WStr</code> in ANSI oder UTF-16 umgewandelt werden.</p>
<p>Techniken, wie man mit den Unterschieden zwischen ANSI- und Unicode-Versionen von AutoHotkey umgehen kann, finden Sie unter <a href="Compat.htm#Format">Unicode vs ANSI</a>.</p>

<h3 id="pure-numbers">Reine Zahlen</h3>
<p>Eine <em>reine</em> oder <em>binäre</em> Zahl ist eine im Speicher enthaltene Zahl, mit deren Format die CPU des Computers direkt umgehen kann, um z. B. Berechnungen durchzuführen. In den meisten Fällen wandelt AutoHotkey automatisch zwischen numerischen Zeichenketten und reinen Zahlen um, die nur selten unterschiedlich behandelt werden. AutoHotkey verwendet hauptsächlich zwei Datentypen für reine Zahlen:</p>
<ul>
  <li>vorzeichenfähige 64-Bit-Integer (<em>int64</em>).</li>
  <li>binäre 64-Bit-Floating-Point-Zahlen (das <em>Double</em>- oder <em>Binary64</em>-Format des internationalen Standards IEEE 754).</li>
</ul>
<p>Mit anderen Worten sind Skripte von folgenden Einschränkungen betroffen:</p>
<ul>
  <li>
<p>Integer müssen im vorzeichenfähigen 64-Bit-Bereich sein; also von -9223372036854775808 (-0x8000000000000000, oder -2<sup>63</sup>) bis 9223372036854775807 (0x7FFFFFFFFFFFFFFF, oder 2<sup>63</sup>-1). Wenn eine Integer-Konstante in einem Ausdruck außerhalb dieses Bereichs liegt, werden nur die niedrigen 64 Bit verwendet (der Wert wird gekürzt). Obwohl größere Werte in einer Zeichenkette enthalten sein können, wird jeder Versuch, die Zeichenkette in eine Zahl umzuwandeln (z. B. in einer mathematischen Operation), bewirken, dass sie auf die gleiche Weise gekürzt wird.</p>
</li>
  <li>
<p>Floating-Point-Zahlen unterstützen in der Regel eine Genauigkeit von 15 Nachkommastellen.</p>
</li>
</ul>
<p id="float-imprecision"><strong>Hinweis:</strong> Es gibt einige Nachkommastellen, die das binäre Floating-Point-Format nicht exakt darstellen kann und die Zahl deshalb auf die nächstliegende darstellbare Zahl rundet. Dies kann zu unerwarteten Ergebnissen führen. Zum Beispiel:</p>
<pre>
MsgBox 0.1 + 0           <em>; 0.10000000000000001</em>
MsgBox 0.1 + 0.2         <em>; 0.30000000000000004</em>
MsgBox 0.3 + 0           <em>; 0.29999999999999999</em>
MsgBox 0.1 + 0.2 = 0.3   <em>; 0 (nicht identisch)</em>
</pre>
<p>Eine Strategie zur Bewältigung dieses Problems besteht darin, den direkten Vergleich zu vermeiden und stattdessen die Differenz zu vergleichen. Zum Beispiel:</p>
<pre>MsgBox Abs((0.1 + 0.2) - (0.3)) &lt; 0.0000000000000001
</pre>
<p>Eine andere Strategie ist es, vor dem Vergleich explizit Rundungen vorzunehmen, indem man z. B. die Umwandlung in eine Zeichenkette durchführt. Es gibt in der Regel zwei Möglichkeiten, dies zu tun, während Sie die Genauigkeit angeben:</p>
<pre>MsgBox Round(0.1 + 0.2, 15) = Format("{:.15f}", 0.3)
</pre>

<h3 id="names">Namen</h3>
<p>AutoHotkey wendet die gleichen Regeln für die Benennung verschiedener Dinge an, inklusive Variablen, Funktionen, <a href="commands/GroupAdd.htm">Fenstergruppen</a>, Klassen, Eigenschaften und Methoden. Die Regeln lauten wie folgt.</p>
<p><strong>Groß- und Kleinschreibung:</strong> Für ASCII-Zeichen nicht relevant. Zum Beispiel ist <code>AktuellesDatum</code> das gleiche wie <code>aktuellesdatum</code>. ASCII-fremde Großbuchstaben wie "Ä" sind jedoch <em>nicht</em> identisch zu ihren Kleinbuchstaben, unabhängig von den aktuellen Sprach- und Regionseinstellungen des Benutzers. Dies hilft dem Skript, sich über mehrere Sprach- und Regionseinstellungen hinweg konsistent zu verhalten.</p>
<p><strong>Maximale Länge:</strong> 253 Zeichen.</p>
<p><strong>Erlaubte Zeichen:</strong> Buchstaben, Ziffern, Unterstrich und ASCII-fremde Zeichen; allerdings darf das erste Zeichen keine Ziffer sein.</p>
<p id="reserved-words"><strong>Reservierte Wörter:</strong> <code>as</code>, <code>and</code>, <code>contains</code>, <code>false</code>, <code>in</code>, <code>is</code>, <code>IsSet</code>, <code>not</code>, <code>or</code>, <code>super</code>, <code>true</code>, <code>unset</code>. Diese Wörter sind für zukünftige Anwendungen oder andere spezifische Zwecke reserviert.</p>
<p>Schlüsselwörter von Deklarationen und Namen von Kontrollanweisungen sind auch reserviert, hauptsächlich um Fehler aufzuspüren. Dazu gehören: <code>Break</code>, <code>Catch</code>, <code>Continue</code>, <code>Else</code>, <code>Finally</code>, <code>For</code>, <code>Global</code>, <code>Goto</code>, <code>If</code>, <code>Local</code>, <code>Loop</code>, <code>Return</code>, <code>Static</code>, <code>Throw</code>, <code>Try</code>, <code>Until</code>, <code>While</code></p>
<p>Namen von Eigenschaften, Methoden und Fenstergruppen dürfen als reservierte Wörter verwendet werden.</p>

<h3 id="references-to-objects">Objektreferenzen</h3>
<p>Ein Skript interagiert mit einem Objekt nicht direkt, sondern via <em>Referenz</em> zum Objekt. Wenn Sie ein Objekt erstellen, wird das Objekt an einem Ort erstellt, den Sie nicht kontrollieren können, und eine Referenz an Sie übergeben. Wenn Sie diese Referenz an eine Funktion übergeben oder in eine Variable oder in einem anderen Objekt speichern, wird eine neue Referenz zum <em>selben</em> Objekt erstellt.</p>
<p>Wenn zum Beispiel <em>meinObj</em> eine Referenz zu einem Objekt enthält, erstellt <code>deinObj := meinObj</code> eine neue Referenz zum gleichen Objekt. Eine Änderung wie <code>meinObj.ans := 42</code> würde sich sowohl in <code>meinObj.ans</code> als auch in <code>deinObj.ans</code> widerspiegeln, da beide auf dasselbe Objekt verweisen. <code>meinObj := Object()</code> wirkt sich jedoch nur auf die <em>meinObj</em>-Variable aus, nicht auf die <em>deinObj</em>-Variable, die immer noch auf das ursprüngliche Objekt verweist.</p>
<p>Um eine Referenz freizugeben, verwenden Sie einfach eine Zuweisung und ersetzen Sie sie mit einem anderen Wert. Ein Objekt wird erst gelöscht, wenn alle Referenzen freigegeben sind; das heißt, dass es weder möglich noch lohnenswert ist, ein Objekt explizit zu löschen. (Sie können jedoch die Eigenschaften, den Inhalt oder die zugehörigen Ressourcen eines Objekts löschen, wie z. B. die Elemente eines <a href="objects/Array.htm">Arrays</a>, das zugeordnete Fenster eines <a href="objects/Gui.htm">Gui</a>-Objekts, das Menü eines <a href="objects/Menu.htm">Menu</a> Objekts, und so weiter.)</p>
<pre>Ref1 := Object()  <em>; Erstellt ein Objekt und speichert die erste Referenz</em>
Ref2 := Ref1      <em>; Erstellt eine neue Referenz zum selben Objekt</em>
Ref1 := ""        <em>; Gibt die erste Referenz frei</em>
Ref2 := ""        <em>; Gibt die zweite Referenz frei; Objekt wird gelöscht</em>
</pre>
<p>Wenn das schwer zu verstehen ist, sollten Sie versuchen, sich ein Objekt als Mietwohnung vorzustellen. Wenn Sie eine Wohnung mieten, erhalten Sie einen Schlüssel, mit dem sie die Wohnung betreten können. Sie können mehr Schlüssel erhalten und sie benutzen, um die Wohnung zu betreten, aber sobald Sie vorhaben, die Wohnung endgültig zu verlassen, müssen Sie alle Schlüssel an den Vermieter zurückgeben. In der Regel wird eine Wohnung nicht <em>gelöscht</em>, aber vielleicht muss die Hausverwaltung jemanden beauftragen, der Ihren zurückgelassenen Müll wegräumt; genauso wie der Fall, dass die Werte, die Sie in ein Objekt gespeichert haben, freigegeben werden, wenn das Objekt gelöscht wird.</p>

</body>
</html>
