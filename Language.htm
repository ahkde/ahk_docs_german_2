<!DOCTYPE HTML>
<html lang="de">
<head>
<title>Skriptsprache | AutoHotkey v2</title>
<meta name="description" content="Erfahren Sie mehr über die Sprache wie Kommentare, Ausdrücke, Kontrollanweisungen, Struktur eines Skripts, etc." />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="robots" content="noindex, nofollow">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
<script src="static/ga4.js" type="text/javascript"></script>
</head>
<body>
<h1>Skriptsprache</h1>
<p>Ein AutoHotkey-Skript ist im Grunde eine Reihe von Instruktionen, die das Programm befolgen muss und in einer benutzerdefinierten Sprache geschrieben ist, die nur AutoHotkey versteht. Diese Sprache weist einige Ähnlichkeiten mit anderen Skriptsprachen auf, hat aber auch ihre eigenen Stärken und Schwächen. Dieses Dokument beschreibt die Sprache und versucht zudem, häufig auftretende Problemfälle aufzuzeigen.</p>
<p class="note">Unter <a href="Concepts.htm">Konzepte und Konventionen</a> finden Sie eine allgemeinere Erklärung der verschiedenen Konzepte, auf die AutoHotkey basiert.</p>

<h2 id="toc">Inhaltsverzeichnis</h2>
<ul>
  <li><a href="#general-conventions">Allgemeine Konventionen</a></li>
  <li><a href="#comments">Kommentare</a></li>
  <li><a href="#expressions">Ausdrücke (Expressions)</a>
  <ul>
    <li><a href="#strings">Zeichenketten / Text</a></li>
    <li><a href="#variables">Variablen</a></li>
    <li><a href="#constants">Konstanten</a></li>
    <li><a href="#operators">Operatoren</a></li>
    <li><a href="#function-calls">Funktionsaufrufe</a>
    <ul>
      <li><a href="#function-call-statements">Funktionsaufrufanweisungen</a></li>
      <li><a href="#optional-parameters">Optionale Parameter</a></li>
    </ul></li>
    <li><a href="#operators-for-objects">Operatoren für Objekte</a></li>
    <li><a href="#expression-statements">Ausdrucksanweisungen</a></li>
  </ul></li>
  <li><a href="#control-flow">Kontrollanweisungen</a>
  <ul>
    <li><a href="#control-flow-vs">Kontrollfluss vs. andere Anweisungen</a></li>
    <li><a href="#loop-statement">Loop-Anweisung</a></li>
    <li><a href="#not-control-flow">Kein Kontrollfluss</a></li>
  </ul></li>
  <li><a href="#structure-of-a-script">Aufbau eines Skripts</a>
  <ul>
    <li><a href="#global-code">Globaler Code</a></li>
    <li><a href="#functions">Funktionen</a></li>
    <li><a href="#-include">#Include</a></li>
  </ul></li>
  <li><a href="#misc">Verschiedenes</a>
  <ul>
    <li><a href="#dynamic-variables">Dynamische Variablen</a>
    <ul>
      <li><a href="#pseudo-arrays">Pseudo-Arrays</a></li>
    </ul></li>
    <li><a href="#labels">Label</a></li>
  </ul></li>
</ul>
<!-- TODO:
Directives
Declarations
Class definitions
Methods?
-->

<h2 id="general-conventions">Allgemeine Konventionen</h2>
<p><strong>Namen:</strong> Variablen- und Funktionsnamen sind nicht Groß-/Kleinschreibung-sensitiv (zum Beispiel wäre <code>AktuellesDatum</code> das gleiche wie <code>aktuellesdatum</code>). Einzelheiten wie maximale Länge und verwendbare Zeichen finden Sie unter <a href="Concepts.htm#names">Namen</a>.</p>
<p><strong>Keine typisierten Variablen:</strong> Variablen haben keinen explizit definierten Typ; stattdessen kann ein beliebiger Wert in eine beliebige Variable (außer Konstante und interne Variable) gespeichert werden. Zahlen können je nach Situation automatisch in Zeichenketten (Text) umgewandelt werden und umgekehrt.</p>
<p><strong>Deklarationen sind optional:</strong> Im Normalfall müssen Variablen nicht deklariert werden (in <a href="Functions.htm">Funktionen</a> gibt es Ausnahmen). Allerdings wird der Versuch, eine Variable zu lesen, bevor ihr ein Wert zugewiesen wurde, als Fehler angesehen.</p>
<p><strong>Leer- und Tabulatorzeichen werden größtenteils ignoriert:</strong> Einrückungen (Leer- und Tabulatorzeichen am Anfang) sind wichtig, um den Code besser lesbar zu machen, allerdings werden sie nicht vom Programm benötigt und werden in der Regel ignoriert. Leer- und Tabulatorzeichen werden <em>grundsätzlich</em> am Ende einer Zeile und innerhalb eines Ausdrucks (außer zwischen Anführungszeichen) ignoriert. Allerdings sind solche Zeichen in einigen Fällen signifikant:</p>
<ul>
  <li><a href="#function-calls">Funktions</a>- und Methodenaufrufe verlangen, dass zwischen dem Funktions-/Methodennamen und <code>(</code> kein Leerzeichen steht.</li>
  <li>Leerzeichen werden zum Verketten von Elementen benötigt.</li>
  <li>Zwischen zwei Operatoren sind eventuell Leerzeichen erforderlich, um Mehrdeutigkeiten zu vermeiden.</li>
  <li>Einzeilige <a href="#comments">Kommentare</a> müssen mit einem Leerzeichen beginnen, wenn sie nicht am Zeilenanfang stehen.</li>
</ul>
<p><strong>Zeilenumbrüche sind von Bedeutung:</strong> Zeilenumbrüche dienen in der Regel als Trennzeichen für Anweisungen und terminieren den vorherigen Funktionsaufruf oder eine andere Anweisung. (Eine <em>Anweisung</em> ist einfach gesagt das kleinste eigenständige Element der Sprache, das eine ausführende Aktion ausdrückt.) Die Ausnahme davon ist die Zeilenfortsetzung (siehe unten).</p>
<p><strong>Zeilenfortsetzung:</strong> Lange Zeilen können in mehreren kurzen Zeilen aufgeteilt werden, um die Übersichtlichkeit und Wartbarkeit des Skripts zu erhöhen. Dies erfolgt präprozedural; das heißt, dass sie im eigentlichen Sinne nicht zur Sprache gehört. Es gibt drei Methoden:</p>
<ul>
  <li><a href="Scripts.htm#continuation-line">Fortsetzungspräfix</a>: Zeilen, die mit einem <a href="Variables.htm#operators">Ausdrucksoperator</a> beginnen (außer ++ und --), werden mit der vorherigen Zeile verbunden. Zeilen werden immer zusammengeführt, egal ob die Zeile tatsächlich einen Ausdruck enthält.</li>
  <li><a href="Scripts.htm#continuation-expr">Fortsetzung durch Umschließen</a>: Ein Teilausdruck, der mit (), [] oder {} umschlossen ist, kann in den meisten Fällen automatisch mehrere Zeilen umfassen.</li>
  <li><a href="Scripts.htm#continuation-section">Fortsetzungsbereich</a>: Ein Bereich mit mehreren Zeilen, der mit <code>(</code> beginnt und mit <code>)</code> endet, wird mit der Zeile darüber verbunden (beide Symbole müssen am Anfang einer Zeile stehen, mit oder ohne Leerzeichen).</li>
</ul>
 

<h2 id="comments">Kommentare</h2>
<p><em>Kommentare</em> sind Textbereiche innerhalb des Skripts, die vom Programm ignoriert werden. Sie werden in der Regel eingesetzt, um Erklärungen hinzuzufügen oder Teile des Codes zu deaktivieren.</p>
<p>Um in Skripten etwas zu kommentieren, muss am Anfang einer Zeile ein Semikolon gesetzt werden. Zum Beispiel:</p>
<pre><em>; Diese ganze Zeile ist ein Kommentar.</em></pre>
<p>Kommentare können auch am Ende einer Zeile stehen - in diesem Fall muss auf der linken Seite des Semikolons mindestens ein Leer- oder Tabulatorzeichen erfolgen. Zum Beispiel:</p>
<pre>Run "Notepad"  <em>; Dieser Kommentar befindet sich auf derselben Zeile wie der Funktionsaufruf.</em></pre>
<p>Mithilfe der Symbole <code><em>/*</em></code> und <code><em>*/</em></code> können ganze Bereiche auskommentiert werden. Zum Beispiel:</p>
<pre><em>/*
MsgBox "Diese Zeile ist auskommentiert (deaktiviert)."
MsgBox "Häufiger Fehler:" */ " Dies beendet nicht den Kommentar."
MsgBox "Diese Zeile ist auskommentiert."
*/</em>
MsgBox "Diese Zeile ist nicht auskommentiert."
<em>/* Dies ist auch gültig, allerdings kann kein anderer Code auf diese Zeile stehen. */</em>
MsgBox "Diese Zeile ist nicht auskommentiert."
</pre>
<p>Ohne Berücksichtigung von Tabulator- und Leerzeichen muss <code><em>/*</em></code> am Anfang der Zeile erscheinen, während <code><em>*/</em></code> nur am Anfang oder Ende einer Zeile erscheinen kann. Es ist auch möglich, <code><em>*/</em></code> wegzulassen - in diesem Fall wird der Rest der Datei auskommentiert.</p>
<p>Kommentare werden beim Lesen des Skripts aus der Datei herausgefiltert, daher haben sie keinerlei Einfluss auf die Leistung oder Speicherauslastung.</p>

<h2 id="expressions">Ausdrücke (Expressions)</h2>
<p><em>Ausdrücke</em> sind Kombinationen aus ein oder mehreren <a href="Concepts.htm#values">Werten</a>, <a href="Concepts.htm#variables">Variablen</a>, <a href="#operators">Operatoren</a> und <a href="#function-calls">Funktionsaufrufen</a>. Zum Beispiel sind <code>10</code>, <code>1+1</code> und <code>MeineVar</code> gültige Ausdrücke. Ein Ausdruck nimmt in der Regel einen oder mehrere Eingabewerte, führt eine oder mehrere Operationen durch, und erzeugt einen Ausgabewert. Der Vorgang zum Herausfinden des Wertes eines Ausdrucks nennt man <em>Auswertung</em>. Der Ausdruck <code>1+1</code> wird beispielsweise zu der Zahl 2 <em>ausgewertet</em>.</p>
<p>Einfache Ausdrücke können zu immer komplexeren Ausdrücken zusammengesetzt werden können. Wenn <code>Rabatt/100</code> beispielsweise einen Rabattprozentsatz in eine Bruchzahl umwandelt, könnte man mit <code>1 - Rabatt/100</code> eine Bruchzahl errechnen, die den verbleibenden Betrag repräsentiert, und mit <code>Preis * (1 - Rabatt/100)</code> den Nettopreis errechnen.</p>
<p><em>Werte</em> sind <a href="Concepts.htm#numbers">Zahlen</a>, <a href="Concepts.htm#objects">Objekte</a> oder <a href="Concepts.htm#strings">Zeichenketten</a>. Ein <em>literaler</em> Wert ist ein Wert, der physisch in das Skript geschrieben wird; einer, den man sehen kann, wenn man auf den Code schaut.</p>

<h3 id="strings">Zeichenketten / Text</h3>
<p class="note">Eine allgemeinere Erklärung zu Zeichenketten finden Sie unter <a href="Concepts.htm#strings">Zeichenketten (Strings)</a>.</p>
<p>Eine <em><em>Zeichenkette</em></em> ist einfach nur ein Textwert. In einem Ausdruck muss direkt geschriebener Text in Hochkommas oder Anführungszeichen gesetzt werden, um ihn von einem Variablennamen oder einem anderen Ausdruck zu unterscheiden. Dieser Zustand wird oft als <em>in Anführungszeichen gesetzte, direkt geschriebene Zeichenkette</em> oder einfach nur <em>in Anführungszeichen gesetzte Zeichenkette</em> bezeichnet. Zum Beispiel: <code>"Dies ist eine in Anführungszeichen gesetzte Zeichenkette."</code> oder <code>'diese auch'</code>.</p>
<p>Um ein <em>tatsächliches</em> Anführungszeichen innerhalb einer in Anführungszeichen gesetzte Zeichenkette einzufügen, können Sie entweder die <a href="misc/EscapeChar.htm#quote">Escapesequenzen</a> <code>`"</code> oder <code>`'</code> verwenden oder das Zeichen mit den gegenteiligen Anführungszeichen umschließen. Zum Beispiel: <code>'Sie sagte: "Ein Apfel täglich."'</code>.</p>
<p>In Anführungszeichen gesetzte Zeichenketten können auch andere <a href="misc/EscapeChar.htm">Escapesequenzen</a> wie z. B. <code>`t</code> (Tabulator), <code>`n</code> (LF-Zeilenumbruchszeichen) und <code>`r</code> (CR-Zeilenumbruchszeichen) enthalten.</p>

<h3 id="variables">Variablen</h3>
<p class="note">Eine grundlegende Erklärung und allgemeine Details zu Variablen finden Sie unter <a href="Concepts.htm#variables">Variablen</a>.</p>
<p>Um <em>Variablen</em> in einem Ausdruck zu nutzen, geben Sie einfach den Namen der Variable an. Zum Beispiel: <code>A_ScreenWidth/2</code>. Allerdings können Variablen nicht in einer in Anführungszeichen gesetzten Zeichenkette verwendet werden. Stattdessen greift man auf eine Vorgehensweise zurück, die sich <a href="Variables.htm#concat"><em>Verkettung</em></a> nennt, um Variablen und andere Werte zu kombinieren. Es gibt zwei Wege, um Werte in einem Ausdruck zu <em>verketten</em>:</p>
<ul>
  <li>Implizite Verkettung: <code>"Der Wert ist " MeineVar</code></li>
  <li>Explizite Verkettung: <code>"Der Wert ist " . MeineVar</code></li>
</ul>
<p>Implizite Verkettung wird auch <em>Auto-Verkettung</em> genannt. In beiden Fällen müssen die Leerzeichen vor der Variable und der Punkt vorhanden sein.</p>
<p>Die <a href="commands/Format.htm">Format</a>-Funktion kann auch für diesen Zweck genutzt werden. Zum Beispiel:</p>
<pre>MsgBox Format("Sie verwenden AutoHotkey v{1} {2}-Bit.", A_AhkVersion, A_PtrSize*8)
</pre>
<p>Um einer Variable einen Wert zuzuweisen, müssen Sie den <a href="Variables.htm#AssignOp">Zuweisungsoperator</a> <code>:=</code> verwenden, wie z. B. in <code>MeineVar := "Beliebiger Text"</code>.</p>
<p><em>Prozentzeichen</em> innerhalb eines Ausdrucks werden genutzt, um <a href="#dynamic-variables">dynamische Variablenreferenzen</a> zu erzeugen, allerdings werden sie selten benötigt.</p>

<h3 id="constants">Konstanten</h3>
<p>Eine Konstante ist nichts anderes als ein unveränderlicher Wert, dem ein symbolischer Name gegeben ist. AutoHotkey hat momentan die folgenden Konstanten:</p>
<table class="info">
  <tr><th>Name</th><th>Wert</th><th>Type</th><th abbr="Beschr">Beschreibung</th></tr>
  <tr><td><code>False</code></td><td><code>0</code></td><td><a href="Concepts.htm#numbers">Integer</a></td><td><a href="Variables.htm#Boolean">Boolescher Wert</a> für Falsch/Unwahr, bedeutet manchmal "aus", "nein" usw.</td></tr>
  <tr><td><code>True</code></td><td><code>1</code></td><td><a href="Concepts.htm#numbers">Integer</a></td><td><a href="Variables.htm#Boolean">Boolescher Wert</a> für Wahr, bedeutet manchmal "an", "ja" usw.</td></tr>
</table>
<p>Im Gegensatz zu den schreibgeschützten <a href="Variables.htm#BuiltIn">internen Variablen</a>, können diese nicht über eine <a href="#dynamic-variables">dynamische Referenz</a> zurückgegeben werden.</p>

<h3 id="operators">Operatoren</h3>
<p><em>Operatoren</em> haben die Form eines Symbols oder einer Gruppe von Symbolen, wie z. B. <code>+</code> oder <code>:=</code>, oder eines der Wörter <code>and</code>, <code>or</code>, <code>not</code>, <code>is</code>, <code>in</code> oder <code>contains</code>. Sie nehmen einen, zwei oder drei Eingabewerte und geben einen Ausgabewert zurück. Ein Wert oder Teilausdruck, der als Eingabe für einen Operator dient, wird als <em>Operand</em> bezeichnet.</p>
<ul>
  <li><em>Unäre</em> (einstellige) Operatoren werden je nach Operator entweder vor oder nach einem einzelnen Operanden geschrieben. Zum Beispiel: <code>-x</code> oder <code>not TasteIstUnten</code>.</li>
  <li><em>Binäre</em> (zweistellige) Operatoren werden zwischen ihre beiden Operanden geschrieben. Zum Beispiel: <code>1+1</code> oder <code>2 * 5</code>.</li>
  <li>AutoHotkey hat nur einen <em>ternären</em> (dreistelligen) Operator, der die Form <a href="Variables.htm#ternary"><code>Bedingung ? WertWennTrue : WertWennFalse</code></a> hat.</li>
</ul>
<p>Einige unäre und binäre Operatoren teilen sich die gleichen Symbole - in diesem Fall hängt die Bedeutung des Operators davon ab, ob er vor, nach oder zwischen zwei Werten geschrieben wird. Zum Beispiel führt <code>x-y</code> eine Subtraktion durch, während <code>-x</code> das Vorzeichen von <code>x</code> invertiert (einen positiven Wert von einem negativen Wert erzeugen und umgekehrt).</p>
<p>Operatoren gleicher Priorität wie Multiplizieren (<code>*</code>) und Dividieren (<code>/</code>) werden von links nach rechts ausgewertet, sofern nicht anders in der <a href="Variables.htm#operators">Operatorentabelle</a> angegeben. Ein Operator mit niedrigerer Priorität wie Addieren (<code>+</code>) wird erst ausgewertet, wenn ein höherer Operator wie Multiplizieren (<code>*</code>) ausgewertet wurde. Zum Beispiel würde <code>3 + 2 * 2</code> als <code>3 + (2 * 2)</code> ausgewertet werden. Mit runden Klammern können die Prioritäten überschrieben werden. Zum Beispiel: <code>(3 + 2) * 2</code></p>

<h3 id="function-calls">Funktionsaufrufe</h3>
<p class="note">Eine allgemeine Erläuterung zu Funktionen und verwandter Fachbegriffe finden Sie unter <a href="Concepts.htm#functions">Funktionen</a>.</p>
<p><em>Funktionen</em> nehmen eine unterschiedliche Anzahl von Eingabewerten, führen eine Aktion oder Berechnung durch und geben dann ein Ergebnis via <a href="Concepts.htm#return-a-value"><em>Return</em></a> zurück. Die Eingabewerte einer Funktion werden als <a href="Concepts.htm#parameters"><em>Parameter</em></a> oder <em>Argumente</em> bezeichnet. Um eine Funktion <a href="Concepts.htm#call"><em>aufzurufen</em></a>, geben Sie einfach die Zielfunktion an, gefolgt von in Klammern gesetzten Parametern. <code>GetKeyState("Shift")</code> beispielsweise gibt 1 zurück (wird zu dieser Zahl ausgewertet), wenn <kbd>Umschalt</kbd> gedrückt gehalten wird, oder 0, wenn nicht.</p>
<p class="warning"><strong>Hinweis:</strong> Zwischen der Funktion und der runden Startklammer darf kein Leerzeichen stehen.
</p>
<p>Für Programmieranfänger mag die Forderung nach Klammern zunächst kryptisch oder umständlich erscheinen, aber gerade sie ermöglichen es, einen Funktionsaufruf mit anderen Operationen zu kombinieren. Zum Beispiel wird der Ausdruck <code>GetKeyState("Shift", "P") and GetKeyState("Ctrl", "P")</code> erst eine 1 zurückgeben, wenn beide Tasten physisch gedrückt gehalten werden.</p>
<p>Obwohl ein Funktionsaufrufausdruck normalerweise mit einem direkt geschriebenen Funktionsnamen beginnt, kann das Ziel des Aufrufs ein beliebiger Ausdruck sein, der ein <a href="objects/Functor.htm">Funktionsobjekt</a> erzeugt. Im Ausdruck <code>GetKeyState("Shift")</code> ist <em>GetKeyState</em> eigentlich eine Variablenreferenz, obwohl sie üblicherweise auf eine schreibgeschützte Variable verweist, die eine interne Funktion enthält.</p>

<h4 id="function-call-statements">Funktionsaufrufanweisungen</h4>
<p>Wenn der Rückgabewert der Funktion nicht benötigt wird und der Funktionsname am Zeilenanfang geschrieben wird (oder in anderen Kontexten, wo eine <a href="Concepts.htm#statement">Anweisung</a> erlaubt ist, wie z. B. nach einem <code>else</code> oder einem <a href="Hotkeys.htm">Hotkey</a>), können die Klammern weggelassen werden. In diesem Fall wird der Rest der Zeile als Parameterliste der Funktion übernommen. Zum Beispiel:</p>
<pre>Ergebnis := MsgBox("Hierfür sind Klammern erforderlich.",, "OKCancel")
MsgBox "Hierfür nicht. Das Ergebnis war " Ergebnis "."</pre>
<p>Die runden Klammern können auch beim Aufrufen einer <a href="Concepts.htm#methods">Methode</a> weggelassen werden, wenn das Zielobjekt entweder eine Variable oder eine direkt benannte Eigenschaft ist, wie z. B. <code>meineVar.meineMethode</code> oder <code>meineVar.meineEigenschaft.meineMethode</code>.</p>
<p>Bei Funktionsaufrufausdrücken muss das Ziel einer Funktionsaufrufanweisung keine vordefinierte Funktion sein; es kann stattdessen eine Variable sein, die ein <a href="objects/Functor.htm">Funktionsobjekt</a> enthält.</p>
<p>Eine Funktionsaufrufanweisung kann sich <a href="Scripts.htm#continuation">über mehrere Zeilen erstrecken</a>.</p>
<p>Funktionsaufrufanweisungen haben die folgenden Einschränkungen:</p>
<ul>
  <li>Wenn es einen Rückgabewert gibt, wird dieser immer verworfen.</li>
  <li>Sie können wie <a href="#control-flow">Kontrollanweisungen</a> nicht innerhalb eines Ausdrucks verwendet werden.</li>
  <li>Wenn optionale Parameter weggelassen werden, müssen auch alle Kommas am <em>Ende</em> der Parameterliste weggelassen werden, um eine <a href="Scripts.htm#continuation-line">Zeilenfortsetzung</a> zu verhindern.</li>
  <li>Funktionsaufrufanweisungen können nicht <a href="Functions.htm#VariadicCall">variadisch</a> sein, aber sie können eine feste Anzahl von Parametern an eine variadische Funktion übergeben.</li>
</ul>

<h4 id="optional-parameters">Optionale Parameter</h4>
<p>Optionale Parameter können einfach leer gelassen werden, allerdings ist das trennende Komma weiterhin notwendig, es sei denn, alle nachfolgenden Parameter werden ebenfalls weggelassen. Zum Beispiel kann die <a href="commands/Run.htm">Run</a>-Funktion ein bis vier Parameter akzeptieren. Alle folgenden Zeilen sind gültig:</p>
<pre>
Run "notepad.exe", "C:\"
Run "notepad.exe",, "Min"
Run("notepad.exe", , , &amp;notepadPID)
</pre>
<p id="unset">Innerhalb eines <a href="Language.htm#function-calls">Funktionsaufrufs</a>, einer <a href="Variables.htm#square-brackets">direkten Array-Schreibweise</a> oder einer <a href="Variables.htm#curly-braces">direkten Objekt-Schreibweise</a> kann das Schlüsselwort <code>unset</code> verwendet werden, um den Parameter oder Wert explizit wegzulassen. Ein ungesetzter Ausdruck hat eine der folgenden Auswirkungen:</p>
<ul>
  <li>Bei einer benutzerdefinierten Funktion wird der <a href="Functions.htm#optional">Standardwert</a> des Parameters verwendet.</li>
  <li>Bei einer internen Funktion wird davon ausgegangen, dass der Parameter weggelassen wurde.</li>
  <li>Bei einer <a href="Variables.htm#square-brackets">direkten Array-Schreibweise</a> wie <code>[var?]</code> wird das Element in die Länge des Arrays einbezogen, erhält aber keinen Wert.</li>
  <li>Bei einer <a href="Variables.htm#curly-braces">direkten Objekt-Schreibweise</a> wie <code>{x: y?}</code> wird die Eigenschaft nicht zugewiesen.</li>
</ul>
<p>Das Schlüsselwort <code>unset</code> kann auch <a href="Functions.htm#unset">in einer Funktionsdefinition verwendet werden</a>, um anzugeben, dass ein Parameter optional ist, aber keinen Standardwert hat. Wenn die Funktion ausgeführt wird, hat die lokale Variable, die diesem Parameter entspricht, <a href="Concepts.htm#nothing">keinen Wert</a>, wenn der Parameter weggelassen wurde.</p>
<p>Mit dem <a href="Variables.htm#maybe">Vielleicht-Operator (<em>Var</em><strong>?</strong>)</a> kann eine Variable übergeben oder weggelassen werden, je nachdem, ob sie einen Wert hat. Zum Beispiel ist <code>Array(MeineVar?)</code> äquivalent zu <code>Array(IsSet(MeineVar) ? MeineVar : unset)</code>.</p>

<h3 id="operators-for-objects">Operatoren für Objekte</h3>
<p>Es gibt noch andere Symbole, die in Ausdrücken verwendet werden, die nicht ganz in eine der oben genannten Kategorien passen oder die Bedeutung anderer Teile des Ausdrucks beeinflussen, wie unten beschrieben. Diese Symbole beziehen sich alle irgendwie auf <em>Objekte</em>. Eine vollständige Erläuterung dessen, was jedes Konstrukt tut, würde die Einführung weiterer Konzepte erfordern, die nicht in den Geltungsbereich dieses Abschnitts fallen.</p>
<p><code>Alpha.Beta</code> wird oft als <em>Objektelementzugriff</em> bezeichnet. <em>Alpha</em> ist eine gewöhnliche Variable und kann mit einem Funktionsaufruf oder einem anderen Teilausdruck, der ein Objekt zurückgibt, ersetzt werden. Beim Auswerten wird das Objekt mit der Anfrage konfrontiert, entweder den Wert oder die Eigenschaft <em>Beta</em> abzurufen, diesen Wert in die Eigenschaft <em>Beta</em> zu speichern oder die Methode namens <em>Beta</em> aufzurufen. Mit anderen Worten ist <em>Beta</em> ein Name, der für das Objekt von Bedeutung ist; es ist keine lokale oder globale Variable.</p>
<p><code>Alpha.Beta()</code> ist ein <em>Methodenaufruf</em>, wie oben beschrieben. Die runden Klammern können in bestimmten Fällen weggelassen werden; siehe <a href="#function-call-statements">Funktionsaufrufanweisungen</a>.</p>
<p><code>Alpha.Beta[Param]</code> ist eine spezielle Form des Objektelementzugriffs, die zusätzliche Parameter in die Anfrage einbezieht. Während <em>Beta</em> ein einfacher Name ist, ist <em>Param</em> eine gewöhnliche Variable oder ein Teilausdruck, oder eine Liste von Teilausdrücken, die durch Kommas getrennt sind (wie in der Parameterliste einer Funktion). <a href="Functions.htm#VariadicCall">Variadische Aufrufe</a> sind erlaubt.</p>
<p><code>Alpha.%vBeta%</code>, <code>Alpha.%vBeta%[Param]</code> und <code>Alpha.%vBeta%()</code> sind ebenfalls Objektelementzugriffe, aber <em>vBeta</em> ist eine Variable oder ein Teilausdruck. Dadurch kann der Name der Eigenschaft oder Methode ermittelt werden, während das Skript ausgeführt wird. Solche Methodenaufrufe benötigen runde Klammern.</p>
<p><code>Alpha[Index]</code> greift auf die <em>Standardeigenschaft</em> von <code>Alpha</code> zu und übergibt <code>Index</code> als Parameter. <em>Alpha</em> und <em>Index</em> sind in diesem Fall Variablen, die mit praktisch jedem Teilausdruck ersetzt werden könnten. Diese Syntax wird in der Regel genutzt, um ein Element eines <a href="objects/Array.htm">Arrays</a> oder eines <a href="objects/Map.htm">Map</a>-Objekts abzurufen.</p>
<p id="array-literal"><code>[A, B, C]</code> erzeugt ein <a href="objects/Array.htm">Array</a> mit den anfänglichen Inhalten von A, B und C (in diesem Fall alle Variablen), wobei A das Element 1 ist.</p>
<p id="object-literal"><code>{Eigenschaft1: Wert1, Eigenschaft2: Eigenschaft2}</code> erstellt ein <a href="objects/Object.htm">Objekt</a> mit den direkt geschriebenen Eigenschaften <em>Eigenschaft1</em> und <em>Eigenschaft2</em>. Ein Wert kann später mit dem oben beschriebenen <em>Objektelementzugriff</em> abgerufen werden. Um einen Eigenschaftsnamen als Ausdruck auszuwerten, umschließen Sie ihn mit Prozentzeichen. Zum Beispiel: <code>{%NameVar%: WertVar}</code>.</p>
<p><code>MeineFunk(Params*)</code> ist ein <a href="Functions.htm#VariadicCall">variadischer Funktionsaufruf</a>. Das Sternchen muss unmittelbar vor der runden Endklammer am Ende der Parameterliste der Funktion stehen. <em>Params</em> muss eine Variable oder ein Teilausdruck, der ein <a href="objects/Array.htm">Array</a> oder ein anderes enumerierbares Objekt zurückgibt, sein. Obwohl <code>Params*</code> nicht überall erlaubt ist, kann es in einem direkt geschriebenen Array (<code>[A, B, C, AnzufügendesArray*]</code>) oder in der Parameterliste einer Eigenschaft (<code>Alpha.Beta[Params*]</code> oder <code>Alpha[Params*]</code>) verwendet werden.</p>

<h3 id="expression-statements">Ausdrucksanweisungen</h3>
<p>Nicht alle Ausdrücke sollten allein auf einer Zeile stehen. Zum Beispiel würde eine Zeile, die nur aus <code>21*2</code> oder <code>"Etwas Text"</code> besteht, keinen Sinn ergeben. Die <em>Ausdrucksanweisung</em> ist ein eigenständiger Ausdruck, der in der Regel für seine Nebenwirkungen verwendet wird. Die meisten Ausdrücke mit Nebenwirkungen können auf diese Weise verwendet werden, daher ist es grundsätzlich nicht notwendig, sich die Details dieses Abschnitts zu merken.</p>
<p>Die folgenden Typen von Ausdrücken können als Anweisungen verwendet werden:</p>
<p>Zuweisungen, wie in <code>x := y</code>, Verbundzuweisungen wie <code>x += y</code>, und Inkrement-/Dekrementoperatoren wie <code>++x</code> und <code>x--</code>.</p>
<p class="warning"><strong>Bekannte Einschränkung:</strong> Bei <code>x++</code> und <code>x--</code> darf derzeit kein Leerzeichen zwischen Variablenname und Operator stehen.</p>
<p>Funktionsaufrufe wie <code>MeineFunk(Params)</code>. Nach einem alleinstehenden Funktionsaufruf kann jedoch keine geschweifte Startklammer <code>{</code> (am Zeilenende oder auf der nächsten Zeile) erfolgen, da dies als Funktionsdeklaration fehlinterpretiert werden würde.</p>
<p>Methodenaufrufe wie <code>MeinObj.MeineMethode()</code>.</p>
<p>Objektelementzugriff via eckige Klammern, wie z. B. <code>MeinObj[Index]</code>, das Nebenwirkungen wie ein Funktionsaufruf haben kann.</p>
<p>Ternäre Ausdrücke wie <code>x ? AufrufenWennTrue() : AufrufenWennFalse()</code>. Es ist jedoch sicherer, die unten beschriebene Regel anzuwenden; also den Ausdruck (oder nur die Bedingung) immer mit Klammern zu umschließen.</p>
<p class="warning"><strong>Bekannte Einschränkung:</strong> Aufgrund von Mehrdeutigkeiten bei <a href="#function-call-statements">Funktionsaufrufanweisungen</a> sollten Bedingungen, die mit einem Variablennamen und Leerzeichen beginnen (aber auch andere Operatoren enthalten), in runden Klammern gesetzt werden. <code>(x + 1) ? y : z</code> und <code>x+1 ? y : z </code> beispielsweise sind Ausdruckszuweisungen, während <code>x + 1 ? y : z</code> eine Funktionsaufrufanweisung ist.</p>
<p class="warning"><strong>Hinweis:</strong> Die Bedingung darf nicht mit <code>!</code> oder einem anderen Ausdrucksoperator beginnen, da sie sonst als <a href="Scripts.htm#continuation-line">Fortsetzungszeile</a> interpretiert werden würde.</p>
<p>Ausdrücke, die mit <code>(</code> beginnen. In der Regel muss jedoch auf der gleichen Zeile ein entsprechendes <code>)</code> stehen, sonst wird die Zeile als Anfang eines <a href="Scripts.htm#continuation">Fortsetzungsbereichs</a> interpretiert.</p>
<p>Ausdrücke, die mit einer Doppeldereferenzierung beginnen, wie z. B. <code>%VarName% := 1</code>. Dies ist in erster Linie auf die Komplexität der Implementierung zurückzuführen.</p>
<p>Ausdrücke, die mit den oben genannten Elementen beginnen (aber nicht mit den unten genannten), sind aus praktischen Gründen ebenfalls erlaubt. Zum Beispiel ist <code>MeineFunk()+1</code> momentan erlaubt, obwohl <code>+1</code> keine Wirkung hat und das Ergebnis verworfen wird. Solche Ausdrücke können in Zukunft durch eine erweiterte Fehlerprüfung ungültig werden.</p>
<p><a href="#function-call-statements">Funktionsaufrufanweisungen</a> sind ähnlich wie Ausdrucksanweisungen, aber technisch gesehen keine reinen Ausdrücke. Zum Beispiel: <code>MsgBox "Hallo, Welt!"</code>, <code>meineGui.Show</code> oder <code>x.y.z "meine Parameter"</code>.</p>

<h2 id="control-flow">Kontrollanweisungen</h2>
<p class="note">Eine allgemeine Erläuterung zum Kontrollfluss finden Sie unter <a href="Concepts.htm#control-flow">Kontrollfluss</a>.</p>
<p>Um <a href="Concepts.htm#statement">Anweisungen</a> zu einem <a href="commands/Block.htm"><em>Block</em></a> zusammenzufassen, umschließen Sie sie mit geschweiften Klammern <code>{}</code>, wie in C, JavaScript und anderen ähnlichen Sprachen, allerdings müssen die Klammern in der Regel am Anfang einer Zeile stehen. Kontrollanweisungen können auf einen ganzen Block oder nur auf eine einzelne Anweisung angewendet werden.</p>
<p>Der <a href="Concepts.htm#cf-body">Körper</a> einer Kontrollanweisung besteht immer aus einer einzigen <em>Gruppe</em> von Anweisungen. Ein Block zählt als eine Gruppe von Anweisungen, ebenso wie eine Kontrollanweisung und ihr Körper. Die folgenden verwandten Anweisungen werden ebenfalls mit ihren Körpern gruppiert: <code>If</code> mit <code>Else</code>; <code>Loop</code>/<code>For</code> mit <code>Until</code> oder <code>Else</code>; <code>Try</code> mit <code>Catch</code> und/oder <code>Else</code> und/oder <code>Finally</code>. Mit anderen Worten: Wenn eine Gruppe dieser Anweisungen als Ganzes verwendet wird, muss sie nicht immer mit geschweiften Klammern umschlossen werden (einige Programmierstile enthalten jedoch aus Gründen der Übersichtlichkeit immer die geschweiften Klammern).</p>
<p>Kontrollanweisungen, die einen Körper haben und deshalb immer eine nachfolgende Anweisung oder eine Gruppe von Anweisungen haben müssen: <code>If</code>, <code>Else</code>, <code>Loop</code>, <code>While</code>, <code>For</code>, <code>Try</code>, <code>Catch</code> und <code>Finally</code>.</p>
<p id="control-flow-list">Es gibt die folgenden Kontrollanweisungen:</p>
<ul>
  <li>Ein <a href="commands/Block.htm">Block</a> (gekennzeichnet durch ein Paar von geschweiften Klammern) gruppiert null oder mehr Anweisungen, um als eine einzige Anweisung zu fungieren.</li>
  <li>Eine <a href="commands/If.htm">If-Anweisung</a> führt ihren Körper aus, wenn eine Bedingung erfüllt ist. Sie kann mit einer nachfolgenden <a href="commands/Else.htm">Else</a>-Anweisung verbunden werden, die nur ausgeführt wird, wenn eine Bedingung nicht erfüllt ist.</li>
  <li><a href="commands/Goto.htm">Goto</a> springt zu einem bestimmten Label und setzt dort die Ausführung fort.</li>
  <li><a href="commands/Return.htm">Return</a> kehrt aus einer Funktion zurück.</li>
  <li>Eine <a href="#loop-statement">Loop-Anweisung</a> (<a href="commands/Loop.htm">Loop</a>, <a href="commands/While.htm">While</a> oder <a href="commands/For.htm">For</a>) führt ihren Körper wiederholt aus.
  <ul>
    <li><a href="commands/Break.htm">Break</a> verlässt (unterbricht) eine Schleife.</li>
    <li><a href="commands/Continue.htm">Continue</a> überspringt den Rest der aktuellen Schleife und beginnt einen neuen Durchlauf.</li>
    <li><a href="commands/Until.htm">Until</a> unterbricht eine Schleife, wenn ein Ausdruck als True gewertet wird. Der Ausdruck wird nach jedem Schleifendurchlauf ausgewertet.</li>
  </ul></li>
  <li><a href="commands/Switch.htm">Switch</a> führt eine Case-Anweisung aus einer Liste von Kandidaten aus, die sich gegenseitig ausschließen.</li>
  <li>Ausnahmebehandlung:
  <ul>
    <li><a href="commands/Try.htm">Try</a> schützt seinen Körper vor Laufzeitfehlern und Werten, die von der Throw-Anweisung ausgelöst werden.</li>
    <li><a href="commands/Catch.htm">Catch</a> wird ausgeführt, wenn innerhalb einer Try-Anweisung eine Ausnahme eines bestimmten Typs ausgelöst wird.</li>
    <li><a href="commands/Else.htm">Else</a>, das nach einer Catch-Anweisung verwendet wird, wird nur ausgeführt, wenn innerhalb einer Try-Anweisung keine Ausnahme ausgelöst wird.</li>
    <li><a href="commands/Finally.htm">Finally</a> führt seinen Körper aus, wenn die Kontrolle aus dem Körper einer Try- oder Catch-Anweisung heraustransferiert verlässt.</li>
    <li><a href="commands/Throw.htm">Throw</a> löst eine Ausnahme aus, um von Tray/Catch oder <a href="commands/OnError.htm">OnError</a> behandelt zu werden oder um ein Fehlerdialogfenster anzuzeigen.</li>
  </ul></li>
</ul>

<h3 id="control-flow-vs">Kontrollfluss vs. andere Anweisungen</h3>
<p>Kontrollanweisungen unterscheiden sich von <a href="#function-call-statements">Funktionsaufrufanweisungen</a> in mehrfacher Hinsicht:</p>
<ul>
  <li>Die geschweifte Startklammer eines <a href="commands/Block.htm">Blocks</a> kann auf derselben Zeile am Ende der Anweisung <a href="commands/If.htm">If</a>, <a href="commands/Else.htm">Else</a>, <a href="#loop-statement">Loop</a>, <a href="commands/While.htm">While</a>, <a href="commands/For.htm">For</a>, <a href="commands/Try.htm">Try</a>, <a href="commands/Catch.htm">Catch</a> oder <a href="commands/Finally.htm">Finally</a> geschrieben werden (im Prinzip jede Kontrollanweisung, die einen <a href="Concepts.htm#cf-body">Körper</a> hat). Dies wird als One True Brace (OTB) Style bezeichnet.</li>
  <li><a href="commands/Else.htm">Else</a>, <a href="commands/Try.htm">Try</a> und <a href="commands/Finally.htm">Finally</a> erlauben auf ihrer rechten Seite eine beliebige gültige Anweisung, da sie keine Parameter sondern einen <a href="Concepts.htm#cf-body">Körper</a> benötigen.</li>
  <li><a href="commands/If.htm">If</a>, <a href="commands/While.htm">While</a>, <a href="commands/Return.htm">Return</a>, <a href="commands/Until.htm">Until</a>, <a href="commands/Loop.htm">Loop <em>Anzahl</em></a> und <a href="commands/Goto.htm">Goto</a> erlauben die Verwendung einer runden Startklammer unmittelbar nach dem Namen, um die gesamte Parameterliste zu umschließen. Sie sehen zwar wie Funktionsaufrufe aus, sind es aber nicht und können auch nicht innerhalb eines Ausdrucks verwendet werden. Zum Beispiel: <code>if(Ausdruck)</code>.</li>
  <li>Kontrollanweisungen können nicht durch Definieren einer gleichnamigen Funktion überschrieben werden.</li>
</ul>

<h3 id="loop-statement">Loop-Anweisung</h3>
<p>Es gibt verschiedene Typen von Loop-Anweisungen:</p>
<ul>
  <li><a href="commands/Loop.htm">Loop <em>Anzahl</em></a> führt eine Anweisung wiederholt aus - entweder eine bestimmte Anzahl von Wiederholungen oder bis ein Break auftritt.</li>
  <li><a href="commands/LoopReg.htm">Loop Reg</a> ruft die Inhalte eines bestimmten Registry-Unterschlüssels einzeln ab.</li>
  <li><a href="commands/LoopFiles.htm">Loop Files</a> ruft bestimmte Dateien oder Ordner einzeln ab.</li>
  <li><a href="commands/LoopParse.htm">Loop Parse</a> ruft Teile (Felder) einer Zeichenkette einzeln ab.</li>
  <li><a href="commands/LoopRead.htm">Loop Read</a> ruft die Zeilen einer Textdatei einzeln ab.</li>
  <li><a href="commands/While.htm">While</a> führt eine Anweisung wiederholt aus, bis ein bestimmter Ausdruck als falsch gewertet wird. Der Ausdruck wird vor jedem Schleifendurchlauf ausgewertet.</li>
  <li><a href="commands/For.htm">For</a> führt eine Anweisung einmal für jeden Wert oder jedes Wertepaar aus, das von einem Enumerator zurückgegeben wird, wie z. B. für jedes Schlüssel-Wert-Paar in einem Objekt.</li>
</ul>
<p><a href="commands/Break.htm">Break</a> verlässt (unterbricht) eine Schleife und bewirkt dadurch, dass die Zeile nach dem Schleifenkörper angesprungen wird.</p>
<p><a href="commands/Continue.htm">Continue</a> überspringt den Rest der aktuellen Schleife und beginnt einen neuen Durchlauf.</p>
<p><a href="commands/Until.htm">Until</a> unterbricht eine Schleife, wenn ein Ausdruck als True gewertet wird. Der Ausdruck wird nach jedem Schleifendurchlauf ausgewertet.</p>
<p id="named-loops">Ein <a href="#labels">Label</a> kann genutzt werden, um eine Schleife für <a href="commands/Continue.htm">Continue</a> und <a href="commands/Break.htm">Break</a> zu "benennen". Dies ermöglicht dem Skript, von einer inneren Schleife heraus den aktuellen Durchlauf einer äußeren Schleife zu überspringen oder die äußere Schleife zu unterbrechen, ohne <a href="commands/Goto.htm">Goto</a> verwenden zu müssen.</p>
<p>Die interne Variable <strong>A_Index</strong> enthält die Nummer des aktuellen Schleifendurchlaufs. Sie enthält eine 1, wenn der Schleifenkörper das erste Mal durchgeführt wurde. Beim zweiten Mal enthält sie eine 2; und so weiter. Wenn eine innere Schleife von einer äußeren Schleife umschlossen ist, hat die innere Schleife Vorrang. A_Index funktioniert in jeder Schleifenvariante, aber außerhalb einer Schleife enthält sie eine 0.</p>
<p>Einige Schleifentypen haben noch andere interne Variablen, die Informationen über das aktuelle Schleifenelement liefern (Registry-Schlüssel/Wert, Datei, Teilzeichenkette oder Textzeile). Solche Variablen haben Namen, die mit <strong>A_Loop</strong> beginnen, wie z. B. A_LoopFileName und A_LoopReadLine. Ihre Werte gehören immer der zuletzt gestarteten (aber noch nicht gestoppten) Schleife des entsprechenden Typs. A_LoopField beispielsweise gibt die aktuelle Teilzeichenkette der innersten Parsing-Schleife zurück, auch wenn sie innerhalb einer Datei- oder Registry-Schleife verwendet wird.</p>
<pre>t := "Spalte 1`tSpalte 2`nWert 1`tWert 2"
Loop Parse t, "`n"
{
    ZeileText := A_LoopField
    ZeileNummer := A_Index  <em>; Für die Verwendung in der zweiten Schleife unten speichern.</em>
    Loop Parse ZeileText, "`t"
    {
        MsgBox ZeileNummer ":" A_Index " = " A_LoopField
    }
}
</pre>
<p>Schleifenvariablen können auch außerhalb des Schleifenkörpers verwendet werden, wie z. B. in einer Funktion, die aus einer Schleife heraus aufgerufen wird.</p>

<h3 id="not-control-flow">Kein Kontrollfluss</h3>
<p>Da Direktiven, Label, Zweifach-Doppelpunkt-Tags von Hotkeys und Hotstrings und Deklarationen ohne Zuweisungen bereits verarbeitet werden, während das Skript aus der Datei geladen wird, unterliegen sie nicht dem Kontrollfluss. Das heißt, dass sie bedingungslos wirksam werden, bevor das Skript überhaupt Kontrollanweisungen ausführt. Die <a href="commands/_HotIf.htm">#HotIf</a>-Direktive hat ebenfalls keinen Einfluss auf den Kontrollfluss; sie legt lediglich die Kriterien für die im Code angegebenen Hotkeys und Hotstrings fest. Die Kriterien eines Hotkeys werden jedes Mal ausgewertet, wenn er gedrückt wird, und nicht, wenn die Ausführung auf die #HotIf-Direktive trifft.</p>

<h2 id="structure-of-a-script">Aufbau eines Skripts</h2>

<h3 id="global-code">Globaler Code</h3>
<p>Nach dem Laden des Skripts wird der <em>Auto-Execute-Thread</em> die Ausführung bei der Zeile ganz oben im Skript beginnen und diese fortsetzen, bis ihm befohlen wird, zu stoppen, z. B. via <a href="commands/Return.htm">Return</a>, <a href="commands/ExitApp.htm">ExitApp</a> oder <a href="commands/Exit.htm">Exit</a>. Das physische Ende des Skripts fungiert auch als <a href="commands/Exit.htm">Exit</a>.</p>
<p>Globaler Code oder Code im globalen <a href="Concepts.htm#scope">Gültigkeitsbereich</a> ist ein ausführbarer Code, der sich nicht innerhalb einer Funktions- oder Klassendefinition befindet. Alle dort befindlichen Variablenreferenzen werden als <a href="Functions.htm#Global">global</a> bezeichnet, da sie von jeder Funktion (mit der entsprechenden Deklaration) angesprochen werden können. Ein solcher Code wird oft genutzt, um Einstellungen zu konfigurieren, die für jeden neu gestarteten <a href="misc/Threads.htm">Thread</a> gelten sollen, oder um globale Variablen zu <a href="Concepts.htm#uninitialized-variables">initialisieren</a>, die von Hotkeys und anderen Funktionen verwendet werden.</p>
<p>Code, der bei der Startphase des Skripts (also sofort beim Starten des Skripts) ausgeführt werden soll, wird oft am Anfang der Datei platziert. Derartiger Code kann jedoch in der gesamten Datei zwischen (aber nicht innerhalb von) Funktions- und Klassendefinitionen platziert werden. Dies liegt daran, dass die Ausführung den Körper jeder Funktions- oder Klassendefinition überspringt. In einigen Fällen kann das Skript komplett aus globalem Code bestehen.</p>
<p><strong>Siehe auch:</strong> <a href="Scripts.htm#auto">Startphase des Skripts (der Auto-Execute-Thread)</a></p>

<h3 id="subroutines">Subroutinen</h3>
<p>Eine <em>Subroutine</em> (auch <em>Sub</em> oder <em>Prozedur</em> genannt) ist ein wiederverwendbarer Codeblock, der bei Bedarf ausgeführt werden kann. Um eine Subroutine zu erstellen, definieren Sie eine <em>Funktion</em> (siehe unten). Diese Begriffe haben in AutoHotkey v2, wo Funktionen die einzigen möglichen Subroutinen sind, grundsätzlich die gleiche Bedeutung.</p>

<h3 id="functions">Funktionen</h3>
<p><strong>Siehe auch:</strong> <a href="Functions.htm">Funktionen</a> (alles über das Definieren von Funktionen)</p>
<p>Neben den vielen nützlichen <a href="commands/index.htm">vordefinierten Funktionen</a> kann ein Skript auch seine eigenen Funktionen definieren. Diese Funktionen können grundsätzlich auf zwei verschiedene Weisen genutzt werden:</p>
<ol>
  <li>Eine Funktion kann vom Skript selbst aufgerufen werden. Diese Art von Funktion kann genutzt werden, um Wiederholungen zu vermeiden, um den Code leichter verwalten zu können, oder auch für andere Zwecke.</li>
  <li>Eine Funktion kann vom Programm als Reaktion auf ein Ereignis aufgerufen werden, z. B. wenn der Benutzer einen Hotkey drückt. Zum Beispiel ist jedem Hotkey eine Funktion zugeordnet, die beim Drücken des Hotkeys ausgeführt wird.</li>
</ol>
<p>Es gibt mehrere Möglichkeiten, eine Funktion zu definieren:</p>
<ul>
  <li>Eine <a href="Functions.htm">Funktionsdefinition</a>, bestehend aus einem Namen, Klammern und einem <a href="commands/Block.htm">Codeblock</a>. Dies definiert eine Funktion, die über ihren Namen via <a href="#function-calls">Funktionsaufruf</a> oder <a href="#function-call-statements">Funktionsaufrufanweisung</a> ausgeführt werden kann. Zum Beispiel:
<pre>SageHallo()  <em>; SageHallo-Funktion definieren.</em>
{
    MsgBox "Hallo!"
}

SageHallo  <em>; SageHallo-Funktion aufrufen.</em></pre>
  </li>
  <li>Eine <a href="Hotkeys.htm">Hotkey</a>- oder <a href="Hotstrings.htm">Hotstring</a>-Definition, bestehend aus einem Hotkey oder Hotstring und einer einzelnen <a href="Concepts.htm#statement">Anweisung</a> oder einem <a href="commands/Block.htm">Codeblock</a>. Diese Art von Funktion kann nicht direkt aufgerufen werden, sondern wird immer dann ausgeführt, wenn der Hotkey oder Hotstring aktiviert wird. Zum Beispiel:
<pre>#w::Run "wordpad"  <em>; WIN+W drücken, um Wordpad zu starten.</em>
#n::  <em>; WIN+N drücken, um Notepad zu starten.</em>
{
    Run "notepad"
}</pre>
  </li>
  <li>Ein <a href="Variables.htm#fat-arrow">Fat-Arrow-Ausdruck</a> definiert eine Funktion, die einen <a href="#expressions">Ausdruck</a> auswertet und dessen Ergebnis <a href="Concepts.htm#return-a-value">zurückgibt</a>, anstatt einen Codeblock auszuführen. Solche Funktionen haben normalerweise keinen Namen, da sie direkt an eine andere Funktion übergeben werden. Zum Beispiel:
    <pre>SetTimer () =&gt; MsgBox("Hallo!"), -1000  <em>; Sagt Hallo nach 1 Sekunde.</em></pre>
  </li>
  <li>Die Fat-Arrow-Syntax kann auch außerhalb von Ausdrücken als Kurzschreibweise für eine normale Funktions- oder Methodendefinition verwendet werden. Zum Beispiel ist die folgende Definition äquivalent zu der obigen SageHallo-Definition, außer dass diese "OK" zurückgibt:
    <pre>SageHallo() =&gt; MsgBox("Hallo!")</pre>
  </li>
</ul>
<p>Variablen in Funktionen sind standardmäßig <a href="Functions.htm#Local">lokal</a> für diese Funktion, außer in den folgenden Fällen:</p>
<ul>
  <li>Wenn die Funktion eine <a href="Functions.htm#AssumeGlobal">Assume-Global</a>-Funktion ist.</li>
  <li>Wenn eine Variable referenziert, aber nicht als Ziel einer <a href="Variables.htm#AssignOp">Zuweisung</a> oder des Referenzoperators (<code>&amp;var</code>) verwendet wird.</li>
  <li>Wenn auf eine lokale Variable einer äußeren Funktion innerhalb einer <a href="Functions.htm#nested">verschachtelten Funktion</a> verwiesen wird.</li>
</ul>
<p>Eine Funktion kann optional <a href="Concepts.htm#parameters">Parameter akzeptieren</a>. Parameter werden definiert, indem man sie innerhalb von runden Klammern auflistet. Zum Beispiel:</p>
<pre>MeineFunktion(ErsterParameter, Zweiter, &amp;Dritter, Vierter:="")
{
    <em>;...</em>
    return "ein Wert"
}
</pre>
<p>Wie bei Funktionsaufrufen auch, darf zwischen dem Funktionsnamen und der runden Startklammer kein Leerzeichen stehen.</p>
<p>Der Zeilenumbruch zwischen der runden Endklammer und der geschweiften Startklammer ist optional. Es kann eine beliebige Anzahl von Leerraumzeichen oder Kommentaren zwischen den beiden sein.</p>
<p>Der <a href="Functions.htm#ByRef">ByRef-Marker (&amp;)</a> kennzeichnet, dass der Aufrufer eine Variablenreferenz übergeben muss. Innerhalb der Funktion wird jegliche Referenz, die auf den Parameter verweist, tatsächlich auf die Variable des Aufrufers zugreifen. Dies ähnelt dem Weglassen von <code>&amp;</code> und der expliziten <a href="Variables.htm#deref">Dereferenzierung</a> des Parameters innerhalb der Funktion (z. B. <code>%Dritter%</code>), allerdings werden in diesem Fall die Prozentzeichen weggelassen. Wenn der Parameter optional ist und der Aufrufer ihn weglässt, verhält sich der Parameter wie eine normale lokale Variable.</p>
<p>Um einen <a href="Functions.htm#optional">optionalen</a> Parameter anzugeben, müssen Sie nach dem Parameternamen <code>:=</code> anfügen, gefolgt von einer direkt geschriebenen, in Anführungszeichen gesetzte Zeichenkette, einer Zahl, <code>true</code>, <code>false</code> oder <code>unset</code>.</p>
<p>Die Funktion kann <a href="Functions.htm#return">einen Wert via Return zurückgeben</a>. Wenn sie das nicht tut, gibt sie standardmäßig eine leere Zeichenkette zurück.</p>
<p>Eine Funktionsdefinition muss nicht vor dem Aufruf dieser Funktion stehen.</p>
<p class="note">Einzelheiten finden Sie unter <a href="Functions.htm">Funktionen</a>.</p>

<h3 id="-include">#Include</h3>
<p>Die <a href="commands/_Include.htm">#Include</a>-Direktive veranlasst das Skript, sich so zu verhalten, als wäre der Inhalt einer bestimmten Datei an genau dieser Stelle vorhanden. Dies wird oft verwendet, um Code in separaten Dateien aufzuteilen oder um Skriptbibliotheken anderer Benutzer zu nutzen.</p>
<p>Eine #Include-Datei kann <a href="#global-code">globalen Code</a> enthalten, der während der <a href="Scripts.htm#auto">Startphase des Skripts</a> ausgeführt werden soll, allerdings wird, analog zum Code in der Hauptskriptdatei, solcher Code nur ausgeführt, wenn der Auto-Execute-Thread nicht bereits vor der #Include-Direktive terminiert wird (z. B. mit einem bedingungslosen <code>Return</code>). Es wird standardmäßig eine <a href="commands/_Warn.htm#Unreachable">Warnung</a> angezeigt, wenn ein Code aufgrund eines vorhergehenden <code>Return</code> nicht ausgeführt werden kann.</p>
<p>Im Gegensatz zu C/C++ macht #Include nichts, wenn die Datei bereits von einer früheren Direktive eingebunden wurde. Um den Inhalt einer Datei mehrfach einzubinden, verwenden Sie <a href="commands/_Include.htm">#IncludeAgain</a>.</p>
<p>Um die gemeinsame Nutzung von Skripten zu erleichtern, sucht #Include an vordefinierten Standorten nach einem Bibliotheksskript. Weitere Informationen finden Sie unter <a href="Scripts.htm#lib">Skriptbibliotheksordner</a>.</p>

<h2 id="misc">Verschiedenes</h2>

<h3 id="dynamic-variables">Dynamische Variablen</h3>
<p>Eine <em>dynamische Variablenreferenz</em> nimmt einen Textwert und interpretiert ihn als Namen einer Variable.</p>
<p class="note"><strong>Hinweis:</strong> Eine Variable kann nicht durch eine dynamische Referenz <em>erstellt</em> werden, aber existierende Variablen können zugewiesen werden. Dazu gehören alle Variablen, zu denen das Skript nicht-dynamische Referenzen enthält, auch wenn ihnen keine Werte zugewiesen wurden.</p>
<p>Die bekannteste Form einer dynamischen Variablenreferenz nennt sich <em>Doppelreferenzierung</em> oder <em>double-deref</em>. Bevor man eine Doppelreferenzierung durchführen kann, muss der Name der Zielvariable in einer zweiten Variable gespeichert sein. Diese zweite Variable kann genutzt werden, um der Zielvariable indirekt einen Wert via Doppelreferenzierung zuzuweisen. Zum Beispiel:</p>
<pre>Ziel := 42
ZweiteVar := "Ziel"
MsgBox  ZweiteVar   <em>; Normale (einfache) Variablenreferenz =&gt; Ziel</em>
MsgBox %ZweiteVar%  <em>; Doppelreferenzierung =&gt; 42</em>
</pre>
<p>Momentan muss <code>ZweiteVar</code> im zweiten Fall immer einen Variablennamen enthalten; beliebige Ausdrücke werden nicht unterstützt.</p>
<p>Eine dynamische Variablenreferenz kann auch einen oder mehrere direkt geschriebene Texte und den Inhalt einer oder mehrerer Variablen zu einem einzigen Variablennamen zusammenfügen. Dazu schreibt man einfach die Bestandteile des Namens und die mit Prozentzeichen umschlossenen Variablen der Reihe nach ohne Leerzeichen auf. Zum Beispiel: <code>MeinArray%A_Index%</code> oder <code>MeinRaster%X%_%Y%</code>. Mit dieser Methode kann man auf <em>Pseudo-Arrays</em> zugreifen, wie unten beschrieben.</p>
<p>Diese Techniken können auch auf Eigenschaften und Methoden von Objekten angewendet werden. Zum Beispiel:</p>
<pre>Farbe := {}
for n, Komponente in ["Rot", "Grün", "Blau"]
    Farbe.%Komponente% := Random(0, 255)
MsgBox Farbe.Rot "," Farbe.Grün "," Farbe.Blau</pre>

<h4 id="pseudo-arrays">Pseudo-Arrays</h4>
<p>Ein <em>Pseudo-Array</em> ist eigentlich nur ein Haufen einzelner Variablen, deren Namensmuster es aber möglich machen, sie wie Elemente eines Arrays zu verwenden. Zum Beispiel:</p>
<pre>
MeinArray1 := "A"
MeinArray2 := "B"
MeinArray3 := "C"
Loop 3
    MsgBox MeinArray%A_Index%  <em>; Zeigt A, dann B, dann C.</em>
</pre>
<p>Der "Index", mit dem der endgültige Variablenname gebildet wurde, muss nicht numerisch sein; er kann auch ein Buchstabe oder Schlüsselwort sein.</p>
<p>Aus diesen Gründen ist es in der Regel ratsam, ein <a href="Objects.htm#Usage_Simple_Arrays">Array</a> oder <a href="Objects.htm#Usage_Associative_Arrays">Map</a> anstelle eines Pseudo-Arrays zu verwenden:</p>
<ul>
  <li>Da es sich bei den einzelnen Elementen um normale Variablen handelt, kann man zwar einen Wert zuweisen oder abrufen, aber keine Elemente <em>entfernen</em> oder <em>einfügen</em>.</li>
  <li>Da das Pseudo-Array nur ein Konzept und kein Einzelwert ist, kann es nicht an eine Funktion übergeben oder von einer Funktion zurückgegeben werden, oder als Ganzes kopiert werden.</li>
  <li>Ein Pseudo-Array kann nicht als Ganzes deklariert werden, daher werden einige "Elemente" möglicherweise zu <a href="Functions.htm#Global">globalen</a> (oder <a href="Functions.htm#capture-var">erfassten</a>) Variablen aufgelöst, andere hingegen nicht.</li>
  <li>Wenn eine Variable nicht-dynamisch referenziert, aber nur dynamisch zugewiesen wird, wird möglicherweise eine <a href="commands/_Warn.htm#VarUnset">Ladezeitwarnung</a> angezeigt. Solche Warnungen sind ein sehr effektives Mittel, um Fehler aufzudecken, daher ist es nicht ratsam, sie zu deaktivieren.</li>
  <li>Aktuelle Versionen der Sprache bieten keine Möglichkeit, neue Variablen dynamisch zu erstellen. Dies dient zum einen dazu, bewährte Verfahren zu fördern, und zum anderen, um Inkonsistenzen zwischen dynamischen und nicht-dynamischen Variablenreferenzen in Funktionen zu vermeiden.</li>
</ul>

<h3 id="labels">Label</h3>
<p>Ein Label identifiziert eine Codezeile. Es kann verwendet werden, um als Ziel für <a href="commands/Goto.htm">Goto</a> zu dienen oder <a href="#named-loops">eine Schleife zu spezifizieren</a>, um aus dieser auszubrechen oder bei ihr fortzufahren. Ein Label besteht aus einem <a href="Concepts.htm#names">Namen</a>, gefolgt von einem Doppelpunkt:</p>
<pre>das_ist_ein_Label:
</pre>
<p>Abgesehen von Leerraumzeichen und Kommentaren darf kein anderer Code auf der Zeile eines Labels stehen. Weitere Informationen finden Sie unter <a href="misc/Labels.htm">Label</a>.</p>
</body>
</html>
