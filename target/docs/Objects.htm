<!DOCTYPE HTML>
<html lang="de">
<head>
<title>Objekte - Definition &amp; Verwendung | AutoHotkey v2</title>
<meta name="description" content="Wie man Objekte verwendet, neue Objekttypen definiert und weitere Einzelheiten darüber, wie Objekte in AutoHotkey funktionieren." />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
<script src="static/ga4.js" type="text/javascript"></script>
<style>
ul.list_of_p p { margin: 0.5em 0; }
ul.list_of_p li { margin: 1em 0; }
</style>
</head>
<body>

<h1>Objekte</h1>

<p>Ein <i>Objekt</i> ist eine Kombination aus <em>Eigenschaften</em> und <a href="Concepts.htm#methods"><em>Methoden</em></a>.</p>
<p>Verwandte Themen:</p>
<ul>
  <li><a href="Concepts.htm#objects">Objekte</a>: Allgemeine Erklärung zu Objekten.</li>
  <li><a href="Concepts.htm#object-protocol">Objektorientierte Schnittstelle</a>: Einzelheiten darüber, wie ein Skript mit einem Objekt interagiert.</li>
  <li><a href="misc/Functor.htm">Funktionsobjekte</a>: Objekte, die <em>aufgerufen</em> werden können.</li>
</ul>

<p>Mit <b>IsObject</b> kann festgestellt werden, ob ein Wert ein Objekt ist:</p>
<pre>Ergebnis := IsObject(<i>Ausdruck</i>)</pre>

<p>Eine Auflistung der verfügbaren Objekttypen finden Sie unter <a href="ObjList.htm">Interne Klassen</a>. Es gibt zwei grundlegende Typen:</p>
<ul>
  <li><strong>AutoHotkey-Objekte</strong> sind Instanzen der <a href="lib/Object.htm">Object</a>-Klasse. Diese unterstützen Ad-hoc-Eigenschaften, und verfügen über Methoden, um herauszufinden, welche Eigenschaften existieren. <a href="lib/Array.htm">Array</a>, <a href="lib/Map.htm">Map</a> und alle benutzerdefinierten und internen Klassen stammen von der Object-Klasse ab.</li>
  <li><strong>COM-Objekte</strong>, wie solche, die via <a href="lib/ComObject.htm">ComObject</a> erstellt werden. Diese sind in externen Bibliotheken implementiert und unterscheiden sich daher von AutoHotkey-Objekten in Bezug auf das Verhalten. ComObject repräsentiert typischerweise ein COM- oder "Automation"-Objekt mit einer implementierten <a href="https://docs.microsoft.com/windows/desktop/api/oaidl/nn-oaidl-idispatch">IDispatch-Schnittstelle</a>. Es wird auch genutzt, um <a href="lib/ComValue.htm">Werte von spezifischen Typen zu wrappen</a>, damit diese an COM-Objekten und Funktionen übergeben werden können.</li>
</ul>

<h2 id="toc">Inhaltsverzeichnis</h2>
<ul>
  <li><a href="#Usage">Grundlegende Verwendung</a> - <a href="#Usage_Simple_Arrays">Arrays</a>, <a href="#Usage_Associative_Arrays">Maps (assoziative Arrays)</a>, <a href="#Usage_Objects">Objekte</a>, <a href="#Usage_Freeing_Objects">Freigeben von Objekten</a></li>
  <li><a href="#Extended_Usage">Erweiterte Verwendung</a> - <a href="#Usage_Arrays_of_Arrays">Mehrdimensionale Arrays</a></li>
  <li><a href="#Custom_Objects">Benutzerdefinierte Objekte</a> - <a href="#creating-a-base-object">Basisobjekt erstellen</a>, <a href="#Custom_Classes">Klassen</a>, <a href="#Custom_NewDelete">Konstruktion und Destruktion</a>, <a href="#Meta_Functions">Metafunktionen</a></li>
  <li><a href="#primitive">Primitive Werte</a></li>
  <li><a href="#Implementation">Implementierung</a> - <a href="#Reference_Counting">Referenzzählung</a>, <a href="#ObjPtr">Objekt-Pointer</a></li>
</ul>

<span id="Syntax"></span><h2 id="Usage">Grundlegende Verwendung</h2>

<h3 id="Usage_Simple_Arrays">Arrays</h3>
<p>Erstellen eines <a href="lib/Array.htm">Arrays</a>:</p>
<pre>MeinArray := [Element1, Element2, ..., ElementN]
MeinArray := Array(Element1, Element2, ..., ElementN)</pre>
<p>Abrufen eines Elements (oder <em>Array-Elements</em>):</p>
<pre>Wert := MeinArray[Index]</pre>
<p>Ändern eines Elementwertes (<code>Index</code> muss zwischen 1 und Länge liegen, oder ein äquivalenter umgekehrter Index):</p>
<pre>MeinArray[Index] := Wert</pre>
<p>Einfügen eines oder mehrerer Elemente ab einem bestimmten Index mittels <a href="lib/Array.htm#InsertAt">InsertAt</a>-Methode:</p>
<pre>MeinArray.InsertAt(Index, Wert, Wert2, ...)</pre>
<p>Anfügen eines oder mehrerer Elemente mittels <a href="lib/Array.htm#Push">Push</a>-Methode:</p>
<pre>MeinArray.Push(Wert, Wert2, ...)</pre>
<p>Entfernen eines Elements mittels <a href="lib/Array.htm#RemoveAt">RemoveAt</a>-Methode:</p>
<pre>EntfernterWert := MeinArray.RemoveAt(Index)</pre>
<p>Entfernen eines Elements mittels <a href="lib/Array.htm#Pop">Pop</a>-Methode:</p>
<pre>EntfernterWert := MeinArray.Pop()</pre>
<p><a href="lib/Array.htm#Length">Length</a> gibt die Anzahl aller Elemente im Array zurück. Um die Inhalte des Arrays zu durchlaufen, erfolgt dies entweder via Index oder mit einer For-Schleife. Zum Beispiel:</p>
<pre>MeinArray := ["eins", "zwei", "drei"]

<em>; Durchläuft das Array von 1 bis zu seinem Ende:</em>
Loop MeinArray.Length
    MsgBox MeinArray[A_Index]

<em>; Enumeriert die Inhalte des Arrays:</em>
For Index, Wert in MeinArray
    MsgBox "Element " Index " ist '" Wert "'"
    
<em>; Das Gleiche nochmal:</em>
For Wert in MeinArray
    MsgBox "Element " A_Index " ist '" Wert "'"
</pre>

<h3 id="Usage_Associative_Arrays">Map-Objekte (Assoziative Arrays)</h3>
<p>Ein <a href="lib/Map.htm">Map</a>-Objekt bzw. assoziatives Array ist ein Objekt, das eine Sammlung von eindeutigen Schlüsseln und eine Sammlung von Werten enthält, die jeweils miteinander verbunden sind. Schlüssel können Zeichenketten, Integer oder Objekte sein, während Werte von beliebigem Typ sein können. Ein assoziatives Array kann wie folgt erstellt werden:</p>
<pre>MeinMap := Map("SchlüsselA", WertA, "SchlüsselB", WertB, ..., "SchlüsselZ", WertZ)</pre>
<p>Abrufen eines Elements, wo <code>Schlüssel</code> eine <a href="Concepts.htm#variables">Variable</a> oder ein <a href="Language.htm#expressions">Ausdruck</a> ist:</p>
<pre>Wert := MeinMap[Schlüssel]</pre>
<p>Zuweisen eines Elements:</p>
<pre>MeinMap[Schlüssel] := Wert</pre>
<p>Entfernen eines Elements mittels <a href="lib/Array.htm#Delete">Delete</a>-Methode:</p>
<pre>EntfernterWert := MeinMap.Delete(Schlüssel)</pre>
<p>Enumerieren von Elementen:</p>
<pre>MeinMap := Map("zehn", 10, "zwanzig", 20, "dreißig", 30)
<a href="lib/For.htm">For</a> Schlüssel, Wert in MeinMap
    MsgBox Schlüssel ' = ' Wert</pre>

<h3 id="Usage_Objects">Objekte</h3>
<p>Ein Objekt kann <em>Eigenschaften</em> und <em>Elemente</em> haben (z. B. Array-Elemente). Der Zugriff auf Elemente erfolgt über <code>[]</code>, wie in den vorherigen Abschnitten gezeigt. Der Zugriff auf Eigenschaften erfolgt durch Anfügen eines Punktes und einem Identifikator (einfach ein <a href="Concepts.htm#names">Name</a>). <em>Methoden</em> sind Eigenschaften, die aufgerufen werden können.</p>
<p><strong>Beispiele:</strong></p>
<p>Abrufen oder Setzen einer Eigenschaft mit dem direkt geschriebenen Namen <em>Eigenschaft</em>:</p>
<pre>Wert := MeinObjekt.Eigenschaft</pre>
<pre>MeinObjekt.Eigenschaft := Wert</pre>
<p>Abrufen oder Setzen einer Eigenschaft mit einem Namen, der via <a href="Language.htm#expressions">Ausdruck</a> oder <a href="Concepts.htm#variables">Variable</a> ermittelt wird:</p>
<pre>Wert := MeinObjekt.%Ausdruck%</pre>
<pre>MeinObjekt.%Ausdruck% := Wert</pre>
<p>Aufrufen einer Eigenschaft/Methode mit dem direkt geschriebenen Namen <em>Methode</em>:</p>
<pre>RückgabeWert := MeinObjekt.Methode(Params)</pre>
<p>Aufrufen einer Eigenschaft/Methode mit einem Namen, der via Ausdruck oder Variable ermittelt wird:</p>
<pre>RückgabeWert := MeinObjekt.%Ausdruck%(Params)</pre>
<p>Manchmal werden beim Abrufen oder Zuweisen von Eigenschaften Parameter akzeptiert:</p>
<pre>Wert := MeinObjekt.Eigenschaft[Params]
MeinObjekt.Eigenschaft[Params] := Wert</pre>
<p>Ein Objekt kann auch die Indexierung unterstützen: <code>MeinArray[Index]</code> ruft eigentlich die <a href="#__Item">__Item</a>-Eigenschaft von <code>MeinArray</code> auf und übergibt <code>Index</code> als Parameter.</p>

<h3 id="object-literal">Direkte Objekt-Schreibweise</h3>
<p>Die direkte Objekt-Schreibweise kann innerhalb eines <a href="Language.htm#expressions">Ausdrucks</a> verwendet werden, um ein improvisiertes Objekt zu erstellen. Die direkte Objekt-Schreibweise besteht aus zwei geschweiften Klammern (<code>{}</code>), die eine Liste von kommagetrennten Name-Wert-Paaren umschließen. Jedes Paar besteht aus einem direkt geschriebenen (in Anführungszeichen gesetzten) <a href="Concepts.htm#names">Eigenschaftsnamen</a> und einem Wert (Teilausdruck), die mit einem Doppelpunkt (<code>:</code>) voneinander getrennt sind. Zum Beispiel:</p>
<pre>Koord := {X: 13, Y: 240}</pre>
<p>Folgendes ist äquivalent:</p>
<pre>Koord := Object()
Koord.X := 13
Koord.Y := 240</pre>
<p>Jedes Name-Wert-Paar bewirkt, dass eine Werteigenschaft definiert wird, mit der Ausnahme, dass <a href="lib/Object.htm#Base">Base</a> gesetzt werden kann (mit den gleichen Einschränkungen wie bei einer normalen Zuweisung).</p>
<p><a href="Variables.htm#deref">Namenssubstitution</a> ermöglicht die Bestimmung eines Eigenschaftsnamens durch Auswertung eines <a href="Language.htm#expressions">Ausdrucks</a> oder einer <a href="Concepts.htm#variables">Variable</a>. Zum Beispiel:</p>
<pre>Teile := StrSplit("Schlüssel = Wert", "=", " ")
Teil := {%Teile[1]%: Teile[2]}
MsgBox Teil.Schlüssel</pre>

<h3 id="Usage_Freeing_Objects">Freigeben von Objekten</h3>
<p>Skripte geben Objekte nicht explizit frei. Sobald die letzte Referenz zu einem Objekt freigegeben ist, wird das Objekt automatisch freigegeben. Eine Referenz, die in einer Variable gespeichert ist, wird automatisch freigegeben, wenn diese Variable irgendeinen anderen Wert zugewiesen bekommt. Zum Beispiel:</p>
<pre>obj := {}  <em>; Erstellt ein Objekt.</em>
obj := ""  <em>; Gibt die letzte Referenz frei, wodurch das Objekt freigegeben wird.</em></pre>
<p>Außerdem wird eine Referenz, die in einer Eigenschaft oder einem Array-Element gespeichert ist, freigegeben, wenn diese Eigenschaft oder dieses Array-Element irgendeinen anderen Wert zugewiesen bekommt oder aus dem Objekt entfernt wird.</p>
<pre>arr := [{}]  <em>; Erstellt ein Array, das ein Objekt enthält.</em>
arr[1] := {}  <em>; Erstellt ein zweites Objekt, wodurch das erste Objekt indirekt freigegeben wird.</em>
arr.RemoveAt(1)  <em>; Entfernt das zweite Objekt und gibt es frei.</em></pre>
<p id="Circular_References">Da alle Referenzen zu einem Objekt freigegeben werden müssen, bevor das Objekt freigegeben werden kann, können Objekte mit Zirkelbezügen nicht automatisch freigegeben werden. Wenn beispielsweise <code>x.child</code> auf <code>y</code> verweist und <code>y.parent</code> auf <code>x</code> verweist, würde es nicht genügen, <code>x</code> und <code>y</code> zu leeren, weil das Parent-Objekt noch eine Referenz zum Child-Objekt enthält, und umgekehrt. Um diese Situation in den Griff zu bekommen, entfernen Sie den Zirkelbezug.</p>
<pre>
x := {}, y := {}             <em>; Erstellt zwei Objekte.</em>
x.child := y, y.parent := x  <em>; Erstellt ein Zirkelbezug.</em>

y.parent := ""               <em>; Der Zirkelbezug muss entfernt werden, bevor die Objekte freigegeben werden können.</em>
x := "", y := ""             <em>; Wenn die Zeile darüber fehlen würde, könnten die Objekte auf diese Weise nicht freigegeben werden.</em>
</pre>
<p>Für mehr Details, siehe <a href="#Reference_Counting">Referenzzählung</a>.</p>

<h2 id="Extended_Usage">Erweiterte Verwendung</h2>

<h3 id="Usage_Arrays_of_Arrays">Mehrdimensionale Arrays</h3>
<p>Obwohl "mehrdimensionale" Arrays nicht unterstützt werden, kann ein Skript mehrere Arrays oder Maps kombinieren. Zum Beispiel:</p>
<pre>
Gitter := [[1,2,3],
         [4,5,6],
         [7,8,9]]
MsgBox Gitter[1][3] <em>; 3</em>
MsgBox Gitter[3][2] <em>; 8</em>
</pre>
<p id="Array2D">Ein benutzerdefiniertes Objekt kann mehrdimensionale Unterstützung implementieren, indem es eine <a href="#__Item">__Item</a>-Eigenschaft definiert. Zum Beispiel:</p>
<pre>
class Array2D extends Array {
    __new(x, y) {
        this.Länge := x * y
        this.Breite := x
        this.Höhe := y
    }
    __Item[x, y] {
        get =&gt; super[this.Breite * (y-1) + x]
        set =&gt; super[this.Breite * (y-1) + x] := value
    }
}

Gitter := Array2D(4, 3)
Gitter[4, 1] := "#"
Gitter[3, 2] := "#"
Gitter[2, 2] := "#"
Gitter[1, 3] := "#"
Gittertext := ""
Loop Gitter.Höhe {
    y := A_Index
    Loop Gitter.Breite {
        x := A_Index
        Gittertext .= Gitter[x, y] || "-"
    }
    Gittertext .= "`n"
}
MsgBox Gittertext
</pre>
<p>Ein echtes Skript sollte eine Fehlerprüfung durchführen und andere Methoden überschreiben, wie z. B. <a href="#__Enum">__Enum</a>, um die Enumeration zu unterstützen.</p>

<h2 id="Custom_Objects">Benutzerdefinierte Objekte</h2>
<p>Es gibt zwei verschiedene Möglichkeiten, benutzerdefinierte Objekte zu erstellen:</p>
<ul>
  <li><em>Ad hoc</em>: Ein Objekt erstellen und Eigenschaften hinzufügen.</li>
  <li><em>Delegation</em>: Eigenschaften in einem <em>Basisobjekt</em> oder einer Klasse definieren.</li>
</ul>
<p><a href="#Meta_Functions">Metafunktionen</a> können genutzt werden, um das Verhalten eines Objekts noch genauer zu steuern.</p>
<p class="note"><strong>Hinweis:</strong> In diesem Abschnitt ist ein <em>Objekt</em> eine beliebige Instanz der <a href="lib/Object.htm">Object</a>-Klasse. Dieser Abschnitt gilt nicht für COM-Objekte.</p>

<h3 id="ad-hoc">Ad Hoc</h3>
<p>Ein neues Objekt kann grundsätzlich zu jeder Zeit um Eigenschaften und Methoden (aufrufbaren Eigenschaften) erweitert werden. Das folgende Beispiel zeigt, wie ein Objekt mit einer Eigenschaft und einer Methode konstruiert werden kann:</p>
<pre><em>; Erstellt ein Objekt.</em>
obj := {}
<em>; Speichert einen Wert.</em>
obj.foo := "bar"
<em>; Definiert eine Methode.</em>
obj.test := obj_test
<em>; Ruft die Methode auf.</em>
obj.test()

obj_test(this) {
    MsgBox this.foo
}</pre>
<p>Das obige Objekt könnte auch mit <code>obj := {foo: "bar"}</code> erstellt werden. Bei der {Eigenschaft:Wert}-Schreibweise dürfen die Eigenschaften nicht in Anführungszeichen gesetzt werden.</p>
<p>Sobald <code>obj.test()</code> aufgerufen wird, wird <i>obj</i> automatisch an den Anfang der Parameterliste gesetzt. Standardmäßig wird der Name der Funktion aus folgenden Komponenten gebildet (aber nicht zwingend notwendig): der "Typ" des Objekts und der Name der Methode.</p>
<p>Im obigen Beispiel kann <em>test</em>, nachdem es definiert wurde, eine andere Funktion oder ein anderer Wert zugewiesen werden; die ursprüngliche Funktion geht in diesem Fall verloren und kann nicht über diese Eigenschaft aufgerufen werden. Alternativ können Sie wie folgt eine schreibgeschützte Methode definieren:</p>
<pre>obj.DefineProp 'test', {call: obj_test}</pre>
<p>Siehe auch: <a href="lib/Object.htm#DefineProp">DefineProp</a></p>

<h3 id="delegation">Delegation</h3>
<p>Objekte sind <em>prototypenbasiert</em>. Das heißt, dass alle Eigenschaften, die nicht im Objekt selbst definiert sind, stattdessen im <a href="lib/Object.htm#Base">Base</a> des Objekts definiert werden können. Man bezeichnet dies als <em>Vererbung durch Delegation</em> oder <em>Differenzielle Vererbung</em>, da ein Objekt nur die Teile implementieren kann, die sich vom Objekt unterscheiden, während es den Rest an dessen Basis delegiert.</p>
<p>Obwohl ein Basisobjekt gemeinhin auch als Prototyp bekannt ist, verwenden wir den Begriff "<a href="lib/Class.htm#Prototype">Prototyp</a> einer Klasse" für das Objekt, auf dem jede Instanz der Klasse basiert, und "Basis" für das Objekt, auf dem eine Instanz basiert.</p>
<p class="note">Das Objektdesign von AutoHotkey wurde hauptsächlich von JavaScript und Lua beeinflusst, und etwas C#. Wir verwenden <code><i>obj</i>.base</code> anstelle von JavaScripts <code><i>obj</i>.__proto__</code> und <code><i>cls</i>.Prototype</code> anstelle von JavaScripts <code><i>func</i>.prototype</code>. (Klassenobjekte werden anstelle von Konstruktorfunktionen verwendet.)</p>

<p>Die Basis eines Objekts wird auch verwendet, um dessen Typ oder Klasse zu identifizieren. Zum Beispiel erstellt <code>x := []</code> ein Objekt <em>basierend auf</em> <code>Array.Prototype</code>; das heißt, dass die Ausdrücke <code>x is Array</code> und <code>x.HasBase(Array.Prototype)</code> True sind und <code>type(x)</code> "Array" zurückgibt. Der Protoyp jeder Klasse basiert auf dem Prototyp ihrer Basisklasse, also ist <code>x.HasBase(Object.Prototype)</code> ebenfalls True.</p>
<p>Ein Basisobjekt kann eine beliebige Instanz der Object-Klasse oder eine abgeleitete Klasse sein, allerdings kann ein Objekt nur <a href="lib/Object.htm#Base">als Basis</a> eines Objekts mit dem gleichen nativen Typ zugewiesen werden. Auf diese Weise wird sichergestellt, dass interne Methoden immer den nativen Typ eines Objekts identifizieren und nur auf Objekte angewendet werden können, die die richtige binäre Struktur aufweisen.</p>
<p>Basisobjekte können auf zwei verschiedene Arten definiert werden:</p>
<ul>
  <li>Durch <a href="#creating-a-base-object">Erstellen eines normalen Objekts</a>.</li>
  <li>Durch <a href="#Custom_Classes">Definieren einer Klasse</a>. Jede Klasse hat eine <a href="lib/Class.htm#Prototype">Prototype</a>-Eigenschaft, die ein Objekt enthält, auf dem alle Instanzen dieser Klasse basieren, während die Klasse selbst zum Basisobjekt von allen direkten Unterklassen wird.</li>
</ul>
<p>Ein Basisobjekt kann der <a href="lib/Object.htm#Base">Base</a>-Eigenschaft eines anderen Objekts zugewiesen werden, allerdings wird die Basis eines Objekts normalerweise beim Erstellen implizit gesetzt.</p>

<h3 id="creating-a-base-object">Basisobjekt erstellen</h3>
<p>Es kann ein beliebiges Objekt als Basis eines anderen Objekts verwendet werden, das den gleichen nativen Typ hat. Das folgende Beispiel basiert auf dem vorherigen Beispiel unter <a href="#ad-hoc">Ad Hoc</a> (kombinieren Sie beide vor dem Ausführen):</p>
<pre>anderesObj := {}
anderesObj.base := obj
anderesObj.test()</pre>
<p>In diesem Fall erbt <i>anderesObj</i> das <i>foo</i> und <i>test</i> von <i>obj</i>. Diese Vererbung ist dynamisch - das heißt, wenn <code>obj.foo</code> modifiziert wird, wird <code>anderesObj.foo</code> diese Änderung widerspiegeln. Wenn das Skript <code>anderesObj.foo</code> einen Wert zuweist, wird dieser Wert in <i>anderesObj</i> gespeichert; weitere Änderungen an <code>obj.foo</code> hätten keinen Einfluss auf <code>anderesObj.foo</code>. Sobald <code>anderesObj.test()</code> aufgerufen wird, enthält ihr <i>this</i>-Parameter eine Referenz zu <i>anderesObj</i> statt zu <i>obj</i>.</p>

<h3 id="Custom_Classes">Klassen</h3>
<blockquote>Unter einer Klasse (auch Objekttyp genannt) versteht man in der objektorientierten Programmierung ein abstraktes Modell bzw. einen Bauplan für eine Reihe von ähnlichen Objekten. <a href="https://de.wikipedia.org/wiki/Klasse_(Objektorientierung)" class="source">Wikipedia</a></blockquote>
<p>Allgemein ausgedrückt ist eine <em>Klasse</em> eine Gruppe oder Kategorie von Dingen, die Eigenschaften oder Attribute gemeinsam nutzen. In AutoHotkey definiert <code>class</code> Eigenschaften, die von Instanzen der Klasse gemeinsam genutzt werden (und Methoden, die aufrufbare Eigenschaften sind). Eine <em>Instanz</em> ist schlicht ein Objekt, das Eigenschaften von der Klasse erbt und typischerweise auch als Teil dieser Klasse verstanden werden kann (z. B. mit dem Ausdruck <code><i>Instanz</i> is <i>KlasseName</i></code>). Instanzen werden typischerweise durch den Aufruf von <a href="lib/Class.htm#Call"><em>KlasseName</em>()</a> erzeugt.</p>
<p>Da Instanzen der <a href="lib/Object.htm">Object</a>-Klasse <a href="#ad-hoc">dynamisch</a> und <a href="#delegation">prototypenbasiert</a> sind, besteht jede Klasse aus zwei Teilen:</p>
<ul>
  <li>Die Klasse hat ein <a href="lib/Class.htm#Prototype">Prototyp</a>-Objekt, auf dem alle Instanzen der Klasse basieren. Alle Methoden und dynamischen Eigenschaften, die sich auf Instanzen der Klasse beziehen, sind im Prototypobjekt enthalten. Dazu gehören alle Eigenschaften und Methoden, denen das Schlüsselwort <code>static</code> fehlt.</li>
  <li>Die Klasse selbst ist ein Objekt, das nur statische Methoden und Eigenschaften enthält. Dazu gehören alle Eigenschaften und Methoden mit dem Schlüsselwort <code>static</code> und alle verschachtelten Klassen. Diese gelten nicht für eine bestimmte Instanz und können verwendet werden, indem man via Name auf die Klasse selbst verweist.</li>
</ul>
<p>Das Folgende zeigt die meisten Elemente einer Klassendefinition:</p>
<pre>class KlasseName extends BasisklasseName
{
    InstanzVar := <i>Ausdruck</i>
    
    static KlasseVar := <i>Ausdruck</i>

    class VerschachtelteKlasse
    {
        ...
    }

    Methode()
    {
        ...
    }
    
    static Methode()
    {
        ...
    }

    Eigenschaft[<i>Parameter</i>]  <em>; Eckige Klammern nur verwenden, wenn Parameter vorhanden sind.</em>
    {
        <span class="dec">get</span> {
            return <i>Eigenschaftswert</i>
        }
        <span class="dec">set</span> {
            <i>Speichere oder verarbeite</i> <span class="biv">value</span>
        }
    }
    
    KurzeEigenschaft
    {
        <span class="dec">get</span> =&gt; <i>Ausdruck zum Ermitteln des Eigenschaftswertes</i>
        <span class="dec">set</span> =&gt; <i>Ausdruck zum Speichern oder Verarbeiten von</i> <span class="biv">value</span>
    }
    
    KürzereEigenschaft =&gt; <i>Ausdruck zum Ermitteln des Eigenschaftswertes</i>
}
</pre>
<p>Dies konstruiert, nachdem das Skript geladen wurde, ein <a href="lib/Class.htm">Class</a>-Objekt und speichert es in eine <a href="Functions.htm#Global">globale</a> Konstante (schreibgeschützte Variable) namens <i>KlasseName</i>. Wenn <code>extends BasisklasseName</code> vorhanden ist, muss der <i>BasisklasseName</i> der vollständige Name einer anderen Klasse sein. Der vollständige Name jeder Klasse ist in <code><i>KlasseName</i>.Prototype.__Class</code> gespeichert.</p>
<p>Da der Zugriff auf die Klasse selbst über eine Variable erfolgt, kann der Klassenname nicht genutzt werden, um im selben Kontext sowohl die Klasse zu verweisen als auch eine separate Variable zu erstellen (um z. B. eine Instanz der Klasse zu enthalten). Zum Beispiel wird <code>box := Box()</code> nicht funktionieren, weil sowohl <code>box</code> als auch <code>Box</code> in dasselbe aufgelöst werden. Der Versuch, eine Top-Level-Klasse (nicht verschachtelte Klasse) auf diese Weise neu zuzuweisen, führt zu einem Ladezeitfehler.</p>
<p>In dieser Dokumentation bezieht sich das Wort "Klasse" in der Regel auf ein Klassenobjekt, das mit dem Schlüsselwort <code>class</code> erstellt wurde.</p>
<p>Klassendefinitionen können Variablendeklarationen, Methodendefinitionen und Unterklassendefinitionen enthalten.</p>

<h4 id="Custom_Classes_var">Instanzvariablen</h4>
<p>Eine <em>Instanzvariable</em> ist eine Variable, von der jede Instanz der Klasse eine eigene Kopie hat. Sie werden wie normale Zuweisungen deklariert und verhalten sich auch wie solche, aber das Präfix <code>this.</code> wird weggelassen (nur direkt innerhalb des Klassenkörpers):</p>
<pre>InstanzVar := Ausdruck</pre>
<p>Solche Deklarationen werden jedes Mal ausgewertet, wenn eine neue Instanz der Klasse mit <a href="lib/Class.htm#Call"><em>KlasseName</em>()</a> erstellt wird, nachdem alle Basisklassendeklarationen ausgewertet wurden, aber bevor <a href="#Custom_NewDelete">__New</a> aufgerufen wird. Dies wird erreicht, indem automatisch eine Methode mit dem Namen <em>__Init</em> erstellt wird, die einen Aufruf von <code>super.__Init()</code> enthält, und jede Deklaration in diese eingefügt wird. Daher darf eine einzelne Klassendefinition weder eine __Init-Methode noch eine Instanzvariablendeklaration enthalten.</p>
<p><em>Ausdruck</em> kann mit <code>this</code> auf andere Instanzvariablen und Methoden zugreifen. Globale Variablen können gelesen, aber nicht zugewiesen werden. Eine zusätzliche Zuweisung (oder die Verwendung des <a href="Variables.htm#ref">Referenzoperators</a>) innerhalb des Ausdrucks erzeugt in der Regel eine Variable, die lokal für die __Init-Methode ist. <code>x := y := 1</code> beispielsweise würde <code>this.x</code> und eine lokale Variable <code>y</code> setzen (die wieder freigegeben wird, sobald alle Initialisierungen ausgewertet wurden).</p>
<p>Um Zugriff auf eine Instanzvariable zu erhalten (sogar innerhalb einer Methode), müssen Sie immer das Zielobjekt angeben; zum Beispiel <code><b>this</b>.InstanzVar</code>.</p>
<p>Deklarationen wie <code>x.y := z</code> werden auch unterstützt, sofern <code>x</code> zuvor in dieser Klasse definiert wurde. <code>x := {}, x.y := 42</code> würde beispielsweise <code>x</code> deklarieren und außerdem <code>this.x.y</code> initialisieren.</p>

<h4 id="Custom_Classes_staticvar">Statische bzw. Klassenvariablen</h4>
<p>Statische bzw. Klassenvariablen gehören nur der Klasse selbst, allerdings können ihre Werte von Unterklassen geerbt werden. Solche Variablen müssen mit dem Schlüsselwort "static" deklariert werden:</p>
<pre>static KlasseVar := Ausdruck</pre>
<p>Diese Deklarationen werden nur einmal ausgewertet, während die Klasse <a href="#static__New">initialisiert</a> wird. Zu diesem Zweck wird automatisch eine statische Methode namens <em>__Init</em> definiert.</p>
<p>Jede Deklaration fungiert wie eine normale Eigenschaftszuweisung, mit dem Klassenobjekt als Ziel. <em>Ausdruck</em> wird ähnlich interpretiert wie bei Instanzvariablen, außer dass <code>this</code> auf die Klasse selbst verweist.</p>
<p>Um einer Klassenvariable irgendwo anders etwas zuzuweisen, müssen Sie immer das Klassenobjekt angeben; zum Beispiel <code><b>KlasseName</b>.KlasseVar := Wert</code>. Wenn eine Unterklasse keine Eigenschaft mit diesem Namen besitzt, kann <code><i>Unterklasse</i>.KlasseVar</code> auch genutzt werden, um den Wert abzurufen; wenn der Wert eine Referenz zu einem Objekt ist, werden Unterklassen sich dieses Objekt standardmäßig teilen. Allerdings würde <code><i>Unterklasse</i>.KlasseVar := y</code> den Wert nicht in <em>KlasseName</em>, sondern in <em>Unterklasse</em> speichern.</p>
<p>Deklarationen wie <code>static x.y := z</code> werden auch unterstützt, sofern <code>x</code> zuvor in dieser Klasse definiert wurde. <code>static x := {}, x.y := 42</code> würde beispielsweise <code>x</code> deklarieren und außerdem <code><i>KlasseName</i>.x.y</code> initialisieren. Da <a href="lib/Class.htm#Prototype">Prototype</a> implizit in jeder Klasse definiert ist, kann <code>static Prototype.gemeinsamerWert := 1</code> genutzt werden, um Werte zu setzen, die dynamisch von allen Instanzen der Klasse geerbt werden (bis sie von einer Eigenschaft auf der Instanz selbst überschattet werden).</p>

<h4 id="Custom_Classes_class">Verschachtelte Klassen</h4>
<p>Verschachtelten Klassendefinitionen ermöglichen es, ein Klassenobjekt mit einer statischen Variable/Klassenvariable der äußeren Klasse statt mit einer separaten globalen Variablen zu assoziieren. Im obigen Beispiel konstruiert <code>class VerschachtelteKlasse</code> ein <a href="lib/Class.htm">Class</a>-Objekt und speichert es in <code>KlasseName.VerschachtelteKlasse</code>. Unterklassen können <em>VerschachtelteKlasse</em> erben oder es mit ihrer eigenen verschachtelten Klasse überschreiben (in diesem Fall kann mit <code>(<i>WelcheKlasse</i>.VerschachtelteKlasse)()</code> eine geeignete Klasse instanziiert werden).</p>
<pre>
class VerschachtelteKlasse
{
    ...
}
</pre>
<p>Die Verschachtelung einer Klasse bedeutet nicht, dass eine bestimmte Beziehung zur äußeren Klasse besteht. Die verschachtelte Klasse wird weder automatisch instanziiert, noch haben Instanzen der verschachtelten Klasse eine Verbindung zu einer Instanz der äußeren Klasse, es sei denn, das Skript stellt diese Verbindung explizit her.</p>
<p>Aufgrund der Funktionsweise der Methoden bei <a href="lib/Object.htm">Object</a>-Klassen übergibt <code><i>WelcheKlasse</i>.VerschachtelteKlasse()</code> jedoch implizit <em>WelcheKlasse</em> als ersten Parameter, äquivalent zu <code><i>WelcheKlasse</i>.VerschachtelteKlasse.Call(<i>WelcheKlasse</i>)</code>. Sofern <code>static Call()</code> nicht überschrieben wird, wird dieser Parameter automatisch an <a href="#Custom_NewDelete">__New</a> übergeben.</p>

<h4 id="Custom_Classes_method">Methoden</h4>
<p>Methodendefinitionen sehen genauso aus wie Funktionsdefinitionen. Jede Methodendefinition erstellt ein <a href="lib/Func.htm">Func</a> mit einem versteckten ersten Parameter namens <code>this</code>, und definiert eine Eigenschaft, die zum Aufrufen der Methode oder zum Abrufen ihres Funktionsobjekts verwendet wird.</p>
<p>Es gibt zwei Arten von Methoden:</p>
<ul>
  <li>Instanzmethoden sind wie folgt definiert und an den <a href="lib/Class.htm#Prototype">Prototyp</a> der Klasse gekoppelt, wodurch sie über jede Instanz der Klasse zugänglich sind. Wenn die Methode aufgerufen wird, verweist <code>this</code> auf eine Instanz der Klasse.</li>
  <li>Um statische Methoden zu definieren, muss vor dem Methodennamen das separate Schlüsselwort <code>static</code> verwendet werden. Diese sind an das Klassenobjekt selbst gekoppelt, allerdings werden diese auch von Unterklassen geerbt, so dass <code>this</code> entweder auf die Klasse selbst oder auf eine Unterklasse verweist.</li>
</ul>
<p>Die Methodendefinition unten erstellt eine Eigenschaft vom gleichen Typ wie <code><i>Ziel</i>.DefineProp('Methode', {call: <i>funcObj</i>})</code>. Standardmäßig gibt <code><i>Ziel</i>.Methode</code> <em>funcObj</em> zurück, und der Versuch, <code><i>Ziel</i>.Methode</code> etwas zuzuweisen, löst einen Fehler aus. Diese Standardverhaltensweisen können durch <a href="#Custom_Classes_property">Definieren einer Eigenschaft</a> oder Aufrufen von <a href="lib/Object.htm#DefineProp">DefineProp</a> überschrieben werden.</p>
<pre>
Methode()
{
    ...
}
</pre>

<p>Die <a href="Variables.htm#fat-arrow">Fat-Arrow-Syntax</a> kann genutzt werden, um eine einzeilige Methode für die Rückgabe eines Ausdrucks zu definieren:</p>
<pre>Methode() =&gt; <i>Ausdruck</i></pre>

<h4 id="Custom_Classes_super">Super</h4>
<p>Innerhalb einer Methode oder eines Eigenschaft-Getters/Setters kann das Schlüsselwort <code>super</code> anstelle von <code>this</code> verwendet werden, um auf Superklassen-Versionen von Methoden oder Eigenschaften, die in einer abgeleiteten Klasse überschrieben werden, zugreifen zu können. <code>super.Methode()</code> in der Klasse oben würde beispielsweise bewirken, dass typischerweise eine Version von <em>Methode</em> aufgerufen wird, die innerhalb von <em>BasisklasseName</em> definiert wurde. Hinweis:</p>
<ul>
  <li><code>super.Methode()</code> ruft immer die Basis der Klasse oder des Prototypobjekts auf, das mit der ursprünglichen Definition der aktuellen Methode verknüpft ist, sogar wenn <code>this</code> von einer <em>Unterklasse</em> aus dieser Klasse oder von einer ganz anderen Klasse abstammt.</li>
  <li><code>super.Methode()</code> übergibt implizit <code>this</code> als ersten (versteckten) Parameter.</li>
  <li>Da nicht bekannt ist, wo (oder ob) <em>KlasseName</em> innerhalb der Kette von Basisobjekten existiert, wird <em>KlasseName</em> selbst als Ausgangspunkt verwendet. Daher ist <code>super.Methode()</code> meistens äquivalent zu <code>(<i>KlasseName</i>.Prototype.base.Methode)(this)</code> (aber ohne <em>Prototype</em>, wenn <em>Methode</em> statisch ist). Allerdings wird <code><i>KlasseName</i>.Prototype</code> beim Laden des Skripts aufgelöst.</li>
  <li>Es wird ein Fehler ausgelöst, wenn die Eigenschaft nicht in einer Superklasse definiert ist oder nicht aufgerufen werden kann.</li>
</ul>
<p>Nach dem Schlüsselwort <code>super</code> muss eines der folgenden Symbole erfolgen: <code>.[(</code></p>
<p><code>super()</code> ist äquivalent zu <code>super.call()</code>.</p>

<h4 id="Custom_Classes_property">Eigenschaften</h4>
<p>Eine Eigenschaftsdefinition erzeugt eine <a href="lib/Object.htm#DefineProp">dynamische Eigenschaft</a>, die eine Methode aufruft, anstatt einfach einen Wert zu speichern oder zurückzugeben.</p>
<pre>Eigenschaft[<i>Parameter</i>]
{
    <span class="dec">get</span> {
        return <i>Eigenschaftswert</i>
    }
    <span class="dec">set</span> {
        <i>Speichere oder verarbeite</i> <span class="biv">value</span>
    }
}
</pre>
<p><em>Eigenschaft</em> ist der Name der Eigenschaft, mit dem sie aufgerufen werden kann. <code>obj.Eigenschaft</code> würde beispielsweise <em>get</em> aufrufen, und <code>obj.Eigenschaft := Wert</code> würde <em>set</em> aufrufen. Innerhalb von <em>get</em> oder <em>set</em> bezieht sich <code>this</code> auf das Objekt, das aufgerufen wird. Innerhalb von <em>set</em> enthält <code>value</code> den Wert, der zugewiesen wird.</p>
<p>Die Definition und Übergabe von Parametern erfolgt auf der rechten Seite des Eigenschaftsnamens, in eckigen Klammern - allerdings sollten diese weggelassen werden, wenn keine Parameter vorhanden sind (siehe unten). Abgesehen von den eckigen Klammern werden Eigenschaftsparameter genauso wie Methodenparameter definiert - optionale, variadische und ByRef-Parameter werden unterstützt.</p>
<p>Wenn eine Eigenschaft mit Parametern aufgerufen wird, aber keine definiert sind, werden Parameter automatisch an die <a href="#__Item">__Item</a>-Eigenschaft des von <em>get</em> zurückgegebenen Objekts weitergeleitet. <code>this.Eigenschaft[x]</code> beispielsweise hätte die gleiche Wirkung wie <code>(this.Eigenschaft)[x]</code> oder <code>y := this.Eigenschaft, y[x]</code>. Leere Klammern (<code>this.Eigenschaft[]</code>) führen dazu, dass die __Item-Eigenschaft des Wertes von <em>Eigenschaft</em> immer aufgerufen wird, aber ein variadischer Aufruf wie <code>this.Eigenschaft[Args*]</code> hat diesen Effekt nur, wenn die Anzahl der Parameter ungleich Null ist.</p>
<p>Um statische Eigenschaften zu definieren, muss vor dem Eigenschaftsnamen das separate Schlüsselwort <code>static</code> verwendet werden. In diesem Fall verweist <code>this</code> auf die Klasse selbst oder eine Unterklasse.</p>
<p>Der Rückgabewert von <em>set</em> wird ignoriert. <code>Wert := obj.Eigenschaft := 42</code> beispielsweise wird immer <code>Wert := 42</code> zuweisen, egal was die Eigenschaft macht, es sei denn, sie löst eine Ausnahme aus oder beendet den Thread.</p>
<p>Jede Klasse kann eine oder beide Hälften einer Eigenschaft definieren. Wenn eine Klasse eine Eigenschaft überschreibt, kann sie <code><a href="#Custom_Classes_super">super.Eigenschaft</a></code> benutzen, um auf die via eigene Basisklasse definierte Eigenschaft zugreifen zu können. Wenn <em>Get</em> oder <em>Set</em> nicht definiert ist, kann es von einem Basisobjekt geerbt werden. Wenn <em>Get</em> undefiniert ist, kann die Eigenschaft einen Wert zurückgeben, der von einer Basis geerbt wurde. Wenn <em>Set</em> in diesem und allen Basisobjekten undefiniert ist (oder von einer geerbten Werteigenschaft verschleiert wird), führt der Versuch, die Eigenschaft zu setzen, zum Auslösen einer Ausnahme.</p>
<p>Eine Eigenschaftsdefinition mit sowohl <em>Get</em> als auch <em>Set</em> erstellt faktisch zwei separate Funktionen, die weder lokale oder statische Variablen noch verschachtelte Funktionen gemeinsam nutzen. Analog zu den Methoden hat jede Funktion einen versteckten Parameter namens <code>this</code>, und <em>Set</em> hat einen zweiten versteckten Parameter namens <code>value</code>. Explizit definierte Parameter erfolgen danach.</p>
<p>Während eine Eigenschaftsdefinition die <em>Get</em>- und <em>Set</em>-Akzessorfunktionen für eine Eigenschaft auf die gleiche Weise wie <a href="lib/Object.htm#DefineProp">DefineProp</a> definiert, definiert eine Methodendefinition die <em>Call</em>-Akzessorfunktion. Jede Klasse kann eine Eigenschaftsdefinition und eine Methodendefinition mit demselben Namen enthalten. Wenn eine Eigenschaft ohne <em>Call</em>-Akzessorfunktion (eine Methode) aufgerufen wird, wird <em>Get</em> ohne Parameter aufgerufen und das Ergebnis anschließend als Methode aufgerufen.</p>

<h4 id="Custom_Classes_property_short">Fat-Arrow-Eigenschaften</h4>
<p>Die <a href="Variables.htm#fat-arrow">Fat-Arrow-Syntax</a> kann genutzt werden, um einen <a href="#Custom_Classes_property">Eigenschaft</a>-Getter oder -Setter für die Rückgabe eines Ausdrucks zu definieren:</p>
<pre>KurzeEigenschaft[<i>Parameter</i>]
{
    <span class="dec">get</span> =&gt; <i>Ausdruck zum Ermitteln des Eigenschaftswertes</i>
    <span class="dec">set</span> =&gt; <i>Ausdruck zum Speichern oder Verarbeiten von</i> <span class="biv">value</span>
}</pre>
<p>Wenn man nur einen Getter definiert, können die geschweiften Klammern und <code>get</code> weggelassen werden:</p>
<pre>KürzereEigenschaft[[<i>Parameter</i>] =&gt; <i>Ausdruck zum Ermitteln des Eigenschaftswertes</i></pre>
<p>In beiden Fällen müssen die eckigen Klammern weggelassen werden, sofern keine Parameter definiert sind.</p>

<h3 id="__Enum">__Enum-Methode</h3>
<pre class="Syntax">__Enum(AnzahlVars)</pre>
<p>Die __Enum-Methode wird aufgerufen, wenn das Objekt an eine <a href="lib/For.htm">For-Schleife</a> übergeben wird. Diese Methode sollte einen <a href="lib/Enumerator.htm">Enumerator</a> zurückgeben, der Elemente im Objekt, wie z. B. Array-Elemente, zurückgeben wird. Wenn es undefiniert bleibt, kann das Objekt nicht direkt an eine For-Schleife übergeben werden, es sei denn, es hat eine <a href="lib/Enumerator.htm#Call">Enumerator-kompatible Call-Methode</a>.</p>
<p><em>AnzahlVars</em> enthält die Anzahl der Variablen, die an die For-Schleife übergeben wurden. Wenn <em>AnzahlVars</em> 2 ist, wird erwartet, dass der Enumerator dem ersten Parameter den Schlüssel oder Index eines Elements und dem zweiten Parameter den Wert zuweist. Jeder Schlüssel oder Index sollte als Parameter der <a href="#__Item">__Item</a>-Eigenschaft akzeptiert werden. Dadurch können <a href="AHKL_DBGPClients.htm">DBGp-basierte Debugger</a> ein bestimmtes Element abrufen oder setzen, nachdem sie via Enumerator aufgelistet wurden.</p>

<h3 id="__Item">__Item-Eigenschaft</h3>
<p>Die __Item-Eigenschaft wird indirekt aufgerufen, wenn der Indexierungsoperator (Array-Syntax) in Verbindung mit dem Objekt verwendet wird. Im folgenden Beispiel wird die Eigenschaft als statisch deklariert, so dass der Indexierungsoperator bei der Env-Klasse selbst angewendet werden kann. Ein weiteres Beispiel finden Sie unter <a href="#Array2D">Array2D</a>.</p>
<pre>class Env {
    static __Item[name] {
        get =&gt; EnvGet(name)
        set =&gt; EnvSet(name, value)
    }
}

Env["PATH"] .= ";" A_ScriptDir  <em>; Hat nur Einfluss auf dieses Skript und Unterprozesse.</em>
MsgBox Env["PATH"]</pre>
<p><code>__Item</code> ist quasi ein Standardeigenschaftsname (wenn so eine Eigenschaft definiert wurde):</p>
<ul>
  <li><code><i>object</i>[<i>params</i>]</code> ist äquivalent zu <code><i>object</i>.__Item[<i>params</i>]</code>, wenn Parameter vorhanden sind.</li>
  <li><code><i>object</i>[]</code> ist äquivalent zu <code><i>object</i>.__Item</code>.</li>
</ul>
<p>Zum Beispiel:</p>
<pre>
obj := {}
obj[] := Map()     <em>; Äquivalent zu obj.__Item := Map()</em>
obj["base"] := 10
MsgBox obj.base = Object.prototype  <em>; True</em>
MsgBox obj["base"]                  <em>; 10</em>
</pre>
<p class="note"><strong>Hinweis:</strong> Wenn ein expliziter Eigenschaftsname mit leeren eckigen Klammern kombiniert wird, wie in <code>obj.prop[]</code>, wird dies als zwei separate Operationen behandelt: zuerst wird <code>obj.prop</code> abgerufen, danach indirekt die Standardeigenschaft des Ergebnisses aufgerufen. Dies ist Bestandteil der Sprachsyntax und somit objektunabhängig.</p>

<h3 id="Custom_NewDelete">Konstruktion und Destruktion</h3>
<p>Wenn ein Objekt mit der Standardimplementierung von <a href="lib/Class.htm#Call"><em>KlasseName</em>()</a> erstellt wird, wird die <code>__New</code>-Methode des neuen Objekts aufgerufen, um eine benutzerdefinierte Initialisierung zu ermöglichen. Alle Parameter, die an <code><i>KlasseName</i>()</code> übergeben werden, werden an <code>__New</code> weitergeleitet, so dass sie den ursprünglichen Inhalt des Objekts oder die Art und Weise, wie es konstruiert ist, beeinflussen können. Zerstört man ein Objekt, wird <code>__Delete</code> aufgerufen. Zum Beispiel:</p>
<pre>m1 := GMem(0, 10)
m2 := {base: GMem.Prototype}, m2.__New(0, 30)

<em>; Hinweis: Für allgemeine Speicherreservierungen sollten Sie stattdessen <a href="lib/Buffer.htm">Buffer</a>() verwenden.</em>
class GMem<span id="GMem"></span>
{
    __New(aFlags, aGröße)
    {
        this.ptr := DllCall("GlobalAlloc", "UInt", aFlags, "Ptr", aGröße, "Ptr")
        if !this.ptr
            throw MemoryError()
        MsgBox "New GMem mit einer Größe von " aGröße " Bytes auf der Adresse " this.ptr "."
    }

    __Delete()
    {
        MsgBox "Delete GMem auf der Adresse " this.ptr "."
        DllCall("GlobalFree", "Ptr", this.ptr)
    }
}</pre>
<p>__Delete wird nicht bei Objekten aufgerufen, die eine Eigenschaft namens "__Class" besitzen. <a href="lib/Class.htm#Prototype">Prototypobjekte</a> haben standardmäßig diese Eigenschaft.</p>
<p>Wenn eine Ausnahme oder ein Laufzeitfehler ausgelöst wird, während __Delete ausgeführt wird, und nicht innerhalb von __Delete behandelt wird, verhält es sich so, als wäre __Delete von einem neuen <a href="misc/Threads.htm">Thread</a> aufgerufen wurden. Das heißt, dass ein Fehlerdialogfenster angezeigt und __Delete durchgeführt wird, aber der Thread nicht beendet wird (es sei denn, er wurde bereits beendet).</p>
<p>Wenn das Skript auf irgendeine Weise direkt terminiert wird, z. B. über das Tray-Menü oder <a href="lib/ExitApp.htm">ExitApp</a>, erhalten alle Funktionen, die noch nicht zu ihrem Aufrufer zurückgekehrt sind, keine Chance, dies jemals zu tun. Daher werden alle Objekte, die von lokalen Variablen dieser Funktionen referenziert werden, nicht freigegeben, was zur Folge hat, dass __Delete nicht aufgerufen wird.</p>
<p>Wenn das Skript beendet wird, werden Objekte, die in globalen und statischen Variablen enthalten sind, automatisch in einer willkürlichen, von der Implementierung festgelegten Reihenfolge freigegeben. Wenn __Delete während dieses Vorgangs aufgerufen wird, können einige globale oder statische Variablen bereits freigegeben worden sein, aber alle Referenzen, die das Objekt selbst enthält, sind nach wie vor gültig. Daher ist es am besten, wenn __Delete völlig eigenständig ist und nicht auf globale oder statische Variablen angewiesen ist.</p>

<h4 id="static__New">Initialisierung einer Klasse</h4>
<p>Jede Klasse wird automatisch initialisiert, wenn eine Referenz zur Klasse erstmals ausgewertet wird. Wenn z. B. <em>MeineKlasse</em> noch nicht initialisiert wurde, würde <code>MeineKlasse.MeineEigen</code> bewirken, dass die Klasse initialisiert wird, bevor die Eigenschaft abgerufen wird. Die Initialisierung umfasst den Aufruf von zwei statischen Methoden: __Init und __New.</p>
<p><code>static __Init</code> wird automatisch für jede Klasse definiert und beginnt immer mit einer Referenz zur Basisklasse, falls eine angegeben wurde, um sicherzustellen, dass sie initialisiert ist. <a href="#Custom_Classes_staticvar">Statische bzw. Klassenvariablen</a> und <a href="#Custom_Classes_class">verschachtelte Klassen</a> werden in der Reihenfolge initialisiert, in der sie definiert wurden, außer wenn eine verschachtelte Klasse während der Initialisierung einer vorherigen Variable oder Klasse referenziert wird.</p>
<p>Wenn die Klasse eine <code>static __New</code>-Methode definiert oder erbt, wird diese unmittelbar nach __Init aufgerufen. Es ist wichtig zu beachten, dass __New einmal für die Klasse, in der es definiert ist, <em>und</em> einmal für jede Unterklasse, die keine eigene definiert (oder die <code>super.__New()</code> aufruft), aufgerufen werden kann. Dies kann verwendet werden, um allgemeine Initialisierungsaufgaben für jede Unterklasse durchzuführen oder Unterklassen vor ihrer Verwendung in irgendeiner Weise zu modifizieren.</p>
<p>Wenn <code>static __New</code> nicht mit abgeleiteten Klassen agieren soll, kann dies durch die Überprüfung des Wertes von <code>this</code> vermieden werden. In manchen Fällen kann es ausreichen, dass sich die Methode selbst löscht, wie z. B. bei <code>this.DeleteProp('__New')</code>; allerdings könnte die erste Ausführung von __New für eine Unterklasse sein, wenn diese in der Basisklasse verschachtelt ist oder bei der Initialisierung einer statischen bzw. Klassenvariable referenziert wird.</p>
<p>Eine Klassendefinition bewirkt auch, dass die Klasse referenziert wird. Mit anderen Worten: Wenn die Ausführung bei der <a href="Scripts.htm#auto">Startphase des Skripts</a> eine Klassendefinition erreicht, werden __Init und __New automatisch aufgerufen, es sei denn, die Klasse wurde bereits vom Skript referenziert. Wenn die Ausführung jedoch daran gehindert wird, die Klassendefinition zu erreichen, z. B. durch <code>return</code> oder eine Endlosschleife, wird die Klasse nur dann initialisiert, wenn sie referenziert wird.</p>
<p>Wenn die automatische Initialisierung einmal begonnen hat, wird sie für dieselbe Klasse nicht erneut durchgeführt. Dies ist grundsätzlich kein Problem, es sei denn, mehrere Klassen referenzieren sich gegenseitig. Ziehen Sie zum Beispiel die beiden folgenden Klassen in Betracht. Wenn <code>A</code> zuerst initialisiert wird, bewirkt die Auswertung von <code>B.SharedArray</code> (A1), dass <code>B</code> initialisiert wird, bevor der Wert abgerufen und zurückgegeben wird, aber <code>A.SharedValue</code> (A3) ist undefiniert und bewirkt keine Initialisierung von <code>A</code>, da diese bereits im Gange ist. Soll heißen: Wenn der Zugriff auf oder die Initialisierung von <code>A</code> zuerst erfolgt, ist die Reihenfolge A1 bis A3, sonst B1 bis B4:</p>
<pre>MsgBox A.SharedArray.Length
MsgBox B.SharedValue

class A {
    static SharedArray := B.SharedArray   <em>; A1          ; B3</em>
    static SharedValue := 42                            <em>; B4</em>
}

class B {
    static SharedArray := StrSplit("XYZ") <em>; A2          ; B1</em>
    static SharedValue := A.SharedValue   <em>; A3 (Error)  ; B2</em>
}</pre>

<h3 id="Meta_Functions">Metafunktionen</h3>
<pre class="Syntax">
class <i>KlasseName</i> {
    __Get(Name, Params)
    __Set(Name, Params, Wert)
    __Call(Name, Params)
}
</pre>
<dl>
  <dt>Name</dt>
  <dd><p>Der Name der Eigenschaft oder Methode.</p></dd>
  <dt>Params</dt>
  <dd><p>Ein <a href="lib/Array.htm">Array</a> mit Parametern. Dazu gehören nur die Parameter zwischen <code>()</code> oder <code>[]</code>, die also leer sein können. Die Metafunktion soll Fälle wie <code>x.y[z]</code> behandeln, in denen <code>x.y</code> nicht definiert ist.</p></dd>
  <dt>Wert</dt>
  <dd><p>Der Wert, der zugewiesen wird.</p></dd>
</dl>
<p>Metafunktionen definieren, was passieren soll, wenn eine undefinierte Eigenschaft oder Methode aufgerufen wird. Wenn <code>obj.unk</code> beispielsweise keinen Wert zugewiesen bekommen hat, wird die <i>__Get</i>-Metafunktion aufgerufen. <code>obj.unk := value</code> veranlasst hingegen den Aufruf von <i>__Set</i> und <code>obj.unk()</code> den Aufruf von <i>__Call</i>.</p>
<p>Eigenschaften und Methoden können im Objekt selbst oder in einem seiner <a href="#delegation">Basisobjekte</a> definiert werden. Damit für jede Eigenschaft eine Metafunktion aufgerufen werden kann, sollten Sie grundsätzlich vermeiden, irgendwelche Eigenschaften zu definieren. Interne Eigenschaften wie <a href="lib/Object.htm#Base">Base</a> können mit einer <a href="#Custom_Classes_property">Eigenschaftsdefinition</a> oder <a href="lib/Object.htm#DefineProp">DefineProp</a> überschrieben werden.</p>
<p>Wenn eine Metafunktion definiert ist, muss sie die gewünschte Standardaktion ausführen. Zum Beispiel kann Folgendes erwartet werden:</p>
<ul>
  <li><i>Call</i>: Löse einen <a href="lib/Error.htm#MethodError">MethodError</a> aus.</li>
  <li>Wenn Parameter angegeben wurden, löse eine Ausnahme aus (es gibt kein Objekt, an das die Parameter weitergeleitet werden können).</li>
  <li><i>Get</i>: Löse einen <a href="lib/Error.htm#PropertyError">PropertyError</a> aus.</li>
  <li><i>Set</i>: Definiere eine neue Eigenschaft mit dem angegebenen Wert, z. B. durch Aufruf von <a href="lib/Object.htm#DefineProp">DefineProp</a>. </li>
</ul>
<p>Es kann ein beliebiges <a href="misc/Functor.htm">aufrufbares Objekt</a> als Metafunktion verwendet werden, wenn man es der entsprechenden Eigenschaft zuweist.</p>
<p>Metafunktionen werden in den folgenden Fällen nicht aufgerufen:</p>
<ul>
  <li><code>x[y]</code>: Die Verwendung von eckigen Klammern ohne Eigenschaftsnamen ruft nur die <a href="#__Item">__Item</a>-Eigenschaft auf.</li>
  <li><code>x()</code>: Der Aufruf des Objekts selbst ruft nur die <code>Call</code>-Methode auf. Dazu gehören interne Aufrufe von internen Funktionen wie <a href="lib/SetTimer.htm">SetTimer</a> und <a href="lib/Hotkey.htm">Hotkey</a>.</li>
  <li>Interne Aufrufe von anderen Metafunktionen oder Doppel-Unterstrich-Methoden lösen <code>__Call</code> nicht aus.</li>
</ul>

<h4 id="Dynamic_Properties">Dynamische Eigenschaften</h4>
<p>Mit der <a href="#Custom_Classes_property">Eigenschaftssyntax</a> und <a href="lib/Object.htm#DefineProp">DefineProp</a> können Eigenschaften definiert werden, die jedes Mal, wenn sie ausgewertet werden, einen Wert berechnen, allerdings muss jede Eigenschaft im Voraus definiert sein. Mit <em>__Get</em> und <em>__Set</em> können hingegen Eigenschaften implementiert werden, die erst zum Zeitpunkt ihres Aufrufs bekannt sind.</p>
<p>Zum Beispiel kann ein "Proxy-Objekt" mit Eigenschaften erstellt werden, die den aktuellen Wert über das Netzwerk (oder über einen anderen Kanal) abfragen. Ein Remote-Server sendet eine Antwort zurück, die den Wert der Eigenschaft enthält, und das Proxy-Objekt übergibt den Wert an seinen Aufrufer. Auch wenn der Name jeder Eigenschaft im Voraus bekannt war, wäre es unlogisch, jede Eigenschaft einzeln in der Proxy-Klasse zu definieren, da jede Eigenschaft dasselbe tun würde (eine Netzwerkanfrage senden). Metafunktionen bekommen den Namen der Eigenschaft als Parameter, demzufolge sind sie eine gute Lösung für dieses Problem.</p>

<h2 id="primitive">Primitive Werte</h2>
<p>Primitive Werte, wie Zeichenketten und Zahlen, können keine eigenen Eigenschaften und Methoden haben. Allerdings unterstützen primitive Werte die gleiche Art von <a href="#delegation">Delegation</a> wie Objekte. Das heißt, dass jede Eigenschaft oder Methode, die einen primitiven Wert aufruft, an ein vordefiniertes Prototypobjekt delegiert wird, das auch über die <a href="lib/Class.htm#Prototype">Prototype</a>-Eigenschaft der entsprechenden Klasse zugänglich ist. Die folgenden Klassen beziehen sich auf primitive Werte:</p>
<ul style="line-height: 1.5">
  <li>Primitive (extends <a href="lib/Any.htm">Any</a>) <ul style="padding-left: 1.7em">
    <li>Number <ul style="padding-left: 1.7em">
      <li>Float</li>
      <li>Integer</li>
    </ul></li>
    <li>String</li>
  </ul></li>
</ul>
<p>Obwohl die Überprüfung der <a href="lib/Type.htm">Type</a>-Zeichenkette in der Regel schneller ist, kann der Typ eines Wertes getestet werden, indem überprüft wird, ob der Wert eine Basis hat. <code>n.HasBase(Number.Prototype)</code> oder <code>n is Number</code> beispielsweise ist True, wenn <em>n</em> ein reiner Integer oder eine reine Floating-Point-Zahl ist, aber False, wenn <em>n</em> eine numerische Zeichenkette ist, da String nicht von Number ableitet. <code>IsNumber(n)</code> hingegen ist True, wenn <em>n</em> eine Zahl oder numerische Zeichenkette ist.</p>
<p><a href="lib/Any.htm#GetBase">ObjGetBase</a> und die <a href="lib/Any.htm#Base">Base</a>-Eigenschaft geben eines der vordefinierten Prototypobjekte zurück, wenn es angebracht ist.</p>
<p>Beachten Sie, dass <code>x is Any</code> normalerweise für jeden Wert innerhalb der Typenhierarchie von AutoHotkey True, aber für COM-Objekte False ist.</p>

<h3 id="primitive-extension">Hinzufügen von Eigenschaften und Methoden</h3>
<p>Eigenschaften und Methoden können für alle Werte eines bestimmten Typs hinzugefügt werden, indem das Prototypobjekt dieses Typs geändert wird. Da aber ein primitiver Wert keine Instanz der Object-Klasse ist und keine eigenen Eigenschaften oder Methoden haben kann, können die primitiven Prototypobjekte nicht von <code>Object.Prototype</code> ableiten. Mit anderen Worten: Man kann standardmäßig nicht auf Methoden wie <a href="lib/Object.htm#DefineProp">DefineProp</a> und <a href="lib/Object.htm#HasOwnProp">HasOwnProp</a> zugreifen. Diese können indirekt aufgerufen werden. Zum Beispiel:</p>
<pre>
DefProp := {}.DefineProp
DefProp( "".base, "Length", { get: StrLen } )
MsgBox A_AhkPath.length " == " StrLen(A_AhkPath)
</pre>
<p>Obwohl primitive Werte Werteigenschaften von ihrem Prototyp erben können, wird eine Ausnahme ausgelöst, wenn das Skript versucht, eine Werteigenschaft auf einen primitiven Wert zu setzen. Zum Beispiel:</p>
<pre>"".base.test := 1  <em>; Bitte nicht nachmachen.</em>
MsgBox "".test  <em>; 1</em>
"".test := 2  <em>; Fehler: Eigenschaft ist schreibgeschützt.</em></pre>
<p>Obwohl __Set- und Eigenschaft-Setter genutzt werden können, sind sie nicht nützlich, da primitive Werte als unveränderlich zu betrachten sind.</p>

<h2 id="Implementation">Implementierung</h2>
<span id="Refs"></span><h3 id="Reference_Counting">Referenzzählung</h3>
<p>AutoHotkey verwendet einen einfachen Referenzzählungsmechanismus, um automatisch Ressourcen freizugeben, falls ein Objekt nicht länger in einem Skript benötigt bzw. verwiesen wird. Skript-Autoren sollten diesen Mechanismus nicht explizit aufrufen, es sei denn, sie müssen sich direkt mit unverwalteten <a href="#ObjPtr">Objekt-Pointern</a> befassen.</p>
<p>Temporär zurückgegebene Referenzen von Funktionen, Methoden oder Operatoren innerhalb eines Ausdrucks werden erst freigegeben, wenn die Auswertung dieses Ausdrucks abgeschlossen oder abgebrochen wurde. Im folgenden Beispiel wird das neue <a href="#GMem">GMem</a>-Objekt erst nach Durchführung von MsgBox freigegeben:</p>
<pre>MsgBox <a href="lib/DllCall.htm">DllCall</a>("GlobalSize", "ptr", GMem(0, 20).ptr, "ptr")  <em>; 20</em></pre>
<p class="note"><strong>Hinweis:</strong> In diesem Beispiel kann <code>.ptr</code> auch weggelassen werden, da der <a href="lib/DllCall.htm#ptr">Ptr</a>-Argumenttyp Objekte mit einer <code>Ptr</code>-Eigenschaft zulässt. Allerdings funktioniert das oben gezeigte Muster auch mit anderen Eigenschaftsnamen.</p>
<p>Um eine Aktion nach Freigabe der letzten Referenz zu einem Objekt durchzuführen, implementieren Sie die <a href="#Custom_NewDelete">__Delete</a>-Metafunktion.</p>
<p><b>Bekannte Einschränkungen:</b></p>
<ul>
  <li>Zirkelbezüge müssen unterbrochen werden, bevor ein Objekt freigegeben werden kann. Siehe <a href="#Circular_References">Freigeben von Objekten</a>, um anhand eines Beispiels mehr darüber zu erfahren.</li>
  <li>Im Gegensatz zu Referenzen in statischen und globalen Variablen werden Referenzen in nicht-statischen lokalen Variablen oder im Ausdrucksauswertungsstapel nicht automatisch freigegeben, sobald das Programm beendet wird. Solche Referenzen werden nur freigegeben, wenn die Funktion oder der Ausdruck regulär beendet werden kann.</li>
</ul>
<p>Obwohl das Betriebssystem den vom Objekt benutzten Speicher zurückfordert, sobald das Programm beendet wird, kann <a href="#Custom_NewDelete">__Delete</a> erst aufgerufen werden, wenn alle Referenzen zum Objekt freigegeben worden sind. Das kann wichtig sein, wenn andere Ressourcen freigegeben werden, die nicht automatisch vom Betriebssystem zurückgefordert werden, wie zum Beispiel temporäre Dateien.</p>

<h3 id="ObjPtr">Objekt-Pointer</h3>
<p>In einigen seltenen Fällen ist es eventuell erforderlich, dass ein Objekt via DllCall an einen externen Code übergeben werden muss, oder dass ein Objekt in eine binäre Datenstruktur gespeichert werden muss, damit es später abgerufen werden kann. Die Adresse eines Objekts kann via <code>Adresse := ObjPtr(meinObjekt)</code> abgerufen werden; dies würde allerdings effektiv zwei Referenzen zum Objekt erzeugen, während das Programm selbst nur die eine Referenz in <em>meinObjekt</em> kennt. Das Objekt wird gelöscht, sobald die letzte <em>bekannte</em> Referenz zum Objekt freigegeben wird. Demzufolge muss das Skript das Objekt darüber informieren, dass es eine Referenz erhalten hat. Dies kann man wie folgt erreichen (die folgenden zwei Zeilen sind äquivalent):</p>
<pre>
ObjAddRef(Adresse := ObjPtr(meinObjekt))
Adresse := ObjPtrAddRef(meinObjekt)
</pre>
<p>Außerdem muss das Objekt informiert werden, wenn das Skript mit dieser Referenz fertig ist:</p>
<pre>ObjRelease(Adresse)</pre>
<p>Generell sollte jede neue Kopie einer Objektadresse als separate Referenz zum Objekt behandelt werden, demzufolge sollte das Skript ObjAddRef aufrufen, wenn es eine Kopie erhält, und sofort ObjRelease aufrufen, bevor es eine verliert. Zum Beispiel sollte immer ObjAddRef aufgerufen werden, wenn eine Adresse mit so etwas wie <code>x := Adresse</code> kopiert wird. Ebenso sollte das Skript ObjRelease aufrufen, wenn es mit <em>x</em> fertig ist (oder dabei ist den Wert von <em>x</em> zu überschreiben).</p>
<p id="ObjFromPtr">Mit der ObjFromPtr-Funktion kann eine Adresse in eine geeignete Referenz umgewandelt werden:</p>
<pre>meinObjekt := ObjFromPtr(Adresse)</pre>
<p>ObjFromPtr geht davon aus, dass <em>Adresse</em> eine gezählte Referenz ist, und nimmt sie in Besitz. Mit anderen Worten: <code>meinObjekt := ""</code> würde bewirken, dass die Referenz, ursprünglich repräsentiert von <em>Adresse</em>, freigegeben wird. Danach muss <em>Adresse</em> als ungültig betrachtet werden. Um stattdessen eine neue Referenz zu erstellen, verwenden Sie eine der folgenden Möglichkeiten:</p>
<pre>
ObjAddRef(Adresse), meinObjekt := ObjFromPtr(Adresse)
meinObjekt := ObjFromPtrAddRef(Adresse)
</pre>

</body>
</html>
