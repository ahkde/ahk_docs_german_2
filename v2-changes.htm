<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Änderungen zwischen v1.1 und v2.0 | AutoHotkey v2</title>
<meta name="description" content="Änderungen zwischen v1.1 und v2.0." />
<meta name="ahk:equiv-v1" content="AHKL_ChangeLog.htm" />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="robots" content="noindex, nofollow">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
<script src="static/ga4.js" type="text/javascript"></script>
</head>
<body>
<h1>Änderungen von v1.1 bis v2.0</h1>

<h2 id="language">Sprache</h2>
<h3 id="legacy-syntax-removed">Altmodische Syntax entfernt</h3>
<p>Direkt geschriebene Zuweisungen entfernt:  <code>Var = Wert</code></p>
<p>Alle altmodischen If-Anweisungen entfernt, so dass nur <code>if Ausdruck</code> übrig bleibt, welches nie Klammern erfordert (aber sie erlaubt, wie bei jedem Ausdruck).</p>
<p>Die "Befehlssyntax" wurde entfernt. Es gibt keine "Befehle" mehr, sondern nur noch <a href="Language.htm#function-call-statements"><em>Funktionsaufrufanweisungen</em></a> - das sind nichts anderes als Funktions- oder Methodenaufrufe ohne runde Klammern. Das bedeutet:</p>
<ul>
<li>Alle ehemaligen Befehle sind jetzt Funktionen (außer Kontrollanweisungen).</li>
<li>Alle Funktionen können ohne runde Klammern aufgerufen werden, wenn der Rückgabewert nicht benötigt wird (aber nach wie vor können die runden Klammern bei Aufrufen innerhalb eines Ausdrucks nicht weggelassen werden).</li>
<li>Alle Parameter sind Ausdrücke, demzufolge muss direkt geschriebener Text in Anführungszeichen gesetzt und nie mit Escapezeichen versehen werden. Gegenwärtig sind einige wenige Direktiven (die weder Befehle noch Funktionen sind) davon ausgenommen.</li>
<li>Parameter sind dieselben, unabhängig von runden Klammern; soll heißen, wenn es für den Rückgabewert keine Ausgabevariable gibt, wird der Rückgabewert beim Weglassen der runden Klammern verworfen.</li>
<li>Normale Variablenreferenzen werden nie mit Prozentzeichen umschlossen (außer bei <a href="commands/_Include.htm">#Include</a> und <a href="commands/_DllLoad.htm">#DllLoad</a>). Benutzen Sie <a href="Variables.htm#concat">Verkettung</a> oder <a href="commands/Format.htm">Format</a>, um Variablen in einen Text einzufügen.</li>
<li>Es gibt kein Komma zwischen dem Funktionsnamen und Parameter; zum Beispiel wäre <code>MouseGetPos(, y)</code> das gleiche wie <code>MouseGetPos , y</code> (x wird weggelassen). Ein Leer- oder Tabulatorzeichen ist erforderlich, um es verständlich zu machen. Um Konsistenz zu bewahren, folgen auch Direktiven der neuen Konvention (es darf kein Komma zwischen dem Namen der Direktive und dem Parameter stehen).</li>
<li>Ein Prozentzeichen als Präfix ist nicht mehr notwendig, um ein Ausdruck zu erzwingen. Anführungszeichenlose Prozentzeichen in Ausdrücken werden nur für Doppelderefenzierungen/dynamische Referenzen verwendet und bei einer ungeraden Anzahl wird ein Syntaxfehler gemeldet.</li>
<li>Methodenaufrufsanweisungen (Methodenaufrufe ohne runde Klammern) sind auf eine reine Variable, gefolgt von einem oder mehreren via Punkte getrennte Identifikatoren, beschränkt, z. B. <code>MeineVar.MeineEigenschaft.MeineMethode "Zeichenkette zum Übergeben"</code>.</li>
</ul>
<p>Die Umwandlung von v1-Befehlen zu Funktionen geschieht in der Regel wie folgt (aber einige Funktionen wurden geändert, wie weiter unten dokumentiert):</p>
<ul>
<li>Wenn der erste Parameter des Befehls eine Ausgabevariable ist und der zweite Parameter nicht, wird der erste Parameter zum Rückgabewert gemacht und aus der Parameterliste entfernt.</li>
<li>Die übrigen Ausgabevariablen werden wie <a href="#byref">ByRef-Parameter</a> behandelt (für die sich die Verwendung und Syntax geändert hat), aber mit dem Unterschied, dass sie Referenzen erlauben, die auf beschreibbare interne Variablen verweisen.</li>
<li>Es wird bei Misserfolg eine Ausnahme ausgelöst, anstatt ErrorLevel zu setzen.</li>
<li>Werte, die früher via ErrorLevel zurückgegeben wurden, werden auf andere Weise zurückgegeben, wurden mit Ausnahmen ersetzt, von etwas anderem abgelöst oder werden einfach nicht zurückgegeben.</li>
</ul>
<p>Alle Kontrollanweisungen akzeptieren auch Ausdrücke, außer wo unten angegeben.</p>
<p>Alle Kontrollanweisungen, die Parameter akzeptieren (außer Zwei-Wort-Loop-Anweisungen), unterstützen runde Klammern um ihre Parameterliste, ohne Leerzeichen zwischen dem Namen und der Klammer. Zum Beispiel <code>return(var)</code>. Allerdings sind das keine Funktionen; zum Beispiel wäre <code>x := return(y)</code> ungültig. <a href="commands/If.htm">If</a> und <a href="commands/While.htm">While</a> unterstützen diese Schreibweise bereits.</p>
<p>Nach <a href="#loop-sub-commands">Loop</a> (außer <a href="commands/Loop.htm">Loop <em>Anzahl</em></a>) erfolgt nun ein sekundäres Schlüsselwort (Files, Parse, Read oder Reg), das weder in Anführungszeichen gesetzt noch über eine Variable angegeben werden darf. Derzeit ist nach dem Schlüsselwort ein Komma möglich, aber nicht zwingend erforderlich, da es kein Parameter ist. OTB wird bei allen Varianten unterstützt.</p>
<p><a href="commands/Goto.htm">Goto</a>, <a href="commands/Break.htm">Break</a> und <a href="commands/Continue.htm">Continue</a> benötigen einen anführungszeichenlosen Labelnamen, äquivalent zu v1 (<code>Goto Label</code> springt zu <code>Label:</code>). Um ein Label dynamisch anzuspringen, verwenden Sie runde Klammern direkt nach dem Namen: <code>Goto(Ausdruck)</code>. Allerdings ist dies keine Funktion und kann deshalb nicht inmitten eines Ausdrucks benutzt werden. Es können runde Klammern bei Break oder Continue verwendet werden, aber in diesem Fall muss der Parameter eine einzelne direkt geschriebene Zahl oder eine in Anführungszeichen gesetzte Zeichenkette sein.</p>
<p>Gosub wurde entfernt, außerdem können Labels nicht mehr mit Funktionen wie <a href="commands/SetTimer.htm">SetTimer</a> und <a href="commands/Hotkey.htm">Hotkey</a> verwendet werden.</p>
<ul>
<li>Sie waren redundant; im Grunde nur eine begrenzte Variante einer Funktion, ohne lokale Variablen oder einen Rückgabewert, und ohne einen eigenen, separaten Namensraum. Funktionen können überall dort verwendet werden, wo zuvor Label-Subroutinen verwendet wurden (sogar <a href="Functions.htm#nested">innerhalb anderer Funktionen</a>).</li>
<li>Funktionen können sich nicht überlappen (können aber innerhalb einer anderen Funktion enthalten sein). Verwenden Sie stattdessen mehrere Funktionen und rufen Sie eine nach der anderen auf. Anstelle von A_ThisLabel können Sie Funktionsparameter verwenden.</li>
<li>Im Gegensatz zu Subroutinen wird man, wenn man vergisst, das <em>Ende</em> einer Funktion zu definieren, normalerweise auf den Fehler hingewiesen, da jedes <code>{</code> ein entsprechendes <code>}</code> haben muss. Die Grenzen einer Funktion dürften auch leichter zu erkennen sein als die einer Label-Subroutine.</li>
<li>Funktionen können in den automatischen Ausführungsbereich platziert werden, ohne diesen zu unterbrechen. Der automatische Ausführungsbereich kann sich nun problemlos über das gesamte Skript erstrecken, daher kann dieser stattdessen als <a href="Language.htm#global-code">globaler Code</a> bezeichnet werden, der innerhalb des <a href="Scripts.htm#auto">Auto-Execute-Threads</a> ausgeführt wird.</li>
<li>Funktionen könnten etwas weniger anfällig dafür sein, als "Goto" missbraucht zu werden (wo ein Benutzer die aktuelle Subroutine sich selbst ausführen lässt, um eine Schleife zu erzeugen, was zwangsläufig dazu führt, dass der Stack-Platz erschöpft und das Programm beendet wird).</li>
<li>Es gibt weniger Mehrdeutigkeit, wenn Funktionen (wie <a href="commands/Hotkey.htm">Hotkey</a>) nicht mehr sowohl ein Label als auch eine Funktion akzeptieren, die beide den gleichen Namen haben können.</li>
<li>Bei allen übrigen Verwendungsarten von Labels ist es nicht zulässig, vom Inneren einer Funktion aus auf ein globales Label zu verweisen. Daher kann die Suche nach Labels auf die lokale Label-Liste beschränkt werden. Es besteht daher keine Notwendigkeit, die Gültigkeit von Sprüngen aus dem Inneren einer Funktion zu überprüfen (die sowieso nie unterstützt wurden).</li>
</ul>
<h3 id="hotkey-and-hotstring-labels">Hotkey- und Hotstring-Labels</h3>
<p><a href="Hotkeys.htm">Hotkeys</a> und nicht-automatisch-ersetzende <a href="Hotstrings.htm">Hotstrings</a> sind keine Labels mehr; stattdessen definieren sie (automatisch) eine Funktion. Verwenden Sie bei einem mehrzeiligen Hotkey geschweifte Klammern, um sein Körper zu umschließen, anstatt sein Ende via <code>Return</code> zu kennzeichnen (was mit der geschweiften Endklammer impliziert wird). Um einen Hotkey explizit aufrufen zu lassen, geben Sie <code>FunkName(ThisHotkey)</code> zwischen <code>::</code> und <code>{</code> an - dies ist auch in v1.1.20+ möglich, aber jetzt gibt es einen Parameter. Wenn die Funktionsdefinition nicht explizit ist, wird der Parameter ThisHotkey genannt.</p>
<p><strong>Hinweis:</strong> Hotkey-Funktionen sind standardmäßig <a href="Functions.htm#AssumeLocal">Assume-Local</a>-Funktionen und können daher nicht ohne Deklaration <a href="Functions.htm#Global">globalen Variablen</a> etwas zuweisen.</p>
<h3 id="names">Namen</h3>
<p>Funktions- und Variablennamen werden jetzt in einem gemeinsamen Namensraum untergebracht.</p>
<ul>
<li>Jede Funktionsdefinition erstellt eine Konstante (schreibgeschützte Variable) innerhalb des aktuellen Gültigkeitsbereichs.</li>
<li>Verwenden Sie <code>MeineFunk</code> anstelle von <code>Func("MeineFunk")</code>.</li>
<li>Verwenden Sie <code>MeineFunk</code> anstelle von <code>"MeineFunk"</code>, wenn Sie die Funktion an eine interne Funktion wie <a href="commands/SetTimer.htm">SetTimer</a> oder <a href="commands/Hotkey.htm">Hotkey</a> übergeben möchten. Die Übergabe eines Namens (Zeichenkette) wird nicht mehr unterstützt.</li>
<li>Verwenden Sie <code>meineVar()</code> anstelle von <code>%meineVar%()</code>, wenn Sie eine Funktion per Wert aufrufen möchten.</li>
<li>Um eine Funktion aufzurufen, von der Sie nur einen Funktionsnamen (Zeichenkette) haben, verwenden Sie zunächst eine <a href="Variables.htm#deref">Doppelderefenzierung</a>, um den Namen in eine Variable aufzulösen und deren Wert (das Funktionsobjekt) abzurufen. <code>%meineVar%()</code> führt nun tatsächlich eine Doppelderefenzierung durch und ruft dann das Ergebnis auf, äquivalent zu <code>f := %meineVar%, f()</code>. Vermeiden Sie nach Möglichkeit die Adressierung von Funktionen über ihren Namen (Zeichenkette); verwenden Sie stattdessen Referenzen.</li>
</ul>
<p>Namen können nicht mehr mit einer Zahl beginnen und dürfen keines der folgenden Zeichen, die vorher erlaubt waren, enthalten: <code>@ # $</code>. Nur Buchstaben, Zahlen, Unterstriche und ASCII-fremde Zeichen sind erlaubt.</p>
<p><strong>Reservierte Wörter:</strong> Deklarationsschlüsselwörter und Namen von Kontrollanweisungen können nicht als Variablen-, Funktions- oder Klassennamen verwendet werden. Dazu gehören <code class="no-highlight">local</code>, <code class="no-highlight">global</code>, <code class="no-highlight">static</code>, <code class="no-highlight">if</code>, <code class="no-highlight">else</code>, <code class="no-highlight">loop</code>, <code class="no-highlight">for</code>, <code class="no-highlight">while</code>, <code class="no-highlight">until</code>, <code class="no-highlight">break</code>, <code class="no-highlight">continue</code>, <code class="no-highlight">goto</code>, <code class="no-highlight">return</code>, <code class="no-highlight">switch</code>, <code class="no-highlight">case</code>, <code class="no-highlight">try</code>, <code class="no-highlight">catch</code>, <code class="no-highlight">finally</code> und <code class="no-highlight">throw</code>. Dies dient in erster Linie dazu, Fehler zu erkennen, wie z. B. <code>if (ex) break</code>.</p>
<p><strong>Reservierte Wörter:</strong> <code class="no-highlight">as</code>, <code class="no-highlight">and</code>, <code class="no-highlight">contains</code>, <code class="no-highlight">false</code>, <code class="no-highlight">in</code>, <code class="no-highlight">is</code>, <code class="no-highlight">IsSet</code>, <code class="no-highlight">not</code>, <code class="no-highlight">or</code>, <code class="no-highlight">super</code>, <code class="no-highlight">true</code>, <code class="no-highlight">unset</code>. Diese Wörter sind für zukünftige Anwendungen oder andere spezifische Zwecke reserviert, und sind als Variablen- oder Funktionsnamen nicht zulässig, auch wenn sie eindeutig sein sollten. Dies dient in erster Linie der Konsistenz - in v1 war <code>and := 1</code> auf einer eigenen Zeile erlaubt, aber <code>(and := 1)</code> hätte nicht funktioniert.</p>
<p>Die oben aufgelisteten Wörter können zum Benennen von Eigenschaften oder Fenstergruppen genutzt werden. Typisch verwendete Eigenschaftsnamen haben einen <code>.</code> davor, was die Interpretation des Wortes als Operator verhindert. Schlüsselwörter hingegen werden nie als Variablen- oder Funktionsnamen innerhalb eines Ausdrucks interpretiert. <code>not(x)</code> beispielsweise ist äquivalent zu <code>not (x)</code> oder <code>(not x)</code>.</p>
<p>Eine Reihe von Klassen sind vordefiniert, so dass diese globalen Variablennamen auf die gleiche Weise wie bei einer benutzerdefinierten Klasse reserviert sind. (Allerdings werden die meisten Probleme, die sich daraus ergeben, durch die unten beschriebenen <a href="#scope">Änderungen am Gültigkeitsbereich</a> entschärft.) Eine Liste der Klassen finden Sie unter <a href="objects/index.htm">Interne Klassen</a>.</p>
<h3 id="scope">Gültigkeitsbereich</h3>
<p><em>Superglobale</em> Variablen wurden entfernt (außer interne Variablen, die nicht ganz dasselbe sind, da sie weder neu deklariert noch überschattet werden können).</p>
<p>Wenn innerhalb einer <a href="Functions.htm#AssumeLocal">Assume-Local</a>-Funktion ein bestimmter Name nicht in einer Deklaration oder als Ziel einer nicht-dynamischen Zuweisung oder des <a href="Variables.htm#ref">Referenz-Operators (&amp;)</a> verwendet wird, kann er in eine bestehende globale Variable aufgelöst werden.</p>
<p>Mit anderen Worten:</p>
<ul>
<li>Funktionen können jetzt globale Variablen lesen, ohne dass sie deklariert werden müssen.</li>
<li>Funktionen, die keine globalen Deklarationen (<code>global</code>) haben, können globale Variablen nicht direkt verändern (dadurch wird eine Quelle für unbeabsichtigte Seiteneffekte eliminiert).</li>
<li>Das Hinzufügen einer neuen Klasse (<code>class</code>) dürfte weit weniger Auswirkungen auf das Verhalten einer bestehenden Funktion haben, da Klassen nicht superglobal sind.</li>
<li>Das Schlüsselwort <code>global</code> ist derzeit redundant, wenn es im globalen Bereich verwendet wird, kann aber zwecks Übersicht noch angegeben werden. Variablen, die auf diese Weise deklariert werden, sind jetzt viel weniger anfällig für Konflikte mit lokalen Variablen (z. B. beim Kombinieren von Skripten auf manuelle Weise oder mit <a href="commands/_Include.htm">#Include</a>), da sie nicht superglobal sind. Auf der anderen Seite geht ein gewisser Komfort verloren.</li>
<li>Deklarationen werden im Allgemeinen nicht so oft benötigt.</li>
</ul>
<p>Der <em>Force-Local</em>-Modus wurde entfernt.</p>
<h3 id="variables">Variablen</h3>
<p>Lokale <a href="Functions.htm#static">statische</a> Variablen werden initialisiert, wenn und sobald sie von der Ausführung erreicht werden, anstatt in linearer Reihenfolge ausgeführt zu werden, bevor der automatische Ausführungsbereich beginnt. Jeder Initialisierer, der beim zweiten Mal erreicht wird, hat keinen Effekt mehr. Mehrere Deklarationen sind zulässig und können für dieselbe Variable zu unterschiedlichen Zeiten ausgeführt werden. Die Vorteile sind vielfältig:</p>
<ul>
<li>Wenn ein statischer Initialisierer andere Funktionen mit statischen Variablen aufruft, besteht ein geringeres Risiko, dass Initialisierer aufgrund der Reihenfolge der Funktionsdefinitionen noch nicht ausgeführt wurden.</li>
<li>Da die Funktion aufgerufen wurde, stehen Parameter, <a href="Variables.htm#ThisFunc">A_ThisFunc</a> und Closures zur Verfügung (vorher waren sie es nicht).</li>
<li>Eine statische Variable kann bedingungsabhängig initialisiert werden; dies erhöht die Flexibilität, während sie dennoch nur einmal ausgeführt wird, ohne dass <code>if IsSet()</code> erforderlich ist.</li>
<li>Da es für eine einzelne statische Variable mehrere Initialisierer geben kann, sind Verbundzuweisungen wie <code>static x += 1</code> zulässig. (Diese Änderung reduzierte die Codegröße nur geringfügig, da es bereits bei <code>local</code> und <code>global</code> erlaubt war.)</li>
</ul>
<p class="note"><strong>Hinweis:</strong> <code>static init := MeineFunk()</code> kann nicht mehr verwendet werden, um <em>MeineFunk</em> automatisch auszuführen. Da man nun auf Label-und-Return-Subroutinen verzichten kann, kann der automatische Ausführungsbereich das gesamte Skript umfassen.</p>
<p>Das Deklarieren einer Variable mit <code>local</code> macht die Funktion nicht mehr <a href="Functions.htm#AssumeGlobal">assume-global</a>.</p>
<p><a href="Variables.htm#deref">Doppeldereferenzierungen</a> sind nun konsistenter mit Variablen, die beim Laden des Skripts aufgelöst werden, und können keine neuen Variablen mehr erzeugen. Dadurch werden einige Inkonsistenzen und häufige Anlässe zu Verwirrung vermieden.</p>
<p>Doppeldereferenzierungen, die aus irgendeinem Grund fehlschlagen, lösen jetzt einen Fehler aus. Früher wurden bei ungültigen Namen stillschweigend eine leere Zeichenkette erzeugt, während bei anderen Fällen eine leere Variable erstellt und zurückgegeben wurde.</p>
<h3 id="expressions">Ausdrücke (Expressions)</h3>
<p>Direkt geschriebene Zeichenketten können in <code>"doppelten"</code> oder <code>'einfachen'</code> Anführungszeichen gesetzt werden, die untereinander nicht austauschbar sind. Direkt geschriebene Anführungszeichen müssen mit einem Escapezeichen versehen werden - <code>`"</code> oder <code>`'</code> - oder mit dem gegenteiligen Anführungszeichen ersetzt werden:  <code>'"42" ist die Antwort'</code>. Doppelte Anführungszeichen haben keine besondere Bedeutung, und lösen einen Fehler aus, weil sie als Auto-Verkettung ein Leerzeichen benötigen.</p>
<p>Die Operatoren <code>&amp;&amp;</code>, <code>||</code>, <code>and</code> und <code>or</code> geben den gewinnenden Wert zurück, ähnlich wie JavaScript und Lua. Zum Beispiel wäre der Rückgabewert von <code>"" or "default"</code> gleich <code>"default"</code> statt <code>1</code>. Skripte, die einen reinen logischen Rückgabewert (0 oder 1) benötigen, können so etwas wie <code>!!(x or y)</code> oder <code>(x or y) ? 1 : 0</code> verwenden.</p>
<p>Auto-Verkettungen benötigen nun mindestens ein Leer- oder Tabulatorzeichen (die v1-Dokumentation sagte, da "sollte" ein Leerzeichen sein).</p>
<p>Das Ergebnis eines Mehrfachanweisungsausdrucks wie <code>x(), y()</code> ist der letzte (ganz rechts befindliche) Teilausdruck, anstatt der erste (ganz links). In v1 als auch v2 werden Teilausdrücke von links nach rechts ausgewertet.</p>
<p>Gleichheitszeichen nach einem Komma sind nicht länger Zuweisungen: <code>y=z</code> in <code>x:=y, y=z</code> wäre nicht eine Zuweisung, sondern ein wirkungsloser Vergleich.</p>
<p><code>:= += -= *= /= ++ --</code> haben konsistentes Verhalten, egal ob sie einzeln oder in Kombination mit anderen Operatoren, wie z. B. <code>x := y, y += 2</code>, benutzt werden. Früher gab es Verhaltensunterschiede, wenn ein Fehler innerhalb des Ausdrucks auftrat oder ein leerer Wert in einer mathematischen Operation verwendet wurde.</p>
<p><code>!=</code> ist nun wie <code>=</code> immer nicht-Groß-/Kleinschreibung-sensitiv, während <code>!==</code> als Counterpart von <code>==</code> hinzugefügt wurde.</p>
<p><code>&lt;&gt;</code> wurde entfernt.</p>
<p><code>//</code> löst nun eine Ausnahme aus, wenn einer der Eingabewerte eine Floating-Point-Zahl ist. Davor waren die Ergebnisse zwischen negativen Floating-Point-Zahlen und negativen Integern inkonsistent.</p>
<p><code>|</code>, <code>^</code>, <code>&amp;</code>, <code>&lt;&lt;</code> und <code>&gt;&gt;</code> lösen nun eine Ausnahme aus, wenn einer ihrer Eingabewerte eine Floating-Point-Zahl ist, anstatt das Ergebnis zu einem Integer zu kürzen.</p>
<p>Die wissenschaftliche Schreibweise kann ohne Dezimalpunkt erfolgen (aber erzeugt immer eine Floating-Point-Zahl). Die wissenschaftliche Schreibweise wird auch unterstützt, wenn numerische Zeichenketten in Integer-Zahlen umgewandelt werden (z. B. wird "1e3" als 1000 statt als 1 interpretiert).</p>
<p>Funktionsaufrufe erlauben jetzt praktisch jeden Teilausdruck, um anzugeben, welche Funktion aufgerufen werden soll, vorausgesetzt, es steht kein Leer- oder Tabulatorzeichen vor der runden Startklammer der Parameterliste. <code>MeineFunk()</code> beispielsweise würde den Wert <code>MeineFunk</code> aufrufen, egal ob das der Name einer Funktion oder eine Variable ist, die ein Funktionsobjekt enthält, und <code>(a?b:c)()</code> würde je nach <code>a</code> entweder <code>b</code> oder <code>c</code> aufrufen. Beachten Sie, dass <code>x.y()</code> immer noch ein Methodenaufruf ist, ähnlich zu <code>(x.y)(x)</code>, aber <code>a[i]()</code> ist jetzt äquivalent zu <code>(a[i])()</code>.</p>
<p>Doppeldereferenzierungen erlauben nun fast jeden Ausdruck (nicht nur Variablen) als Quelle für den Variablennamen. Zum Beispiel sind <code>DoNotUseArray%n+1%</code> und <code>%(%triple%)%</code> gültig. Die Syntax zur doppelten Dereferenzierung wird jetzt auch für die Dereferenzierung von VarRefs, wie z. B. <code>ref := &amp;var, value := %ref%</code>, verwendet.</p>
<p>Die Ausdrücke <code>funkName[""]()</code> und <code>funkName.()</code> rufen nicht länger eine Funktion via Name auf. Das Weglassen des Methodennamens wie in <code>.()</code> verursacht nun eine Fehlermeldung beim Laden des Skripts. Funktionen sollten per Referenz aufgerufen oder adressiert werden, nicht per Name.</p>
<p><code>var :=</code> ohne R-Wert löst einen Ladezeitfehler aus. In v1 war dies äquivalent zu <code>var := ""</code>, was aber in Kombination mit einem anderen Ausdruck stillschweigend fehlschlug - zum Beispiel: <code>x :=, y :=</code>.</p>
<p>Direkt geschriebene Zeichenketten, gefolgt von einem mehrdeutigen einstelligen/zweistelligen Operator, lösen einen Ladezeitfehler aus. <code>"new Zähler:" ++Zähler</code> beispielsweise soll eigentlich <code>Zähler</code> um 1 erhöhen und anschließend anzeigen, aber technisch gesehen ist das eine ungültige <em>Addition</em> und ein <em>unäres Plus</em>.</p>
<p><code>Wort ++</code> und <code>Wort --</code> sind nicht länger Ausdrücke, da <code>Wort</code> eine benutzerdefinierte Funktion sein kann (und nach ++/- kann ein Ausdruck folgen, der eine Variablenreferenz erzeugt). Um einen alleinstehenden Post-Inkrement- oder Post-Dekrement-Ausdruck zu schreiben, muss man entweder das Leerzeichen zwischen Variable und Operator weglassen, oder die Variable oder den Ausdruck in Klammern setzen.</p>
<p><code>Wort ? x : y</code> ist immer noch ein ternärer Ausdruck, allerdings werden bei komplexeren Fällen, die mit einem Wort beginnen, z. B. <code>Wort1 Wort2 ? x : y</code>, das <em>Wort1</em> immer als Funktionsaufruf interpretiert (selbst wenn so eine Funktion nicht existiert). Um einen alleinstehenden ternären Ausdruck mit einer komplexen Bedingung zu schreiben, umschließen Sie die Bedingung mit runden Klammern.</p>
<p>Mit dem neuen <a href="Variables.htm#is"><code>is</code>-Operator</a> wie in <code>x is y</code> kann geprüft werden, ob der Wert <em>x</em> eine Instanz der Klasse <em>y</em> ist, wobei <em>y</em> ein Objekt mit einer <code>prototype</code>-Eigenschaft (also eine Klasse) sein muss. Dies schließt primitive Werte ein, wie in <code>x is Integer</code> (was eine reine Typenprüfung ist, während <code>IsInteger(x)</code> auf eine mögliche Konvertierung prüft).</p>
<p>Die Schlüsselwörter <code>contains</code> und <code>in</code> sind für die zukünftige Verwendung reserviert.</p>
<p><code>&amp;var</code> (Adressoperator) wurde mit <code>StrPtr(var)</code> und <code>ObjPtr(obj)</code> ersetzt, um die Intention zu verdeutlichen und die Fehlerprüfung zu verbessern. In v1 gab der Adressoperator die Adresse des internen Zeichenkettenpuffers von <em>var</em> zurück, auch dann, wenn dieser eine Zahl (aber kein Objekt) enthielt. Der Operator wurde auch verwendet, um die Adresse eines Objekts abzurufen. Das Abrufen einer Adresse vom falschen Typ kann schlimme Folgen haben.</p>
<p><code>&amp;var</code> ist jetzt der <a href="Variables.htm#ref">Referenzoperator</a>, der für alle <a href="#byref">ByRef</a>- und AusgabeVar-Parametern verwendet wird, um die Übersichtlichkeit und Flexibilität zu verbessern (und andere Sprachänderungen zu ermöglichen). Weitere Informationen finden Sie unter <a href="Concepts.htm#variable-references">Variablenreferenzen (VarRef)</a>.</p>
<p>Die Länge der Zeichenkette wird nun während der Ausdrucksauswertung im Cache zwischengespeichert. Dies erhöht die Leistung und ermöglicht, dass Zeichenketten eine binäre Null enthalten dürfen. Genauer gesagt:</p>
<ul>
<li>Wenn man zwei Zeichenketten, die binäre Nullen enthalten, verkettet, werden die Daten nicht länger gekürzt.</li>
<li>Mit den Groß-/Kleinschreibung-sensitiven Gleichheitsoperatoren (<code>==</code> und <code>!==</code>) können binäre Daten verglichen werden. Die anderen Vergleichsoperatoren können nur bis zur ersten binären Null "sehen".</li>
<li>Binäre Daten können von Funktionen zurückgegeben und in Objekten gespeichert werden.</li>
</ul>
<p>Die meisten Funktionen erwarten immer noch null-terminierte Zeichenketten; das heißt, dass sie nur bis zur ersten binären Null "sehen" können. Zum Beispiel würde <a href="commands/MsgBox.htm">MsgBox</a> nur den Teil der Zeichenkette vor der ersten binären Null anzeigen.</p>
<p>Der <code>*</code>-Operator (Dereferenz) wurde entfernt. Verwenden Sie stattdessen <a href="commands/NumGet.htm">NumGet</a>.</p>
<p>Der <code>~</code>-Operator (<a href="Variables.htm#unary">bitweises NICHT</a>) behandelt seinen Eingabewert nun immer als 64-Bit-Integer; er behandelt Werte zwischen 0 und 4294967295 nicht mehr als vorzeichenlose 32-Bit-Integer.</p>
<p><code>&gt;&gt;&gt;</code> und <code>&gt;&gt;&gt;=</code> wurden für die logische bitweise Verschiebung nach rechts hinzugefügt.</p>
<p><a href="Variables.htm#fat-arrow">Fat-Arrow-Funktionen</a> hinzugefügt. Der Ausdruck <code>Fn(Parameter) =&gt; Ausdruck</code> definiert eine Funktion namens <em>Fn</em> (was weggelassen werden kann) und gibt ein <a href="objects/Func.htm">Func</a>- oder Closure-Objekt zurück. Wenn dieser Ausdruck aufgerufen wird, wird die Funktion <em>Ausdruck</em> auswerten und das Ergebnis zurückgeben. Wenn dieser Ausdruck in einer anderen Funktion ist, kann <em>Ausdruck</em> auf die Variablen der äußeren Funktion zugreifen (dies kann auch mit einer normalen Funktionsdefinition erfolgen).</p>
<p>Die Fat-Arrow-Syntax kann auch genutzt werden, um Methoden und Eigenschaft-Getter/Setter zu definieren (in diesem Fall ist die Methoden-/Eigenschaftsdefinition selbst kein Ausdruck; ihr Körper gibt einfach nur einen Ausdruck zurück).</p>
<p>Direkt geschriebene Zahlen werden nun auf der linken Seite des Objektelementzugriffs (Punkt) vollständig unterstützt. <code>0.1</code> beispielsweise ist eine Zahl, aber <code>0.min</code> und <code>0.1.min</code> greifen auf die <em>min</em>-Eigenschaft zu, die von einem Basisobjekt behandelt werden kann (siehe <a href="Objects.htm#primitive">Primitive Werte</a>). <code>1..2</code> oder <code>1.0.2</code> ist die Zahl 1.0, gefolgt von der Eigenschaft 2. Dies könnte z. B. für Maßeinheiten, direkt geschriebenen Versionsnummern oder Zahlenbereichen verwendet werden.</p>
<p><code>x**y</code>: Wenn <code>x</code> und <code>y</code> Integer sind und <code>y</code> positiv ist, liefert der Potenzoperator jetzt korrekte Ergebnisse für alle Eingabewerte, sofern im gültigen Bereich, wo vorher aufgrund der internen Floating-Point-Berechnung eine gewisse Genauigkeit verloren ging. Verhalten bei Überschreitung ist undefiniert.</p>
<h3 id="objects-misc">Objekte (Sonstiges)</h3>
<p>Siehe auch: <a href="#objects">Objekte</a></p>
<p>Der Zugriff auf Eigenschaften via <code>.</code> und der Zugriff auf Daten via <code>[]</code> (Elemente, Array- oder Map-Elemente) werden nun getrennt voneinander behandelt. <code>dictionary["Count"]</code> beispielsweise kann die Definition von "Count" zurückgeben, während <code>dictionary.Count</code> die Anzahl der darin enthaltenen Wörter zurückgibt. Benutzerdefinierte Objekte können dies durch Definieren einer <a href="Objects.htm#__Item">__Item-Eigenschaft</a> nutzen.</p>
<p>Wenn der Name einer Eigenschaft oder Methode nicht im Voraus bekannt ist, kann (und muss) der Zugriff auf diese via Prozentzeichen erfolgen. <code>obj.%varname%()</code> beispielsweise ist das v2-Äquivalent zu <code>obj[varname]()</code>. Die Verwendung von <code>[]</code> ist für Daten (z. B. Array-Elemente) reserviert.</p>
<p>Die direkte Schreibweise zum Konstruieren eines Ad-Hoc-Objekts ist nach wie vor <code>{Name: Wert}</code>, aber da reine Objekte jetzt nur noch "Eigenschaften" und keine "Array-Elemente" mehr haben, wurden die Regeln leicht abgeändert, um konsistent mit der Art und Weise zu sein, wie alle anderen Zugriffe auf Eigenschaften erfolgen:</p>
<ul>
<li><code>o := {a: b}</code> verwendet wie zuvor den Namen "a".</li>
<li><code>o := {%a%: b}</code> verwendet den Eigenschaftsnamen in <code>a</code>, anstatt diesen als Variablennamen zu nehmen, eine Doppeldereferenzierung durchzuführen und den Inhalt der resultierenden Variable zu verwenden. Mit anderen Worten hat es denselben Effekt wie <code>o := {}, o.%a% := b</code>.</li>
<li>Jeder andere Ausdruckstyp links von <code>:</code> ist unzulässig. Zum Beispiel <code>{(a): b}</code> oder <code>{ein Fehler: 1}</code>.</li>
</ul>
<p>Die Verwendung des Wortes "base" in <code>base.Methode()</code> wurde mit <a href="Objects.htm#Custom_Classes_super">super</a> ersetzt (<code>super.Methode()</code>), um die beiden Konzepte besser zu unterscheiden:</p>
<ul>
<li><code>super.</code> oder <code>super[</code> ruft die Superklassenversion einer Methode/Eigenschaft auf, wobei "Superklasse" die Basis des Prototypobjekts ist, das ursprünglich zur Definition der aktuellen Funktion gehörte.</li>
<li><code>super</code> ist ein reserviertes Wort; der Versuch, es ohne das Suffix <code>.</code> oder <code>[</code> oder <code>(</code> oder außerhalb einer Klasse zu verwenden, führt zu einem Ladezeitfehler.</li>
<li><code>base</code> ist eine vordefinierte Eigenschaft, die das unmittelbare Basisobjekt des Objekts abruft oder setzt (wie <a href="objects/Any.htm#GetBase">ObjGetBase</a>/<a href="objects/Object.htm#SetBase">ObjSetBase</a>). Es ist nur ein normaler, nicht reservierter Eigenschaftsname.</li>
<li>Der Aufruf von <code>super.x</code> löst, wenn die Superklasse keine Definition von x hat, einen Fehler aus, während <code>base.x</code> früher ignoriert wurde (auch wenn es eine Zuweisung war).</li>
</ul>
<p>Wenn Fn ein Objekt ist, ruft <code>Fn()</code> (vorher als <code>%Fn%()</code> geschrieben) jetzt <code>Fn.Call()</code> anstelle von <code>Fn.()</code> auf (das jetzt nur noch als <code>Fn.%""%()</code> geschrieben werden kann). Funktionen unterstützen nicht mehr die namenlose Methode.</p>
<p><code>this.Method()</code> ruft <code>Fn.Call(this)</code> (wobei <em>Fn</em> das Funktionsobjekt ist, das die Methode implementiert) anstelle von <code>Fn[this]()</code> auf (was in v1 zu einem Aufruf von <code>Fn.__Call(this)</code> führen würde, sofern <code>Fn[this]</code> keine Funktion enthält). Funktionsobjekte sollten eine <em>Call</em>-Methode anstelle von <em>__Call</em> implementieren, das nur für explizite Methodenaufrufe vorgesehen ist.</p>
<p><code><i>Klassenname</i>()</code> (ehemals <code>new <i>Klassenname</i>()</code>) versagt nun beim Erstellen des Objekts, wenn die Methode <code>__New</code> definiert ist, aber nicht aufgerufen werden konnte (z. B. weil die Parameteranzahl falsch ist), oder wenn Parameter übergeben wurden, aber <code>__New</code> nicht definiert ist.</p>
<p>Objekte, die innerhalb eines Ausdrucks erstellt oder von einer Funktion zurückgegeben werden, werden nun zurückgehalten, bis die Ausdrucksauswertung abgeschlossen ist, und dann freigegeben. Dies verbessert die Leistung geringfügig und ermöglicht es, temporäre Objekte für die Speicherverwaltung innerhalb eines Ausdrucks zu verwenden, ohne befürchten zu müssen, dass die Objekte vorzeitig freigegeben werden.</p>
<p>Objekte können Zeichenkettenwerte (aber nicht Schlüssel) mit binären Nullen enthalten. Beim Klonen eines Objekts werden Binärdaten in Zeichenketten beibehalten, bis zur gespeicherten Länge der Zeichenkette (nicht deren Kapazität). Früher wurden Daten über die Länge des Wertes hinaus geschrieben, wenn es um binäre Daten oder Strukturen ging; jetzt sollte stattdessen ein <a href="objects/Buffer.htm">Buffer</a>-Objekt verwendet werden.</p>
<p>Zuweisungsausdrücke wie <code>x.y := z</code> liefern nun immer den Wert <code>z</code>, egal wie <code>x.y</code> implementiert wurde. Der Rückgabewert eines Eigenschaft-Setters wird nun ignoriert. Früher:</p>
<ul>
<li>Einige interne Objekte gaben <code>z</code> zurück, andere gaben <code>x.y</code> zurück (z. B. <code>c := GuiObj.BackColor := "red"</code>, das <code>c</code> auf <code>0xFF0000</code> gesetzt hat), und andere gaben einen falschen Wert zurück.</li>
<li>Benutzerdefinierte Eigenschaft-Setter haben eventuell unerwartete Werte zurückgegeben oder konnten nichts zurückgeben.</li>
</ul>
<p><code>x.y(z) := v</code> ist nun ein Syntaxfehler. Früher war es äquivalent zu <code>x.y[z] := v</code>. Grundsätzlich sind <code>x.y(z)</code> (Methodenaufruf) und <code>x.y[z]</code> (parametrisierte Eigenschaft) zwei verschiedene Operationen, allerdings werden diese als gleichwertig angesehen, wenn <code>x</code> ein COM-Objekt ist (aufgrund von Einschränkungen der COM-Schnittstelle).</p>
<p>Die Verkettung eines Objekts mit einem anderen Wert oder dessen Übergabe an Loop wird derzeit als Fehler behandelt; früher wurde das Objekt als leere Zeichenkette behandelt. Dies kann so geändert werden, dass implizit <code>.ToString()</code> aufgerufen wird. Verwenden Sie <code>String(x)</code>, um einen Wert in eine Zeichenkette zu konvertieren; dies ruft <code>.ToString()</code> auf, wenn <code>x</code> ein Objekt ist.</p>
<p>Beim Aufrufen eines Objekts via IDispatch (die COM-Schnittstelle) führen unbehandelte Ausnahmen, die nicht an den Aufrufer zurückgegeben werden können, zu einem Fehlerdialogfenster. (Der Aufrufer kann nach Belieben ein zusätzliches Fehlerdialogfenster ohne spezifische Details anzeigen.) Dies gilt auch für den Aufruf von Ereignishandlern durch Verwendung von <a href="commands/ComObjConnect.htm">ComObjConnect</a>.</p>
<h3 id="functions">Funktionen</h3>
<p>Funktionen können nicht mehr dynamisch mit mehr Parametern als formal möglich aufgerufen werden.</p>
<p>Variadische Funktionen sind von der obigen Einschränkung nicht betroffen, erstellen aber normalerweise bei jedem Aufruf ein Array, um die überschüssigen Parameter zu behalten. Wenn dieses Array nicht benötigt wird, kann der Parametername nun weggelassen werden, um seine Erstellung zu verhindern:</p>
<pre>AkzeptiertEinOderMehrArgs(erster, *) {
  ...
}
</pre>
<p>Dies kann für Callbacks verwendet werden, bei denen die zusätzlichen Parameter nicht benötigt werden.</p>
<p>Variadische Funktionsaufrufe erlauben nun ein beliebiges enumerierbares Objekt in Situationen, wo sie früher ein Standardobjekt mit sequentiellen numerischen Schlüsseln benötigten. Wenn der Enumerator mehr als einen Wert pro Iteration zurückgibt, wird nur der erste Wert verwendet. <code>Array(mymap*)</code> beispielsweise erstellt ein Array, das die Schlüssel von <em>mymap</em> enthält.</p>
<p>Variadische Funktionsaufrufe hatten früher nur eine halbherzige Unterstützung für benannte Parameter. Dies wurde deaktiviert, um ein mögliches Hindernis für die ordnungsgemäße Implementierung von benannten Parametern zu beseitigen.</p>
<p>Benutzerdefinierte Funktionen können das neue Schlüsselwort <code>unset</code> als Standardwert eines Parameters verwenden, um den Parameter "ungesetzt" zu machen, wenn kein Wert bereitgestellt wurde. Die Funktion kann dann IsSet() verwenden, um festzustellen, ob ein Wert bereitgestellt wurde. <code>unset</code> ist derzeit in keinem anderen Kontext erlaubt.</p>
<p>Skripte werden nicht mehr automatisch aus den Funktionsbibliothekordnern (Lib) eingebunden, wenn ein Funktionsaufruf ohne Definition vorhanden ist, um die Komplexität zu verringern und Missgeschicke zu verhindern (jetzt, wo das <code>MeineFunk</code> in <code>MeineFunk()</code> eine beliebige Variable sein kann). <code>#Include &lt;BiblName&gt;</code> funktioniert wie zuvor. Es könnte in einer zukünftigen Version mit einer Modulunterstützung ersetzt werden.</p>
<p>Variadische interne Funktionen haben jetzt einen <code>MaxParams</code>-Wert äquivalent zu <code>MinParams</code>, anstatt einer willkürlichen Zahl (wie 255 oder 10000). Verwenden Sie <code>IsVariadic</code>, um zu erkennen, wenn es keine obere Grenze gibt.</p>
<h4 id="byref">ByRef</h4>
<p><a href="Functions.htm#ByRef">ByRef-Parameter</a> werden jetzt nicht mehr mit <code>ByRef param</code>, sondern mit <code>&amp;param</code> deklariert, mit einigen Unterschieden bei der Verwendung.</p>
<p>ByRef-Parameter nehmen nicht mehr implizit eine Referenz, die auf die Variable des Aufrufers verweist. Stattdessen muss der Aufrufer eine Referenz explizit mit dem <a href="Variables.htm#ref">Referenzoperator</a> (<code>&amp;var</code>) übergeben. Dies ermöglicht mehr Flexibilität, z. B. Referenzen woanders hin zu speichern, sie mit einer variadischen Funktion zu akzeptieren und sie mit einem variadischen Aufruf weiterzugeben.</p>
<p>Wenn ein Parameter als ByRef gekennzeichnet ist, führt jeder Versuch, explizit einen Nicht-VarRef-Wert zu übergeben, dazu, dass ein Fehler ausgelöst wird. Andernfalls kann die Funktion erstens mit <code>param is VarRef</code> prüfen, ob eine Referenz vorliegt, zweitens mit <code>IsSetRef(param)</code> prüfen, ob die Zielvariable einen Wert hat, und drittens diese mit <code>%param%</code> explizit dereferenzieren.</p>
<p>ByRef-Parameter sind nun in der Lage, eine Referenz zu einer lokalen Variable aus einer vorherigen Instanz derselben Funktion zu erhalten, wenn diese rekursiv aufgerufen wird.</p>
<h3 id="nested-functions">Verschachtelte Funktionen</h3>
<p>Es kann eine Funktion in einer anderen Funktion definiert werden. Eine verschachtelte Funktion kann automatisch nicht-statische lokale Variablen von der äußeren Funktion "abfangen" (unter den richtigen Bedingungen), wodurch diese nach Abschluss der äußeren Funktion verwendet werden können.</p>
<p>Der neue Fat-Arrow-Operator <code>=&gt;</code> kann auch genutzt werden, um verschachtelte Funktionen zu erstellen.</p>
<p>Alle Details finden Sie unter <a href="Functions.htm#nested">Verschachtelte Funktionen</a>.</p>
<h3 id="uncategorized">Sonstiges</h3>
<p>Beim Initialisieren einer deklarierten Variable oder eines optionalen Parameters muss <code>:=</code> statt <code>=</code> verwendet werden.</p>
<p><code>return %var%</code> bewirkt nun eine Doppeldereferenzierung; vorher war es das gleiche wie <code>return var</code>.</p>
<p><a href="commands/_Include.htm">#Include</a> ist standardmäßig relativ zum Verzeichnis, das die aktuelle Datei enthält. Der Parameter dieser Direktive können nun optional in Anführungszeichen gesetzt werden.</p>
<p>Der Parameter von <a href="commands/_ErrorStdOut.htm">#ErrorStdOut</a> kann nun optional in Anführungszeichen gesetzt werden.</p>
<p>Labelnamen dürfen nur noch aus Buchstaben, Zahlen, Unterstrichen und ASCII-fremden Zeichen bestehen (dasselbe gilt für Variablen, Funktionen und so weiter).</p>
<p>Labels innerhalb einer Funktion werden lokal behandelt; sie sind nur innerhalb der Funktion nutzbar und können nicht mit anderen Labels außerhalb dieser Funktion in Konflikt geraten. Es ist nicht möglich, lokale Labels extern aufzurufen (auch nicht via interne Funktionen). Stattdessen können verschachtelte Funktionen verwendet werden, die die volle Nutzung lokaler Variablen ermöglichen.</p>
<p><code>for k, v in obj</code>:</p>
<ul>
<li>Es wurde geändert, wie das Objekt aufgerufen wird. Siehe <em>Enumeration</em>.</li>
<li><code>for</code> setzt nun k und v auf die Werte zurück, die sie vor Beginn der Schleife hatten, nachdem die Schleife unterbrochen oder beendet wurde.</li>
<li>Es wird eine Ausnahme ausgelöst, wenn <em>obj</em> kein Objekt ist oder es ein Problem beim Abrufen oder Aufrufen des Enumerators gibt.</li>
<li>Es können bis zu 19 Variablen verwendet werden.</li>
<li>Variablen können weggelassen werden.</li>
</ul>
<p>Ein Komma mit einem Escapezeichen zu versehen, hat keine Bedeutung mehr. Früher wurde ein Komma, das sich in einem Ausdruck innerhalb eines Befehlsparameters befand und nicht mit runden Klammern umschlossen war, als Mehrfachanweisungsoperator interpretiert, anstatt als Trennung für Parameter. Diese Methode funktionierte nur bei Befehlen, nicht bei Funktionen oder Variablendeklarationen.</p>
<p>Die Escapesequenz <code>`s</code> ist nun überall dort erlaubt, wo <code>`t</code> unterstützt wird. Früher war sie nur bei #IfWin und (Join erlaubt.</p>
<p><code>*/</code> kann nun am Ende einer Zeile stehen, um einen mehrzeiligen Kommentar zu schließen, und um zu bewirken, dass <code>/* */</code> sich so verhält wie bei anderen Sprachen. Um das Risiko einer Mehrdeutigkeit zu verhindern (z. B. ein Hotstring, der mit <code>*/</code> endet), wird jedes <code>*/</code>, das nicht ein <code>/*</code> davor hat, nicht länger ignoriert (eine Änderung in AHK_L Revision 54 wurde rückgängig gemacht).</p>
<p>Integer-Konstanten und numerische Zeichenketten außerhalb des unterstützten Bereichs (von vorzeichenbehafteten 64-Bit-Integern) werden nun überlaufen/umgekehrt, anstatt auf den Minimal-/Maximalwert begrenzt zu werden. Dies ist konsistent mit mathematischen Operatoren, daher ist <code>9223372036854775807+1 == 9223372036854775808</code> (aber beide erzeugen -9223372036854775808). Dies ermöglicht bitweise Operationen bei 64-Bit-Werten.</p>
<p>Bei numerischen Zeichenketten kommt es eher selten vor, dass neben Leer- oder Tabulatorzeichen noch andere Arten von Leerraumzeichen vor der Zahl erlaubt sind. In der Regel gilt (sowohl in v1 als auch v2), dass nur Leer- und Tabulatorzeichen erlaubt sind, aber in einigen Fällen werden andere Typen von Leerraumzeichen aufgrund der Konventionen der C-Laufzeitbibliothek toleriert.</p>
<p><code>else</code> kann nun zusammen mit <code>loop</code>, <code>for</code>, <code>while</code> und <code>catch</code> verwendet werden. Bei Schleifen wird es ausgeführt, wenn die Schleife null Iterationen hatte. Bei <code>catch</code> wird es ausgeführt, wenn keine Ausnahme innerhalb von <code>try</code> ausgelöst wird (und wird nicht ausgeführt, wenn ein Fehler oder ein Wert ausgelöst wird, auch wenn es kein <code>catch</code> gibt, das der Klasse des Wertes entspricht). Folglich kann die neue Interpretation von <code>else</code> abweichen, wenn es ohne geschweifte Klammern verwendet wird. Zum Beispiel:</p>
<pre>if Bedingung
{
    while Bedingung
        <em>; Anweisung, die für jede Iteration ausgeführt werden soll</em>
} <em>; Diese Klammern sind jetzt erforderlich, sonst assoziiert Else mit While</em>
else
    <em>; Anweisung, die ausgeführt werden soll, wenn die Bedingung False ist</em>
</pre>
<h3 id="continuation-sections">Fortsetzungsbereiche</h3>
<p>Intelligentes LTrim: Standardmäßig werden alle Leer- und Tabulatorzeichen gezählt, die am Anfang der ersten Zeile unterhalb der Fortsetzungsbereichsoptionen vorkommen, und danach genauso viele Zeichen bei nachfolgenden Zeilen entfernt. Enthält die erste Zeile eine Mischung aus Leer- und Tabulatorzeichen, wird nur der erste Zeichentyp als Einrückung behandelt. Wenn jede Zeile weniger eingerückt ist als die erste Zeile oder mit den falschen Zeichen eingerückt ist, werden alle Leerraumzeichen am Anfang auf dieser Zeile beibehalten.</p>
<p>Anführungszeichen werden automatisch mit einem Escapezeichen versehen (also als direkt geschriebene Zeichen interpretiert), wenn der Fortsetzungsbereich innerhalb einer in Anführungszeichen gesetzte Zeichenkette beginnt. Dadurch wird verhindert, dass Anführungszeichen in mehrzeiligen Zeichenketten mit einem Escapezeichen versehen werden müssen (wenn das beginnende und endende Anführungszeichen außerhalb des Fortsetzungsbereichs liegen), während mehrzeilige Ausdrücke immer noch Anführungszeichen enthalten können.</p>
<p>Wenn die Zeile über dem Fortsetzungsbereich mit einem Namenszeichen endet und der Bereich nicht innerhalb eines Anführungszeichens beginnt, wird automatisch ein einzelnes Leerzeichen eingefügt, um den Namen vom Inhalt des Fortsetzungsbereichs zu trennen. Dadurch kann ein Fortsetzungsbereich für einen mehrzeiligen Ausdruck verwendet werden, der nach einem <code>return</code>, Funktionsaufrufanweisungen und so weiter erfolgt. Es stellt auch sicher, dass Variablennamen nicht mit anderen Tokens (oder Namen) verbunden werden, was zu ungültigen Ausdrücken führt.</p>
<p>Zeilenumbruchszeichen (<code>`n</code>) werden innerhalb von Ausdrücken als Leerzeichen behandelt. Dadurch können Ausdrücke mehrzeilig gemacht werden, mithilfe eines Fortsetzungsbereichs mit Standardoptionen (das heißt, dass <code>Join</code> nicht mehr notwendig ist).</p>
<p>Die Optionen <code>,</code> und <code>%</code> wurden entfernt, da solche Zeichen nicht mehr mit einem Escapezeichen versehen werden müssen.</p>
<p>Wenn <code>(</code> oder <code>)</code> in den Optionen eines potenziellen Fortsetzungsbereichs erscheint (außer als Teil der <code>Join</code>-Option), wird die gesamte Zeile nicht als Beginn eines Fortsetzungsbereichs interpretiert. Mit anderen Worten werden Zeilen wie <code>(x.y)()</code> und <code>(x=y) &amp;&amp; z()</code> als Ausdrücke interpretiert. Ein mehrzeiliger Ausdruck kann auch mit einer runden Startklammer am Anfang einer Zeile beginnen, vorausgesetzt, es gibt mindestens ein weiteres <code>(</code> oder <code>)</code> in der ersten physikalischen Zeile. Zum Beispiel könnte der gesamte Ausdruck mit <code>((</code> und <code>))</code> umschlossen werden.</p>
<p>Abgesehen vom obigen Fall wird bei Vorhandensein ungültiger Optionen ein Ladezeitfehler angezeigt, anstatt die ungültigen Optionen zu ignorieren.</p>
<p>Zeilen, die mit <code>(</code> beginnen und mit <code>:</code> enden, sind nicht mehr vom Beginn eines Fortsetzungsbereichs ausgeschlossen, weil sie wie ein Label aussehen, da <code>(</code> in einem Labelnamen nicht mehr gültig ist. Dies macht es möglich, dass so etwas wie <code>(Join:</code> einen Fortsetzungsbereich beginnen kann. <code>(:</code> ist jedoch ein Fehler und <code>(::</code> ist immer noch ein Hotkey.</p>
<p>Eine neue Methode der Zeilenfortsetzung wird in Ausdrücken und Funktions-/Eigenschaftsdefinitionen unterstützt, die die Tatsache ausnutzt, dass jedes <code>(</code>/<code>[</code>/<code>{</code> mit einem entsprechenden <code>)</code>/<code>]</code>/<code>}</code> abgeglichen werden muss. Sprich, enthält eine Zeile ein nicht geschlossenes <code>(</code>/<code>[</code>/<code>{</code>, wird sie mit nachfolgenden Zeilen verbunden, bis sich die Anzahl der Start- und Endklammern ausgleicht. Ein <code>{</code> am Ende einer Zeile wird als OTB (und nicht als Anfang einer direkten Objektschreibweise) angesehen, wenn es keine anderen ungeschlossenen Symbole gibt und unmittelbar vor der Klammer kein Operator steht.</p>
<h3 id="continuation-lines">Fortsetzungszeilen</h3>
<p>Die Zeilenfortsetzung ist jetzt selektiver in Bezug dessen, in welchem Kontext ein Symbol als Ausdrucksoperator angesehen wird. Grundsätzlich können Komma- und Ausdrucksoperatoren nicht mehr zur Fortsetzung in textueller Hinsicht verwendet werden, wie z. B. bei Hotstrings oder Direktiven (außer #HotIf) oder nach einer nicht geschlossenen, in Anführungszeichen gesetzten Zeichenkette.</p>
<p>Die Zeilenfortsetzung funktioniert jetzt auch für Ausdrucksoperatoren am Ende einer Zeile.</p>
<p><code>is</code>, <code>in</code> und <code>contains</code> können für die Zeilenfortsetzung genutzt werden, allerdings sind <code>in</code> und <code>contains</code> noch nicht als Operatoren reserviert/implementiert.</p>
<p><code>and</code>, <code>or</code>, <code>is</code>, <code>in</code> und <code>contains</code> agieren als Zeilenfortsetzungsoperatoren, auch wenn danach eine Zuweisung oder ein anderer binärer Operator erfolgt, da diese keine gültigen Variablennamen mehr sind. AHK v1 hingegen hatte Ausnahmen für <code>and</code>/<code>or</code>, gefolgt von einem der folgenden Zeichen: <code>&lt;&gt;=/|^:,</code></p>
<p>Wenn <code>.</code> für die Fortsetzung verwendet wird, werden die beiden Zeilen nicht mehr automatisch durch ein Leerzeichen abgegrenzt, wenn am Anfang einer Zeile kein Leer- oder Tabulatorzeichen rechts von <code>.</code> war, wie in <code>.SehrLangerVerschachtelterKlassenname</code>. Beachten Sie, dass <code>x .123</code> immer ein Eigenschaftszugriff ist (keine Auto-Verkettung) und <code>x+.123</code> mit oder ohne Leerzeichen funktioniert.</p>
<h3 id="types">Typen</h3>
<p>In der Regel erzeugt v2 konsistentere Ergebnisse als v1 bei einem Code, das vom Typ eines Wertes abhängig ist.</p>
<p>In v1 kann eine Variable sowohl eine Zeichenkette als auch eine zwischengespeicherte Binärzahl enthalten, die immer dann aktualisiert wird, wenn die Variable als Zahl verwendet wird. Da diese zwischengespeicherte Binärzahl das einzige Mittel zur Erkennung des Werttyps ist, wird das Caching, welches intern via Ausdrücke wie <code>var+1</code> oder <code>abs(var)</code> erfolgt, effektiv den "Typ" von <code>Var</code> ändern. AutoHotkey v2 deaktiviert dieses Caching, so dass <code>str := "123"</code> immer eine Zeichenkette und <code>int := 123</code> immer ein Integer ist. Folglich muss <code>str</code> jedes Mal umgewandelt werden, wenn es als Nummer verwendet wird (statt nur beim ersten Mal), es sei denn, es wurde ursprünglich eine reine Nummer zugewiesen.</p>
<p>Die internen Variablen <code>True</code>, <code>False</code>, <code>A_PtrSize</code>, <code>A_IsUnicode</code>, <code>A_Index</code> und <code>A_EventInfo</code> geben immer reine Integer statt Zeichenketten zurück. In v1 geben sie manchmal Zeichenketten zurück, aufgrund von Optimierungen, die in v2 ersetzt wurden.</p>
<p>Alle direkt geschriebenen Zahlen werden beim Laden des Skripts in reine Binärzahlen umgewandelt und ihre Repräsentation als Zeichenkette verworfen. Zum Beispiel wäre <code>MsgBox 0x1</code> das gleiche wie <code>MsgBox 1</code>, oder <code>MsgBox 1.0000</code> das gleiche wie <code>MsgBox 1.0</code> (weil die interne Float-Formatierung geändert wurde). Eine Zahl, die man in eine Variable speichert oder von einer benutzerdefinierten Funktion zurückgeben lässt, wird ihren reinen numerischen Zustand beibehalten.</p>
<p>Die standardmäßig verwendete Formatangabe für Floating-Point-Zahlen ist nun <code>.17g</code> (vorher war es <code>0.6f</code>), was in vielen Fällen kompakter und genauer ist. Dieser Standard kann nicht geändert werden, aber mit <code>Format</code> können andere Formatierungen erzielt werden.</p>
<p>Direkt geschriebene Zeichenketten in Anführungszeichen und Zeichenketten, die mit mehreren direkt geschriebenen Zeichenketten in Anführungszeichen gebildet werden, werden nicht länger bedingungslos als nicht-numerisch angesehen. Stattdessen werden sie wie Zeichenketten behandelt, die in Variablen gespeichert oder von Funktionen zurückgegeben worden sind. Dies hat folgende Auswirkungen:</p>
<ul>
<li>Anweisungen wie <code>"0"</code> werden als False angesehen.</li>
<li><code>("0xA") + 1</code> und <code>("0x" Chr(65)) + 1</code> erzeugen 11 statt einen Fehler.</li>
<li><code>x[y:="0"]</code> und <code>x["0"]</code> verhalten sich nun gleich.</li>
</ul>
<p>Die Operatoren <code>=</code> und <code>!=</code> vergleichen nun ihre Operanden alphabetisch, wenn beide Operanden Zeichenketten sind, auch dann, wenn sie numerische Zeichenketten sind. Ein numerischer Vergleich wird weiterhin durchgeführt, wenn beide Operanden numerisch sind und mindestens ein Operand eine reine Zahl (keine Zeichenkette) ist. So zum Beispiel werden 54 und "530" numerisch verglichen, während "54" und "530" alphabetisch verglichen werden. Darüber hinaus werden Zeichenketten, die in Variablen gespeichert sind, genauso wie direkt geschriebene Zeichenketten behandelt.</p>
<p>Die Vergleichsoperatoren <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> und <code>&gt;=</code> lösen nun eine Ausnahme aus, wenn sie mit einer nicht-numerischen Zeichenkette verwendet werden. Früher verglichen sie numerisch oder alphabetisch, je nachdem, ob beide Eingabewerte numerisch waren; direkt geschriebene, in Anführungszeichen gesetzte Zeichenketten wurden jedoch immer als nicht-numerisch angesehen. Verwenden Sie stattdessen <code>StrCompare(a, b, GroßKleinSensitiv)</code>.</p>
<p><code>Type(Wert)</code> gibt eine der folgenden Zeichenketten zurück: String, Integer, Float, oder die spezifische Klasse eines Objekts.</p>
<p><code>Float(v)</code>, <code>Integer(v)</code> and <code>String(v)</code> konvertieren <code>v</code> in den jeweiligen Typ, oder lösen eine Ausnahme aus, wenn die Konvertierung nicht durchgeführt werden kann (z.B. <code>Integer("1z")</code>). <code>Number(v)</code> konvertiert einen Wert in einen Integer- oder Float-Wert. <code>String</code> ruft <code>v.ToString()</code> auf, wenn <code>v</code> ein Objekt ist. (Idealerweise wäre das für jede implizite Konvertierung von Objekt zu Zeichenkette wünschenswert, aber die aktuelle Implementierung macht dies schwierig.)</p>
<h2 id="objects">Objekte</h2>
<p>Objekte verwenden nun einen strukturierteren Klassen-Prototypen-Ansatz, um Klassenelemente bzw. statische Elemente von Instanzelementen zu trennen. Viele der internen Methoden und Obj-Funktionen wurden verschoben, umbenannt, geändert oder entfernt.</p>
<ul>
<li>Jede benutzerdefinierte oder interne Klasse ist ein Klassenobjekt (eine Instanz von <a href="objects/Class.htm">Class</a>), das nur Methoden und Eigenschaften, die mit dem Schlüsselwort <code>static</code> definiert wurden (einschließlich statischer Elemente, die von der Basisklasse geerbt wurden) und verschachtelten Klassen offenlegt.</li>
<li>Jedes Klassenobjekt hat eine <a href="objects/Class.htm#Prototype">Prototype</a>-Eigenschaft, die zum <code>base</code> aller Instanzen dieser Klasse wird. Alle nicht-statischen Methoden- und Eigenschaftsdefinitionen innerhalb des Klassenkörpers sind mit dem Prototype-Objekt verbunden.</li>
<li>Die Instanziierung erfolgt durch Aufruf der statischen Methode <a href="objects/Class.htm#Call">Call</a>, wie in <code>meineKlasse.Call()</code> oder <code>meineKlasse()</code>. Dadurch kann die Klasse das Konstruktionsverhalten vollständig überschreiben (z. B. um eine Class Factory oder ein Singleton zu implementieren, oder um ein natives Array- oder Map-Objekt anstelle einer Instanz der Object-Klasse zu konstruieren), obwohl die Initialisierung typischerweise noch in <code>__New</code> durchgeführt werden sollte. Der Rückgabewert von <code>__New</code> wird nun ignoriert; um den Rückgabewert zu überschreiben, verwenden Sie die Call-Methode.</li>
</ul>
<p>Der gemischte Objekttyp wurde in <code>Object</code>, <code>Array</code> und <code>Map</code> (assoziatives Array) aufgeteilt.</p>
<p>Object ist nun die Stammklasse für alle benutzerdefinierten <strong>und internen</strong> Objekte (außer VarRef und COM-Objekte). Elemente, die zu <code>Object.Prototype</code> hinzugefügt wurden, werden von allen AutoHotkey-Objekten geerbt.</p>
<p>Der Operator <code>is</code> erwartet eine Klasse, also wird <code>x is y</code> nun nach <code>y.Prototype</code> in der Basisobjektkette suchen und überprüfen. Um nach <code>y</code> selbst zu suchen und zu überprüfen, rufen Sie <code>x.HaseBase(y)</code> oder <code>HasBase(x, y)</code> auf.</p>
<p>Benutzerdefinierte Klassen können auch explizit <code>Object</code>, <code>Array</code>, <code>Map</code> oder irgendeine andere interne Klasse via "extends" erweitern (obwohl dies nicht immer sinnvoll ist), mit <code>Object</code> als Standardbasisklasse ist, wenn keine angegeben ist.</p>
<p>Der <code>new</code>-Operator wurde entfernt. Lassen Sie stattdessen einfach den Operator weg, wie in <code>MeineKlasse()</code>. Um ein Objekt zu konstruieren, das auf einem anderen Objekt <em>basiert</em>, das keine Klasse ist, erstellen Sie es mit <code>{}</code> oder <code>Object()</code> (oder auf andere Weise) und setzen Sie dessen <code>base</code>. <code>__Init</code> und <code>__New</code> können bei Bedarf explizit aufgerufen werden, allerdings ist das in der Regel nur bei der Instanziierung einer Klasse sinnvoll.</p>
<p>Verschachtelte Klassendefinitionen erzeugen jetzt eine dynamische Eigenschaft mit <em>Get</em>- und <em>Call</em>-Akzessorfunktionen anstelle einer einfachen Werteigenschaft. Damit soll das folgende Verhalten unterstützt werden:</p>
<ul>
<li><code>Verschachtelt.Klasse()</code> übergibt <code>Verschachtelt</code> nicht an <code>Verschachtelt.Klasse.Call</code> und letztlich an <code>__New</code>, was sonst passieren würde, weil dies das normale Verhalten für Funktionsobjekte ist, die als Methoden aufgerufen werden (so wie hier die verschachtelte Klasse verwendet wird).</li>
<li><code>Verschachtelt.Klasse := 1</code> ist standardmäßig ein Fehler (die Eigenschaft ist schreibgeschützt).</li>
<li>Die Klasse wird initialisiert, sobald sie das erste Mal referenziert oder aufgerufen wird.</li>
</ul>
<p>GetCapacity und SetCapacity wurden entfernt.</p>
<ul>
<li><a href="objects/Object.htm#GetCapacity">ObjGetCapacity</a> und <a href="objects/Object.htm#SetCapacity">ObjSetCapacity</a> haben nur noch Einfluss auf die Kapazität des Objekts zur Aufnahme von Eigenschaften, und kommen voraussichtlich nur selten zum Einsatz. Das Setzen der Kapazität des Zeichenkettenpuffers einer Eigenschaft, eines Array-Elements oder eines Map-Elements wird nicht unterstützt; für Binärdaten können Sie ein <a href="objects/Buffer.htm">Buffer</a>-Objekt nutzen.</li>
<li>Array- und Map-Objekte haben eine Capacity-Eigenschaft, die der aktuellen Array- oder Map-Speicherzuweisung des Objekts entspricht.</li>
</ul>
<p>Andere redundante Obj-Funktionen (von denen es interne Object-Methoden gibt) wurden entfernt. <a href="objects/Object.htm#HasOwnProp">ObjHasOwnProp</a> (ehemals ObjHasKey) und <a href="objects/Object.htm#OwnProps">ObjOwnProps</a> (ehemals ObjNewEnum) bleiben erhalten, um die sichere Überprüfung von Objekten zu erleichtern, die diese Methoden neu definiert haben (und die primitiven Prototypen, die diese Methoden nicht definiert haben). ObjCount wurde mit <a href="objects/Object.htm#OwnPropCount">ObjOwnPropCount</a> ersetzt (nur eine Funktion, für alle Instanzen der Object-Klasse) und das Map-Objekt hat eine eigene <a href="objects/Map.htm#Count">Count</a>-Eigenschaft.</p>
<p>ObjRawGet und ObjRawSet wurden mit <a href="objects/Object.htm#GetOwnPropDesc">GetOwnPropDesc</a> und <a href="objects/Object.htm#DefineProp">DefineProp</a> zusammengeführt. Die ursprünglichen Gründe, warum sie hinzugefügt wurden, wurden durch andere Änderungen verdrängt, wie z. B. das <code>Map</code>-Objekt, Änderungen in der Funktionsweise von Meta-Funktionen, und DefineProp selbst, das Meta-Funktionen für einige Zwecke verdrängt hat.</p>
<p>Top-Level-Klassendefinitionen erstellen nun eine Konstante (schreibgeschützte Variable); das heißt, dass wenn man einem Klassennamen etwas zuweist, nicht länger eine optionale Warnung, sondern eine Fehlermeldung angezeigt wird, außer wenn eine lokale Variable die globale Klasse überschattet (was jetzt standardmäßig bei Zuweisungen innerhalb einer Funktion geschieht).</p>
<h3 id="primitive-values">Primitive Werte</h3>
<p>Primitive Werte emulieren Objekte durch Delegieren von Methoden- und Eigenschaftsaufrufen an ein Prototypobjekt auf Basis ihres Typs anstelle des v1-"Standardbasisobjekts". Integer und Float erbt von Number. String und Number erbt von Primitive. Primitive und Object erbt von Any. All diese existieren als vordefinierte Klassen.</p>
<h3 id="properties-and-methods">Eigenschaften und Methoden</h3>
<p>Methoden werden durch Eigenschaften definiert, ähnlich wie in v1, aber anders als in v2.0-a104 bis v2.0-a127, wo Methoden und Eigenschaften getrennt behandelt werden. Allerdings sind im Gegensatz zu v1 Eigenschaften, die mit einer Klassenmethodendefinition (oder einer internen Methode) erstellt wurden, standardmäßig schreibgeschützt. Methoden können aber weiterhin durch Zuweisen neuer Werteigenschaften erstellt werden, die sich grundsätzlich wie in v1 verhalten.</p>
<p>Die Object-Klasse definiert neue Methoden für den Umgang mit Eigenschaften und Methoden: <a href="objects/Object.htm#DefineProp">DefineProp</a>, <a href="objects/Object.htm#DeleteProp">DeleteProp</a>, <a href="objects/Object.htm#GetOwnPropDesc">GetOwnPropDesc</a>, <a href="objects/Object.htm#HasOwnProp">HasOwnProp</a>, <a href="objects/Object.htm#OwnProps">OwnProps</a>. Zusätzliche Methoden sind für alle Werte (außer ComObjects) definiert: <a href="objects/Any.htm#GetMethod">GetMethod</a>, <a href="objects/Any.htm#HasProp">HasProp</a>, <a href="objects/Any.htm#HasMethod">HasMethod</a>.</p>
<p>Object, Array und Map sind nun getrennte Typen, und Array-Elemente und Eigenschaften werden getrennt behandelt.</p>
<p>Alle internen Methoden und Eigenschaften (einschließlich <code>base</code>) werden wie benutzerdefinierte Methoden definiert. Dadurch wird sichergestellt, dass diese sich konsistent verhalten und dass sowohl interne als auch benutzerdefinierte Elemente erkannt, abgerufen oder neu definiert werden können.</p>
<p>Wenn eine Eigenschaft keine Parameter akzeptiert, werden diese automatisch an das von der Eigenschaft zurückgegebene Objekt übergeben (oder es löst eine Ausnahme aus).</p>
<p>Der Versuch, eine nicht-existierende Eigenschaft abzurufen, wird bei allen Typen von Werten oder Objekten als Fehler behandelt, es sei denn, <code>__get</code> wurde definiert. Allerdings wird beim Setzen einer nicht-existierenden Eigenschaft diese in den meisten Fällen erstellt.</p>
<p>Hacks für mehrdimensionale Arrays wurden entfernt. <code>x.y[z]:=1</code> erzeugt nicht länger ein Objekt in <code>x.y</code>, außerdem ist <code>x[y,z]</code> ein Fehler, es sei denn, x.__item (oder x.__item.__item etc.) behandelt zwei Parameter.</p>
<p>Wenn eine Eigenschaft <code>get</code>, aber nicht <code>set</code> definiert, wird beim Zuweisen eines Wertes eine Ausnahme ausgelöst, anstatt die Eigenschaft überschrieben.</p>
<p><a href="objects/Object.htm#DefineProp">DefineProp</a> kann verwendet werden, um zu definieren, was passieren soll, wenn eine bestimmte Eigenschaft abgerufen, gesetzt <em>oder aufgerufen</em> wird, ohne dass irgendwelche Metafunktionen definiert werden müssen. Eigenschafts- und Methodendefinitionen in Klassen nutzen denselben Mechanismus, so dass es möglich ist, einen Property-Getter/Setter und eine Methode mit demselben Namen zu definieren.</p>
<p><code>{}</code>-Objektliterale setzen jetzt direkt Werte <em>eigener Eigenschaften</em> oder das <code>base</code> des Objekts. Das heißt, dass <code>__Set</code> und Eigenschaft-Setter nicht mehr aufgerufen werden (was typischerweise nur möglich wäre, wenn <code>base</code> innerhalb der Parameterliste gesetzt ist).</p>
<h3 id="staticclass-variables">Statische bzw. Klassenvariablen</h3>
<p>Initialisierungen von statischen bzw. Klassenvariablen werden jetzt im Kontext einer <code>static __Init</code>-Methode ausgeführt, so dass <code>this</code> auf die Klasse verweist und die Initialisierungen lokale Variablen erzeugen können. Sie werden evaluiert, wenn die Klasse zum ersten Mal referenziert wird (anstatt vor dem Beginn des automatischen Ausführungsbereichs ausgewertet zu werden, strikt nach Definitionsreihenfolge). Wenn die Klasse noch nicht referenziert wurde, werden sie spätestens beim Erreichen der Klassendefinition während der Ausführung evaluiert, so dass die Initialisierung globaler Variablen zuerst erfolgen kann, ohne sie in eine Klasse zu stecken.</p>
<h3 id="meta-functions">Metafunktionen</h3>
<p>Die Metafunktionen wurden stark vereinfacht; sie verhalten sich wie normale Methoden:</p>
<ul>
<li>Es spielt keine Rolle, wo sie innerhalb der Hierarchie definiert sind.</li>
<li>Wenn die Metafunktion überschrieben ist, wird die Basisversion nicht automatisch aufgerufen. Skripte können bei Bedarf <code>super.__xxx()</code> aufrufen.</li>
<li>Wenn die Metafunktion definiert ist, muss sie die Standardaktion ausführen; wenn z. B. __set keinen Wert speichert, wird er nicht gespeichert.</li>
<li>Das Verhalten ist nicht davon abhängig, ob die Methode <code>return</code> verwendet (aber natürlich müssen __get und __call noch einen Wert zurückgeben).</li>
</ul>
<p>Methoden- und Eigenschaftsparameter werden als Array-Objekt übergeben. Dies optimiert verkettete Basis/Superklassen-Aufrufe und ermutigt Autoren (in Kombination mit der MaxParams-Validierung), die Parameter zu behandeln. Bei __set wird der Zuweisungswert separat übergeben.</p>
<pre><code><div>this.__call(name, args)
this.__get(name, args)
this.__set(name, args, value)
</div></code></pre>
<p>Definierte Eigenschaften und Methoden haben Vorrang vor Metafunktionen, egal ob sie in einem Basisobjekt definiert wurden.</p>
<p>__Call wird nicht für interne Aufrufe von __Enum (ehemals _NewEnum) oder Call aufgerufen, z. B. wenn ein Objekt an eine For-Schleife übergeben wird oder wenn ein Funktionsobjekt von SetTimer aufgerufen wird.</p>
<p>Die statische Methode __New wird für jede Klasse bei ihrer Initialisierung aufgerufen, wenn sie von dieser Klasse definiert oder von einer Superklasse geerbt wurde. Weitere Informationen finden Sie unter <a href="#staticclass-variables">Statische bzw. Klassenvariablen</a> (oben) und <a href="Objects.htm#static__New">Initialisierung einer Klasse</a>.</p>
<h3 id="array">Array</h3>
<p><code>class Array extends Object</code></p>
<p>Ein Array-Objekt enthält eine Liste oder Sequenz von Werten, hierbei ist Index 1 das erste Element.</p>
<p>Beim Zuweisen oder Abrufen eines Array-Elements muss der Absolutwert des Index zwischen 1 und <a href="objects/Array.htm#Length">Length</a> des Arrays liegen, sonst wird eine Ausnahme ausgelöst. Die Größe eines Arrays kann durch Einfügen oder Entfernen von Elementen mit der entsprechenden Methode oder durch Zuweisung eines Wertes an <a href="objects/Array.htm#Length">Length</a> geändert werden.</p>
<p>Aktuell sind eckige Klammern beim Zugriff auf Elemente erforderlich; sprich, <code>a.1</code> bezieht sich auf eine Eigenschaft und <code>a[1]</code> auf ein Element.</p>
<p>Negative Werte können verwendet werden, um rückwärts zu indexieren.</p>
<p>Die Funktionsweise von <a href="objects/Array.htm#Clone">Clone</a>, <a href="objects/Array.htm#Delete">Delete</a>, <a href="objects/Array.htm#InsertAt">InsertAt</a>, <a href="objects/Array.htm#Pop">Pop</a>, <a href="objects/Array.htm#Push">Push</a> und <a href="objects/Array.htm#RemoveAt">RemoveAt</a> ist grundsätzlich gleich geblieben. HasKey wurde in <a href="objects/Array.htm#Has">Has</a> umbenannt. <a href="objects/Array.htm#Length">Length</a> ist nun eine Eigenschaft. Die <a href="objects/Array.htm#Capacity">Capacity</a>-Eigenschaft wurde hinzugefügt.</p>
<p>Arrays können mit <code>Array(Werte*)</code> oder <code>[Werte*]</code> konstruiert werden. Variadische Funktionen erhalten ein Array von Parametern, außerdem werden Arrays von mehreren internen Funktionen erstellt.</p>
<p>Die Funktionsweise der For-Schleife ist <code>for val in arr</code> oder <code>for idx, val in arr</code>, wenn standardmäßig <code>idx = A_Index</code>. Das heißt, dass Elemente ohne Wert weiterhin enumeriert werden und dass der Index nicht zurückgegeben wird, wenn nur eine Variable übergeben wurde.</p>
<h3 id="map">Map</h3>
<p>Ein Map-Objekt ist ein assoziatives Array ähnlich dem v1-Objekt, aber mit geringerer Mehrdeutigkeit.</p>
<ul>
<li><a href="objects/Map.htm#Clone">Clone</a> wird wie bisher verwendet.</li>
<li><a href="objects/Map.htm#Delete">Delete</a> kann immer nur einen Schlüssel auf einmal löschen.</li>
<li>HasKey wurde in <a href="objects/Map.htm#Has">Has</a> umbenannt.</li>
<li><a href="objects/Map.htm#Count">Count</a> ist jetzt eine Eigenschaft.</li>
<li>Neue Eigenschaften: <a href="objects/Map.htm#Capacity">Capacity</a>, <a href="objects/Map.htm#CaseSense">CaseSense</a></li>
<li>Neue Methoden: <a href="objects/Map.htm#Get">Get</a>, <a href="objects/Map.htm#Set">Set</a>, <a href="objects/Map.htm#Clear">Clear</a></li>
<li>Zeichenketten-Schlüssel sind standardmäßig Groß-/Kleinschreibung-sensitiv und werden nie in Integer umgewandelt.</li>
</ul>
<p>Derzeit werden Float-Schlüssel noch in Zeichenketten umgewandelt.</p>
<p>Eckige Klammern sind beim Zugriff auf Elemente erforderlich; sprich, <code>a.b</code> bezieht sich auf eine Eigenschaft und <code>a["b"]</code> auf ein Element. Im Gegensatz zu v1 kann eine Eigenschaft oder Methode nicht versehentlich durch die Zuweisung eines Array-Elements deaktiviert werden.</p>
<p>Es wird eine Ausnahme ausgelöst, wenn man versucht, den Wert eines nicht existierenden Elements abzurufen, es sei denn, das Map-Objekt hat eine <a href="objects/Map.htm#Default">Default</a>-Eigenschaft definiert. <code>MapObj.Get(Schlüssel, Standardwert)</code> kann verwendet werden, um explizit einen Standardwert für jede Abfrage bereitzustellen.</p>
<p>Nutzen Sie <code>Map(Schlüssel, Wert, ...)</code>, um ein Map-Objekt mit einer Liste von Schlüssel-Wert-Paaren zu erstellen.</p>
<h3 id="enumeration">Enumeration</h3>
<p>Geändertes Enumerator-Modell:</p>
<ul>
<li>_NewEnum() wurde mit __Enum(n) ersetzt.</li>
<li>Der Pflichtparameter n enthält die Anzahl der Variablen in der For-Schleife, damit die Enumeration beeinflusst werden kann, ohne die Initialisierung bis zum ersten Iterationsaufruf verzögern zu müssen.</li>
<li>Next() wurde mit Call() ersetzt und wird genauso verwendet, nur dass ByRef jetzt anders funktioniert; z. B. sollte eine Methode, die als <code>Call(&amp;a)</code> definiert ist, <code>a := next_value</code> zuweisen, während <code>Call(a)</code> ein <code>VarRef</code> erhalten würde und somit <code>%a% := next_value</code> zuweisen sollte.</li>
<li>Wenn __Enum nicht vorhanden ist, wird das Objekt als Enumerator vermutet. Dadurch können Funktionsobjekte (wie z. B. Closures) direkt verwendet werden.</li>
</ul>
<p>Da Array-Elemente und Eigenschaften nun getrennt behandelt werden, muss zum Enumerieren von Eigenschaften explizit ein Enumerator via <a href="objects/Object.htm#OwnProps">OwnProps</a> erstellt werden.</p>
<h3 id="bound-functions">Bound-Funktionen</h3>
<p>Wenn eine Bound-Funktion aufgerufen wird, werden die vom Aufrufer übergebenen Parameter alle Positionen ergänzen, die bei der Erstellung der Bound-Funktion weggelassen wurden. <code>F.Bind(,b).Call(a,c)</code> beispielsweise ruft <code>F(a,b,c)</code> statt <code>F(,b,a,c)</code> auf.</p>
<h3 id="com-objects-comobject">COM-Objekte (ComObject)</h3>
<p>COM-Wrapper-Objekte werden jetzt in Abhängigkeit von ihrem Variantentyp als Instanzen einiger verschiedener Klassen identifiziert (was sich wie zuvor darauf auswirkt, welche Methoden und Eigenschaften sie unterstützen):</p>
<ul>
<li><code>ComValue</code> ist die Basisklasse für alle COM-Wrapper-Objekte.</li>
<li><code>ComObject</code> ist für VT_DISPATCH mit einem Nicht-Null-Pointer; also typischerweise ein gültiges COM-Objekt, das vom Skript mit normaler Objektsyntax aufgerufen werden kann.</li>
<li><code>ComObjArray</code> ist für VT_ARRAY (SafeArrays).</li>
<li><code>ComValueRef</code> ist für VT_BYREF.</li>
</ul>
<p>Diese Klassen können für Typenprüfungen mittels <code>obj is ComObject</code> und ähnlichem verwendet werden. Für Objekte vom Typ ComValue, ComObjArray und ComValueRef (aber nicht ComObject) können Eigenschaften und Methoden definiert werden, indem das jeweilige Prototyp-Objekt modifiziert wird.</p>
<p><code>ComObject(CLSID)</code> erstellt ein ComObject; das ist quasi das neue ComObjCreate.</p>
<p>Hinweis: Wenn Sie alten Code aktualisieren und einen TypeError aufgrund der Übergabe eines Integers an ComObject erhalten, sollten Sie wahrscheinlich stattdessen ComValue aufrufen.</p>
<p><code>ComValue(vt, Wert)</code> erstellt ein Wrapper-Objekt. Es kann eine Instanz einer beliebigen der oben aufgeführten Klassen zurückgeben. Dies ersetzt <code>ComObjParameter(vt, value)</code>, <code>ComObject(vt, value)</code> und alle anderen Namen, die mit einem <em>Variantentyp</em> und <em>Wert</em> als Parameter verwendet wurden. <em>Wert</em> wird in den entsprechenden Typ konvertiert (gemäß den COM-Konventionen), anstatt einen Integer mit dem richtigen Binärwert zu fordern. Genauer gesagt verhalten sich die folgenden anders als zuvor, wenn ein Integer übergeben wird: R4, R8, Cy, Date. Pointer-Typen erlauben entweder eine reine Integer-Adresse wie zuvor, oder ein Objekt/ComValue.</p>
<p><code>ComObjFromPtr(pdsp)</code> ist eine ähnliche Funktion wie <code>ComObjEnwrap(dsp)</code>, aber wie ObjFromPtr ruft sie nicht AddRef auf den Pointer auf. Das Äquivalent in v1 ist <code>ComObject(9, dsp, 1)</code>; das Weglassen des dritten Parameters in v1 verursachte ein AddRef.</p>
<p>Sowohl bei ComValue als auch bei ComObjFromPtr ist zu beachten, dass AddRef nie automatisch aufgerufen wird; dahingehend verhalten sie sich wie <code>ComObject(9, Wert, 1)</code> oder <code>ComObject(13, Wert, 1)</code> in v1. Das bedeutet nicht unbedingt, dass Sie <code>ObjAddRef(Wert)</code> hinzufügen sollten, wenn Sie alte Skripte aktualisieren, da viele Skripte die alte Funktion inkorrekt verwendet haben.</p>
<p>COM-Wrapper-Objekte mit dem Variantentyp VT_BYREF, VT_ARRAY oder VT_UNKNOWN haben jetzt eine <code>Ptr</code>-Eigenschaft, die äquivalent zu <code>ComObjValue(ComObj)</code> ist. Diese Änderung macht es möglich, COM-Objekte direkt an DllCall- oder ComCall-Funktionen zu übergeben, die den Argumenttyp <code>Ptr</code> aufweisen. Dadurch ist es auch möglich, das Objekt direkt an NumPut oder NumGet zu übergeben, was zusammen mit VT_BYREF (Zugriff auf die typisierte Variable des Aufrufers), VT_ARRAY (Zugriff auf SAFEARRAY-Felder) oder VT_UNKNOWN (vtable-Pointer abrufen) verwendet werden kann.</p>
<p>COM-Wrapper-Objekte mit dem Variantentyp VT_DISPATCH oder VT_UNKNOWN und einem Null-Interface-Pointer haben jetzt eine <code>Ptr</code>-Eigenschaft, die gelesen oder geändert werden kann. Sobald ein Nicht-Null-Pointer zugewiesen wurde, ist die Eigenschaft schreibgeschützt. Dies ist für die Verwendung mit DllCall und ComCall vorgesehen, damit der Pointer nach dem Return der Funktion nicht manuell gewrappt werden muss.</p>
<p>Die Enumeration von ComObjArray ist jetzt konsistent mit Array; also <code>for value in arr</code> oder <code>for index, value in arr</code> anstelle von <code>for value, vartype in arr</code>. Der Startwert für <code>index</code> ist die Untergrenze von ComObjArray (<code>arr.MinIndex()</code>), typischerweise 0.</p>
<p>Die Integer-Typen I1, I8, UI1, UI2, UI4 und UI8 werden nun in einen Integer statt in eine Zeichenkette konvertiert. Diese kommen in COM-Aufrufen selten vor, aber das gilt auch für VT_BYREF-Wrapper. VT_ERROR wird nicht mehr in einen Integer konvertiert, sondern erzeugt einen ComValue.</p>
<p>COM-Objekte setzen nicht länger <a href="Variables.htm#LastError">A_LastError</a>, wenn ein Eigenschafts- oder Methodenaufruf fehlschlägt.</p>
<h3 id="default-property">Standardeigenschaft</h3>
<p>Ein COM-Objekt verfügt ggf. über eine "Standardeigenschaft", die zwei Aufgaben hat:</p>
<ul>
<li>Der <em>Wert</em> des Objekts. In VBScript z. B. evaluiert <code>MsgBox obj</code> das Objekt, indem es dessen Standardelement aufruft.</li>
<li>Die indexierte Eigenschaft einer Sammlung, die normalerweise <code>Item</code> oder <code>item</code> heißt.</li>
</ul>
<p>AutoHotkey v1 hatte kein Konzept für eine Standardeigenschaft, so dass der COM-Objekt-Wrapper die Standardeigenschaft aufrief, wenn der Eigenschaftsname weggelassen wurde; also <code>obj[]</code> oder <code>obj[,x]</code>.</p>
<p>AutoHotkey v2 trennt jedoch Eigenschaften von Array-/Map-/Sammlungselementen. Um dies zu ermöglichen, wird <code>obj[x]</code> auf die Standardeigenschaft des Objekts gemapped (unabhängig davon, ob <code>x</code> vorhanden ist oder nicht). Für AutoHotkey-Objekte ist das <code>__Item</code>.</p>
<p>Einige COM-Objekte, die Arrays oder Sammlungen repräsentieren, stellen keine Standardeigenschaft zur Verfügung, sodass in v2 kein Zugriff auf Elemente mittels <code>[]</code> möglich ist. Zum Beispiel stellen JavaScript-Array-Objekte und einige andere Objekte, die normalerweise mit JavaScript verwendet werden, Array-Elemente als Eigenschaften zur Verfügung. In solchen Fällen kann <code>arr.%i%</code> verwendet werden, um auf eine Array-Element-Eigenschaft zuzugreifen.</p>
<p>Wenn ein <code>Array</code>-Objekt von AutoHotkey v2 an JavaScript übergeben wird, können dessen Elemente nicht mit JavaScripts <code>arr[i]</code> abgerufen werden, da das einen Zugriffsversuch auf eine Eigenschaft bedeuten würde.</p>
<h3 id="com-calls">COM-Aufrufe</h3>
<p>Aufrufe von AutoHotkey-Objekten über das IDispatch-Interface unterstützen jetzt nachvollziehbar <code>VT_BYREF</code>-Parameter. Dies wird häufig zusammen mit COM-Ereignissen (<a href="commands/ComObjConnect.htm">ComObjConnect</a>) verwendet.</p>
<p>Für jeden <code>VT_BYREF</code>-Parameter wird eine namenlose temporäre Variable erzeugt, der Wert aus der Variable des Aufrufers kopiert und eine <code>VarRef</code> an die AutoHotkey-Funktion/Methode übergeben. Bei Rückgabe wird der Wert aus der temporären Variable zurück in die Variable des Aufrufers kopiert.</p>
<p>Eine Funktion/Methode kann einen Wert zuweisen, indem der Parameter als ByRef (mit <code>&amp;</code>) deklariert oder eine explizite Dereferenzierung durchgeführt wird.</p>
<p>Ein Parameter vom Typ <code>VT_BYREF|VT_BOOL</code> beispielsweise hätte vorher ein ComObjRef-Objekt erhalten und einen Wert wie <code>pbCancel[] := true</code> oder <code>NumPut(-1, ComObjValue(pbCancel), "short")</code> zugewiesen bekommen. Nun kann der Parameter als <code>&amp;bCancel</code> definiert und ihm etwas mit so etwas wie <code>bCancel := true</code> zugewiesen werden; oder als <code>pbCancel</code> definiert und ihm etwas mit so etwas wie <code>%pbCancel% := true</code> zugewiesen werden.</p>
<h2 id="library">Liste</h2>
<p>Entfernt:</p>
<ul>
<li>Asc() (nutzen Sie stattdessen <a href="commands/Ord.htm">Ord</a>)</li>
<li>AutoTrim (nutzen Sie stattdessen <a href="commands/Trim.htm">Trim</a>)</li>
<li>ComObjMissing() (schreiben Sie stattdessen zwei aufeinanderfolgende Kommas)</li>
<li>ComObjUnwrap() (nutzen Sie stattdessen <a href="commands/ComObjValue.htm">ComObjValue</a>, und bei Bedarf <a href="commands/ObjAddRef.htm">ObjAddRef</a>)</li>
<li>ComObjEnwrap() (nutzen Sie stattdessen <a href="commands/ComObjFromPtr.htm">ComObjFromPtr</a>, und bei Bedarf <a href="commands/ObjAddRef.htm">ObjAddRef</a>)</li>
<li>ComObjError()</li>
<li>ComObjXXX(), wo XXX nichts anderes ist als eine der explizit definierten ComObj-Funktionen (nutzen Sie stattdessen <a href="commands/ComObjActive.htm">ComObjActive</a>, <a href="commands/ComValue.htm">ComValue</a> oder <a href="commands/ComObjFromPtr.htm">ComObjFromPtr</a>).</li>
<li>ControlSendRaw (nutzen Sie stattdessen <code>ControlSend "{Raw}"</code> oder <a href="commands/ControlSend.htm">ControlSendText</a>)</li>
<li>EnvDiv</li>
<li>EnvMult</li>
<li>EnvUpdate (dessen Nutzen war sehr begrenzt und kann mit einem einfachen <a href="commands/SendMessage.htm">SendMessage</a> ersetzt werden)</li>
<li>Exception (nutzen Sie stattdessen <a href="objects/Error.htm">Error</a> oder eine geeignete Unterklasse)</li>
<li>FileReadLine (nutzen Sie stattdessen eine <a href="commands/LoopFiles.htm">dateilesende Schleife</a> oder <a href="commands/FileOpen.htm">FileOpen</a>)</li>
<li>Func (nutzen Sie stattdessen eine direkte Referenz wie <code>MeineFunk</code>)</li>
<li>Gosub</li>
<li>Gui, GuiControl, GuiControlGet (siehe <a href="#gui">Gui</a>)</li>
<li>IfEqual</li>
<li>IfExist</li>
<li>IfGreater</li>
<li>IfGreaterOrEqual</li>
<li>IfInString</li>
<li>IfLess</li>
<li>IfLessOrEqual</li>
<li>IfMsgBox (<a href="commands/MsgBox.htm">MsgBox</a> gibt nun den Namen der Schaltfläche zurück)</li>
<li>IfNotEqual</li>
<li>IfNotExist</li>
<li>IfNotInString</li>
<li>IfWinActive</li>
<li>IfWinExist</li>
<li>IfWinNotActive</li>
<li>IfWinNotExist</li>
<li>If between/is/in/contains (aber siehe <a href="#isXXX">isXXX</a>)</li>
<li>Input (nutzen Sie stattdessen <a href="commands/InputHook.htm">InputHook</a>)</li>
<li>IsFunc</li>
<li>Menu (nutzen Sie stattdessen die <a href="objects/Menu.htm">Menu/MenuBar-Klasse</a>, <a href="commands/TraySetIcon.htm">TraySetIcon</a>, <a href="Variables.htm#IconTip">A_IconTip</a>, <a href="Variables.htm#IconHidden">A_IconHidden</a> und <a href="Variables.htm#AllowMainWindow">A_AllowMainWindow</a>)</li>
<li>MenuGetHandle (nutzen Sie stattdessen <a href="objects/Menu.htm#Handle">Menu.Handle</a>)</li>
<li>MenuGetName (es gibt keine Menünamen; <a href="commands/MenuFromHandle.htm">MenuFromHandle</a> ist der nächstliegende Ersatz)</li>
<li>Progress (nutzen Sie stattdessen <a href="objects/Gui.htm">Gui</a>)</li>
<li>SendRaw (nutzen Sie stattdessen <code>Send "{Raw}"</code> oder <a href="commands/Send.htm#SendText">SendText</a>)</li>
<li>SetBatchLines (-1 ist nun das Standardverhalten)</li>
<li>SetEnv</li>
<li>SetFormat (<a href="commands/Format.htm">Format</a> kann zum Formatieren einer Zeichenkette benutzt werden)</li>
<li>SoundGet/SoundSet (siehe <a href="#Sound">Sound-Funktionen</a>)</li>
<li>SoundGetWaveVolume/SoundSetWaveVolume (verhalten sich etwas anders als wie SoundGet/SoundSet in Bezug auf die Balance, aber keins von denen behält die Balance bei)</li>
<li>SplashImage (nutzen Sie stattdessen <a href="objects/Gui.htm">Gui</a>)</li>
<li>SplashTextOn/Off (nutzen Sie stattdessen <a href="objects/Gui.htm">Gui</a>)</li>
<li>StringCaseSense (nutzen Sie stattdessen entsprechende Parameter)</li>
<li>StringGetPos (nutzen Sie stattdessen <a href="commands/InStr.htm">InStr</a>)</li>
<li>StringLeft<br>
StringLen<br>
StringMid<br>
StringRight<br>
StringTrimLeft<br>
StringTrimRight -- nutzen Sie stattdessen <a href="commands/SubStr.htm">SubStr</a>.</li>
<li>StringReplace (nutzen Sie stattdessen <a href="commands/StrReplace.htm">StrReplace</a>)</li>
<li>StringSplit (nutzen Sie stattdessen <a href="commands/StrSplit.htm">StrSplit</a>)</li>
<li>Transform</li>
<li>VarSetCapacity (nutzen Sie stattdessen ein <a href="objects/Buffer.htm">Buffer</a>-Objekt für binäre Daten/Strukturen und <a href="commands/VarSetStrCapacity.htm">VarSetStrCapacity</a> für UTF-16-Zeichenketten)</li>
<li>WinGetActiveStats</li>
<li>WinGetActiveTitle</li>
<li>#CommentFlag</li>
<li>#Delimiter</li>
<li>#DerefChar</li>
<li>#EscapeChar</li>
<li>#HotkeyInterval (nutzen Sie stattdessen <a href="Variables.htm#HotkeyInterval">A_HotkeyInterval</a>)</li>
<li>#HotkeyModifierTimeout (nutzen Sie stattdessen <a href="misc/A_HotkeyModifierTimeout.htm">A_HotkeyModifierTimeout</a>)</li>
<li>#IfWinActive, #IfWinExist, #IfWinNotActive, #IfWinNotExist (siehe <a href="commands/_HotIf.htm#optimization">#HotIf-Optimierung</a>)</li>
<li>#InstallKeybdHook (nutzen Sie stattdessen die <a href="commands/InstallKeybdHook.htm">InstallKeybdHook</a>-Funktion)</li>
<li>#InstallMouseHook (nutzen Sie stattdessen die <a href="commands/InstallMouseHook.htm">InstallMouseHook</a>-Funktion)</li>
<li>#KeyHistory (nutzen Sie stattdessen <code>KeyHistory N</code>)</li>
<li>#LTrim</li>
<li>#MaxHotkeysPerInterval (nutzen Sie stattdessen <a href="misc/A_MaxHotkeysPerInterval.htm">A_MaxHotkeysPerInterval</a>)</li>
<li>#MaxMem (die maximale Kapazität jeder Variable ist nun unbegrenzt)</li>
<li>#MenuMaskKey (nutzen Sie stattdessen <a href="misc/A_MenuMaskKey.htm">A_MenuMaskKey</a>)</li>
<li>#NoEnv (gilt jetzt immer)</li>
</ul>
<p>Umbenannt:</p>
<ul>
<li>ComObjCreate() → <a href="commands/ComObject.htm">ComObject</a>, das nun eine Klasse ist</li>
<li>ComObjParameter() → <a href="commands/ComValue.htm">ComValue</a>, das nun eine Klasse ist</li>
<li>DriveSpaceFree → <a href="commands/DriveGetSpaceFree.htm">DriveGetSpaceFree</a></li>
<li>EnvAdd → <a href="commands/DateAdd.htm">DateAdd</a></li>
<li>EnvSub → <a href="commands/DateDiff.htm">DateDiff</a></li>
<li>FileCopyDir → <a href="commands/DirCopy.htm">DirCopy</a></li>
<li>FileCreateDir → <a href="commands/DirCreate.htm">DirCreate</a></li>
<li>FileMoveDir → <a href="commands/DirMove.htm">DirMove</a></li>
<li>FileRemoveDir → <a href="commands/DirDelete.htm">DirDelete</a></li>
<li>FileSelectFile → <a href="commands/FileSelect.htm">FileSelect</a></li>
<li>FileSelectFolder → <a href="commands/DirSelect.htm">DirSelect</a></li>
<li>#If → <a href="commands/_HotIf.htm">#HotIf</a></li>
<li>#IfTimeout → <a href="commands/_HotIfTimeout.htm">HotIfTimeout</a></li>
<li>StringLower → <a href="commands/StrLower.htm">StrLower</a> und <a href="commands/StrLower.htm">StrTitle</a></li>
<li>StringUpper → <a href="commands/StrLower.htm">StrUpper</a> und <a href="commands/StrLower.htm">StrTitle</a></li>
<li>UrlDownloadToFile → <a href="commands/Download.htm">Download</a></li>
<li>WinMenuSelectItem → <a href="commands/MenuSelect.htm">MenuSelect</a></li>
<li>LV-, TV- und SB-Funktionen → Methoden von <a href="objects/GuiControl.htm">GuiControl</a></li>
<li>File.__Handle → <a href="objects/File.htm#Handle">File.Handle</a></li>
</ul>
<h3 id="modified-commandsfunctions">Geänderte Befehle/Funktionen</h3>
<p class="note">Die Überschrift soll nicht suggerieren, dass es Befehle in v2 gibt. Es gibt nur Funktionen. Die Überschrift bezieht sich auf beide Versionen.</p>
<p><a href="commands/BlockInput.htm">BlockInput</a> wird nicht mehr kurzzeitig deaktiviert, wenn ein Alt-Ereignis mit der SendEvent-Methode gesendet wird. Ursprünglich war das notwendig, um einen Bug in einigen Versionen von Windows XP zu umgehen, der dazu führte, dass BlockInput das künstliche Alt-Ereignis blockierte.</p>
<p><code>Chr(0)</code> gibt eine Zeichenkette mit einer Länge von 1 zurück, weil eine binäre Null enthalten ist. Diese Änderung beruht auf der verbesserten Unterstützung für binäre Nullen in Zeichenketten.</p>
<p><a href="commands/ClipWait.htm">ClipWait</a> gibt nun 0 zurück, wenn die Wartezeit abgelaufen ist, ansonsten 1. ErrorLevel wurde entfernt. Eine 0 anzugeben ist nicht länger dasselbe wie, als würde man 0.5 angeben; stattdessen wird die kleinstmögliche Wartezeit erzeugt.</p>
<p><code>ComObj()</code>: Diese Funktion hatte eine Art Platzhalternamen, der viele verschiedene Suffixe zuließ. Einige Namen wurden häufiger mit bestimmten Arten von Parametern verwendet, z. B. <code>ComObjActive(CLSID)</code>, <code>ComObjParameter(vt, value)</code>, <code>ComObjEnwrap(dsp)</code>. Stattdessen gibt es jetzt separate Funktionen/Klassen und keine Platzhalter mehr. Weitere Informationen finden Sie unter <a href="#com-objects-comobject">COM-Objekte (ComObject)</a>.</p>
<p>Steuerelement-Parameter: Es wurden mehrere Änderungen am <a href="commands/Control.htm#Parameter"><em>Steuerelement</em>-Parameter</a> durchgeführt, der von den <a href="commands/Control.htm">Control-Funktionen</a>, <a href="commands/SendMessage.htm">SendMessage</a> und <a href="commands/PostMessage.htm">PostMessage</a> verwendet wird:</p>
<ul>
<li>Dieser akzeptiert nun eine HWND-Nummer (muss ein reiner Integer sein), oder ein Objekt mit einer <code>Hwnd</code>-Eigenschaft wie z. B. ein <a href="objects/GuiControl.htm">GuiControl</a>-Objekt. Die HWND-Nummer kann ein Steuerelement oder ein nicht-untergeordnetes Fenster identifizieren, obwohl letzteres in der Regel nur für einige wenige Funktionen sinnvoll ist (siehe unten).</li>
<li>Dieser Parameter ist nicht mehr optional, außer bei Funktionen, die mit einem nicht-untergeordneten Fenster agieren können (<a href="commands/ControlSend.htm">ControlSend[Text]</a>, <a href="commands/ControlClick.htm">ControlClick</a>, <a href="commands/SendMessage.htm">SendMessage</a>, <a href="commands/PostMessage.htm">PostMessage</a>) oder wenn andere optionale Parameter davor sind (<a href="commands/ListViewGetContent.htm">ListViewGetContent</a>, <a href="commands/ControlGetPos.htm">ControlGetPos</a>, <a href="commands/ControlMove.htm">ControlMove</a>).</li>
<li>Fehlt dieser Parameter, wird stattdessen das Zielfenster verwendet. Diese Änderung entspricht dem vorherigen Verhalten von <a href="commands/SendMessage.htm">SendMessage</a>/<a href="commands/PostMessage.htm">PostMessage</a> und ersetzt den von <a href="commands/ControlSend.htm">ControlSend</a> verwendeten speziellen Wert <code>ahk_parent</code>.</li>
<li>Leere Werte sind ungültig. Standardmäßig agieren solche Funktionen nie mit dem obersten Steuerelement des Zielfensters.</li>
</ul>
<p><a href="commands/ControlGetFocus.htm">ControlGetFocus</a> gibt nun die HWND-Nummer anstelle der ClassNN-Bezeichnung des Steuerelements zurück, und wertet es nicht mehr als Fehler, wenn es erfolgreich festgestellt hat, dass das Fenster kein fokussiertes Steuerelement aufweist.</p>
<p><a href="commands/ControlMove.htm">ControlMove</a>, <a href="commands/ControlGetPos.htm">ControlGetPos</a> und <a href="commands/ControlClick.htm">ControlClick</a> verwenden nun Clientkoordinaten (wie <a href="objects/GuiControl.htm">GuiControl</a>) statt Fensterkoordinaten. Clientkoordinaten sind relativ zur oberen linken Ecke des Clientbereichs (das ist der Bereich ohne Titelleiste und Rahmen). (Steuerelemente werden nur im Clientbereich gerendert.)</p>
<p>Die Parameterreihenfolge von <a href="commands/ControlMove.htm">ControlMove</a>, <a href="commands/ControlSend.htm">ControlSend</a> und <a href="commands/ControlSetText.htm">ControlSetText</a> ist nun im Einklang mit anderen Control-Funktionen; das heißt, dass <em><strong>Steuerelement</strong>, FensterTitel, FensterText, IgnoriereTitel, IgnoriereText</em> immer zusammen sind (am Ende der Parameterliste), um das Einprägen der Parameter zu fördern.</p>
<p><a href="commands/CoordMode.htm">CoordMode</a> akzeptiert nicht länger "Relative" als Modus, da alle Modi relativ zu etwas sind. Es war ein Synonym für "Window", also verwenden Sie stattdessen dieses Wort.</p>
<p><a href="commands/DllCall.htm">DllCall</a>: Siehe <a href="#dllcall">DllCall</a>-Abschnitt weiter unten.</p>
<p><a href="commands/Edit.htm">Edit</a> hatte früher ein Fallback-Verhalten für den Dateityp <code>.ini</code>, wenn das Shell-Verb "edit" nicht registriert war. Dies wurde entfernt, da Skriptdateien nicht mehr die Dateiendung <code>.ini</code> haben können. <code>AutoHotkey.ini</code> war der Standard-Skriptname in alten AutoHotkey-Versionen.</p>
<p><a href="commands/Edit.htm">Edit</a> unternimmt nichts mehr, wenn das Skript aus stdin gelesen wurde, anstatt zu versuchen, einen Editor für <code>*</code> zu öffnen.</p>
<p><a href="commands/EnvSet.htm">EnvSet</a> löscht nun die Umgebungsvariable, wenn der Wert-Parameter vollständig weggelassen wird.</p>
<p><a href="commands/Exit.htm">Exit</a> verhielt sich früher wie <a href="commands/ExitApp.htm">ExitApp</a>, wenn das Skript nicht persistent ist, selbst wenn es andere suspendierte Threads gab, die vom Thread, der Exit aufrief, unterbrochen wurden. Dies ist nun nicht mehr der Fall. Stattdessen wird es den aktuellen Thread immer ordnungsgemäß beenden, und das Skript erst terminiert (sofern nicht persistent), wenn der letzte Thread beendet wurde. Dadurch wird sichergestellt, dass <code>Finally</code>-Anweisungen ausgeführt und lokale Variablen freigegeben werden, was wiederum ermöglicht, dass <code>__Delete</code> für alle in lokalen Variablen enthaltenen Objekte aufgerufen werden kann.</p>
<p><a href="commands/FileAppend.htm">FileAppend</a> nutzt standardmäßig End-of-Line-Umwandlungen, um konsistent mit <a href="commands/FileRead.htm">FileRead</a> und <a href="commands/FileOpen.htm">FileOpen</a> zu sein. FileAppend und FileRead haben jeweils einen separaten <em>Optionen</em>-Parameter, der die Optionspräfixe ersetzt und optional einen Kodierungsnamen enthalten kann (um die <code>*Pnnn</code>-Option von FileRead abzulösen). FileAppend, FileRead und FileOpen benutzen <code>"`n"</code>, um End-of-Line-Umwandlungen zu aktivieren. FileAppend und FileRead unterstützen die Option <code>"RAW"</code>, um die Zeichensatzkonvertierung zu deaktivieren (Lesen/Schreiben von binären Daten); FileRead gibt in diesem Fall ein <code>Buffer</code>-Objekt zurück. Diese Option ersetzt <code>*c</code> (siehe ClipboardAll). FileAppend kann ein <code>Buffer</code>-ähnliches Objekt akzeptieren, in diesem Fall werden keine Konvertierungen durchgeführt.</p>
<p><a href="commands/FileCopy.htm">FileCopy</a> und <a href="commands/FileMove.htm">FileMove</a> lösen jetzt eine Ausnahme aus, wenn der Quellpfad nicht <code>*</code> oder <code>?</code> enthält und keine Datei gefunden wurde. Es wird jedoch immer noch nicht als Fehler behandelt, null Dateien zu kopieren oder zu verschieben, wenn der Quellpfad Platzhalterzeichen enthält.</p>
<p><a href="commands/FileOpen.htm">FileOpen</a> löst jetzt eine Ausnahme aus, wenn es die Datei nicht öffnen kann. Ansonsten würde eine Ausnahme (wenn das Skript nicht auf Misserfolg prüft) bereits beim ersten Zugriffsversuch auf das Objekt ausgelöst werden und nicht erst am eigentlichen Misserfolgspunkt.</p>
<p><a href="objects/File.htm#RawRead">File.RawRead</a>: Übergibt man eine Variable direkt, wird die Adresse des internen Zeichenkettenpuffers der Variable nicht länger verwendet. Daher kann eine Variable, die eine Adresse enthält, direkt übergeben werden (während in v1 so etwas wie <code>var+0</code> notwendig war).</p>
<p>Für Puffer, die vom Skript reserviert werden, wird das neue <code>Buffer</code>-Objekt gegenüber einer Variable bevorzugt; es kann ein beliebiges Objekt verwendet werden, solange es über die Eigenschaften <code>Ptr</code> und <code>Size</code> verfügt.</p>
<p><a href="objects/File.htm#RawWrite">File.RawWrite</a>: Wie oben, außer dass es eine Zeichenkette (oder eine Variable mit einer Zeichenkette) akzeptieren kann - in diesem Fall ist <em>Bytes</em> standardmäßig die Größe der Zeichenkette in Bytes. Die Zeichenkette kann binäre Nullen enthalten.</p>
<p><a href="objects/File.htm#ReadLine">File.ReadLine</a> unterstützt nun immer <code>`r</code>, <code>`n</code> und <code>`r`n</code> als Zeilenenden und fügt das Zeilenende nicht länger in den Rückgabewert ein. Zeilenenden werden weiterhin unverändert via <a href="objects/File.htm#Read">File.Read</a> an das Skript zurückgegeben, wenn die EOL-Umwandlung deaktiviert ist.</p>
<p><a href="commands/FileEncoding.htm">FileEncoding</a> ermöglicht nun die Angabe von Zeichensätzen via Nummer, ohne dass das Präfix <code>CP</code> notwendig ist. Der Parameter ist nicht mehr optional, kann aber weiterhin explizit leer sein.</p>
<p><a href="commands/FileExist.htm">FileExist</a> ignoriert nun <code>.</code> und <code>..</code>, das in jeder Verzeichnisliste vorkommt, demzufolge ist <code>FileExist("dir\*")</code> nun False statt True, wenn das Verzeichnis existiert aber leer ist.</p>
<p><a href="commands/FileGetAttrib.htm">FileGetAttrib</a> und A_LoopFileAttrib nutzen jetzt den Buchstaben "L" für Analysepunkte oder symbolische Verknüpfungen.</p>
<p><a href="commands/FileInstall.htm">FileInstall</a> in einem unkompilierten Skript versucht nicht länger, die Datei zu kopieren, wenn Quelle und Ziel der gleiche Pfad sind (nach dem Auflösen relativer Pfade, da die Quelle relativ zu <a href="Variables.htm#ScriptDir">A_ScriptDir</a> ist, nicht zu <a href="Variables.htm#WorkingDir">A_WorkingDir</a>). In v1 führte dies dazu, dass ErrorLevel auf 1 gesetzt wurde, was meist unbemerkt blieb. Der Versuch, eine Datei mittels zwei verschiedener Pfade auf sich selbst zu kopieren, löst weiterhin einen Fehler aus.</p>
<p>FileSelectFile (jetzt unter dem Namen <a href="commands/FileSelect.htm">FileSelect</a> bekannt) hatte zwei Mehrfachauswahl-Modi, die über Option 4 und M erreichbar waren. Option 4 und der entsprechende Modus wurden entfernt; sie waren eine lange Zeit nicht in der Doku erwähnt. FileSelect gibt jetzt, wenn der Mehrfachauswahlmodus verwendet wird, ein Array mit Pfaden anstelle einer Zeichenkette wie <code>C:\Verz`nDatei1`nDatei2</code> zurück. Jedes Array-Element enthält den vollständigen Pfad einer Datei. Wenn der Benutzer das Dialogfenster abbricht, ist das Array leer.</p>
<p>FileSelect verwendet jetzt die seit Windows Vista verfügbare IFileDialog-API anstelle der alten GetOpenFileName/GetSaveFileName-API. Dadurch entfällt die Notwendigkeit von (internen) Workarounds in Bezug auf das Dialogfenster, welches das aktuelle Arbeitsverzeichnis ändert.</p>
<p>FileSelect hat nicht länger standardmäßig den redundanten Filter "Text Documents (*.txt)", wenn <em>Filter</em> weggelassen wird.</p>
<p>FileSelect entfernt nicht länger Leerzeichen vom Filtermuster, wie z. B. bei <code>Muster mit Leerzeichen*.ext</code>. Tests zufolge werden Leerzeichen auf beiden Seiten des Musters (z. B. nach dem Semikolon in <code>*.cpp; *.h</code>) bereits vom Betriebssystem ignoriert, so dass es keine negativen Konsequenzen geben sollte.</p>
<p>FileSelect kann jetzt im "Ordner auswählen"-Modus über den Optionsbuchstaben <code>D</code> verwendet werden.</p>
<p><a href="commands/FileSetAttrib.htm">FileSetAttrib</a> überschreibt ab sofort Attribute, wenn kein +, - oder ^ als Präfix vorhanden ist, anstatt nichts zu tun. Zum Beispiel würde <code>FileSetAttrib(FileGetAttrib(Datei2), Datei1)</code> die Attribute von Datei2 nach Datei1 kopieren (fügt alles hinzu, das Datei2 hat, und entfernt alles, das es nicht hat).</p>
<p><a href="commands/FileSetAttrib.htm">FileSetAttrib</a> und <a href="commands/FileSetTime.htm">FileSetTime</a>: Die Parameter <em>OrdnerEinbeziehen?</em> und <em>Rekursiv?</em> wurden mit einem einzelnen Parameter namens <em>Modus</em> ersetzt, der mit dem von <a href="commands/LoopFiles.htm">Loop Files</a> identisch ist. Zum Beispiel <code>FileSetAttrib("+a", "*.zip", "RF")</code> (nur Dateien rekursiv abarbeiten).</p>
<p><a href="commands/GetKeyName.htm">GetKeyName</a> gibt jetzt die Nicht-Ziffernblock-Namen für VK-Codes zurück, die sowohl einer Ziffernblock- als auch einer Nicht-Ziffernblock-Taste entsprechen. <code>GetKeyName("vk25")</code> beispielsweise gibt Left anstelle von NumpadLeft zurück.</p>
<p><a href="commands/GetKeyState.htm">GetKeyState</a> gibt nun immer 0 oder 1 zurück.</p>
<p><a href="commands/GroupActivate.htm">GroupActivate</a> gibt nun die HWND-Nummer des Fensters zurück, das zur Aktivierung ausgewählt wurde, oder 0, wenn keine Übereinstimmungen gefunden wurden (mit Ausnahme des bereits aktiven Fensters), anstatt ErrorLevel zu setzen.</p>
<p><a href="commands/GroupAdd.htm">GroupAdd</a>: Der <em>Label</em>-Parameter und ähnliche Funktionalitäten wurden entfernt. Diese nicht sehr intuitive Methode war eine Möglichkeit, um festzustellen, ob GroupActivate passende Fenster finden konnte; stattdessen sollte der Rückgabewert von GroupActivate verwendet werden.</p>
<p><a href="commands/GroupDeactivate.htm">GroupDeactivate</a> wählt jetzt Fenster in einer Weise aus, die eher den System-Hotkeys <kbd>Alt</kbd>+<kbd>Esc</kbd> und <kbd>Alt</kbd>+<kbd>Umschalt</kbd>+<kbd>Esc</kbd> sowie der Taskleiste entspricht. Konkret heißt das:</p>
<ul>
<li>Untergeordnete Fenster werden nicht evaluiert. Wenn das nicht-untergeordnete Fenster geeignet ist (keine Übereinstimmung für die Gruppe ist), wird entweder das nicht-untergeordnete Fenster oder eines seiner untergeordneten Fenster aktiviert, je nachdem, welches zuletzt aktiv war. Ein Fenster, das einem Gruppenmitglied untergeordnet ist, wird nicht länger aktiviert, aber das Hinzufügen des untergeordneten Fensters selbst zur Gruppe hat jetzt keine Wirkung mehr. (Das frühere Verhalten bestand darin, jedes untergeordnete Fenster durchzugehen und niemals dessen übergeordnetes Fenster zu aktivieren.)</li>
<li>Jedes deaktivierte Fenster wird übersprungen, es sei denn, eines seiner untergeordneten Fenster war in jüngerer Zeit aktiv als es selbst.</li>
<li>Fenster mit dem WS_EX_NOACTIVATE-Style werden übersprungen, da sie wahrscheinlich nicht aktiviert werden sollten. Sie werden auch von den System-Hotkeys <kbd>Alt</kbd>+<kbd>Esc</kbd> und <kbd>Alt</kbd>+<kbd>Umschalt</kbd>+<kbd>Esc</kbd> übersprungen.</li>
<li>Fenster mit dem WS_EX_NOACTIVATE-Style, aber nicht mit dem WS_EX_APPWINDOW-Style, werden in der Taskleiste und in Alt-Tab ausgelassen und daher übersprungen.</li>
</ul>
<p><a href="commands/Hotkey.htm">Hotkey</a> benutzt nicht länger standardmäßig das <a href="commands/_HotIf.htm">#HotIf</a> (ehemals #If) ganz unten im Skript. Hotkey/Hotstring- und HotIf-Threads benutzen standardmäßig dasselbe Kriterium wie der Hotkey, demzufolge würde <code>Hotkey A_ThisHotkey, "Off"</code> den aktuellen Hotkey deaktivieren, auch dann, wenn er kontextabhängig wäre. Alle anderen Threads benutzen standardmäßig die zuletzt im automatischen Ausführungsbereich definierte Einstellung, die selbst standardmäßig auf kein Kriterium gesetzt ist (globale Hotkeys).</p>
<p>Der <em>Callback</em>-Parameter von <a href="commands/Hotkey.htm">Hotkey</a> benötigt nun ein Funktionsobjekt oder den Namen eines Hotkeys. Labels und Funktionsnamen werden nicht länger unterstützt. Wenn der Name eines Hotkeys angegeben ist, wird die ursprüngliche Funktion dieses Hotkeys verwendet; und im Gegensatz zu früher funktioniert dies mit <a href="commands/_HotIf.htm">#HotIf</a> (ehemals #If).</p>
<ul>
<li>Neben anderen Vorteilen beseitigt dies die Mehrdeutigkeit mit folgenden speziellen Zeichenketten: <code>On</code>, <code>Off</code>, <code>Toggle</code>, <code>AltTab</code>, <code>ShiftAltTab</code>, <code>AltTabAndMenu</code>, <code>AltTabMenuDismiss</code>. Früher war es so, dass das Label oder die Funktion mit diesem Namen verwendet wurde, sofern vorhanden, aber nur, wenn der <em>Label</em>-Parameter weder eine Variablenreferenz noch einen Ausdruck enthielt.</li>
</ul>
<p><a href="commands/Hotkey.htm">Hotkey</a> und <a href="commands/Hotstring.htm">Hotstring</a> unterstützen jetzt die S-Option, um den Hotkey/Hotstring vor <a href="commands/Suspend.htm">Suspend</a> zu schützen (entspricht der neuen Direktive <a href="commands/_SuspendExempt.htm">#SuspendExempt</a>), und die S0-Option, um den Schutz zu deaktivieren.</p>
<p>"Hotkey If" und die anderen If-Unterbefehle wurden in einzelne Funktionen aufgeteilt: <a href="commands/HotIf.htm">HotIf, HotIfWinActive, HotIfWinExist, HotIfWinNotActive, HotIfWinNotExist</a>.</p>
<p><a href="commands/HotIf.htm">HotIf</a> (ehemals "Hotkey If") erkennt nun Ausdrücke, die die Operatoren <code>and</code> oder <code>or</code> benutzen. In v1 hat das nicht funktioniert, weil solche Operatoren während der Ladezeit mit <code>&amp;&amp;</code> oder <code>||</code> ersetzt wurden.</p>
<p><a href="commands/Hotkey.htm">Hotkey</a> hat nicht länger die Option <code>UseErrorLevel</code>, und wird niemals ErrorLevel setzen. Bei Misserfolg wird eine Ausnahme ausgelöst. Die Fehlermeldungen wurden geändert, um konstant (und kürzer) zu sein, mit der Taste oder dem Namen des Hotkeys in <code>Exception.Extra</code>, und mit der Klasse der Ausnahme, die den Grund für den Fehler angibt.</p>
<p><a href="commands/_HotIf.htm">#HotIf</a> (ehemals #If) erzeugt jetzt implizit eine Funktion mit einem Parameter (ThisHotkey). Wie alle Funktionen ist auch diese Funktion standardmäßig eine Assume-Local-Funktion. Der Ausdruck kann lokale Variablen erstellen und globale Variablen lesen, aber globalen Variablen nicht direkt etwas zuweisen, da der Ausdruck keine Deklarationen enthalten kann.</p>
<p><a href="commands/_HotIf.htm">#HotIf</a> wurde so optimiert, dass einfache Aufrufe von <a href="commands/WinActive.htm">WinActive</a> oder <a href="commands/WinExist.htm">WinExist</a> direkt vom Hook-Thread ausgewertet werden können (wie es bei #IfWin in v1 der Fall war, und bei <a href="commands/HotIf.htm">HotIfWin</a> noch der Fall ist). Dies verbessert die Leistung und reduziert das Risiko von Problemen, wenn das Skript beschäftigt ist oder nicht reagiert. Diese Optimierung gilt für Ausdrücke, die einen einzelnen Aufruf von <a href="commands/WinActive.htm">WinActive</a> oder <a href="commands/WinExist.htm">WinExist</a> mit bis zu zwei Parametern enthalten, wo jeder Parameter eine einfache in Anführungszeichen gesetzte Zeichenkette ist und das Ergebnis optional mit <code>!</code> oder <code>not</code> invertiert wird. Zum Beispiel <code>#HotIf WinActive("Chrome")</code> oder <code>#HotIf !WinExist("Popup")</code>. In solchen Fällen kann der erste Ausdruck mit einer beliebigen Kombination von Kriterien entweder via Ausdruck oder via Fensterkriterien identifiziert werden. Zum Beispiel verweisen <code>HotIf '!WinExist("Popup")'</code> und <code>HotIfWinNotExist "Popup"</code> auf dieselben Hotkey-Varianten.</p>
<p><code>KeyHistory N</code> ändert die Größe des Tastenverlaufspuffers, anstatt den Tastenverlauf anzuzeigen. Dies ersetzt "#KeyHistory N".</p>
<p><a href="commands/ImageSearch.htm">ImageSearch</a> gibt 1 (true) zurück, wenn das Bild im angegebenen Bereich gefunden wurde, oder 0 (false), wenn es nicht gefunden wurde, oder löst eine Ausnahme aus, wenn die Suche nicht durchgeführt werden konnte. ErrorLevel wird nicht gesetzt.</p>
<p><a href="commands/IniDelete.htm">IniDelete</a>, <a href="commands/IniRead.htm">IniRead</a> und <a href="commands/IniWrite.htm">IniWrite</a> setzen <a href="Variables.htm#LastError">A_LastError</a> auf das Ergebnis der Systemfunktion GetLastError().</p>
<p><a href="commands/IniRead.htm">IniRead</a> löst eine Ausnahme aus, wenn es einen Schlüssel, eine Sektion oder eine Datei anfordert, der bzw. die nicht gefunden werden kann, und der <em>Standardwert</em>-Parameter weggelassen wurde. Hat man für <em>Standardwert</em> einen Wert angegeben, sogar <code>""</code>, wird keine Ausnahme ausgelöst.</p>
<p><a href="commands/InputHook.htm">InputHook</a> behandelt nun <kbd>Umschalt</kbd>+<kbd>Backspace</kbd> wie <kbd>Backspace</kbd>, anstatt es in <code>`b</code> zu übersetzen.</p>
<p><a href="commands/InputBox.htm">InputBox</a> wurde syntaktisch überarbeitet, um die Benutzerfreundlichkeit zu verbessern (weniger Parameter). Informationen zur Verwendung finden Sie unter <a href="#inputbox">InputBox</a>.</p>
<p><a href="commands/InStr.htm">InStr</a>-Parameter <em><em>GroßKleinSensitiv</em></em> wurde geändert und akzeptiert jetzt 0, 1 oder "Locale".</p>
<p>InStr sucht jetzt von rechts nach links, wenn <em>Vorkommen</em> negativ ist (was vorher ein Ergebnis von 0 verursachte), und sucht nicht mehr von rechts nach links, wenn eine negative <em>StartPos</em> mit einem positiven <em>Vorkommen</em> verwendet wird. (Es wird jedoch weiterhin von rechts nach links gesucht, wenn <em>StartPos</em> negativ ist und <em>Vorkommen</em> weggelassen wird.) Dies erleichtert die Suche von rechts nach links in einer Schleife und ermöglicht es, eine negative <em>StartPos</em> zu verwenden und trotzdem von links nach rechts zu suchen.</p>
<ul>
<li>Zum Beispiel sucht <code>InStr(a, b,, -1, 2)</code> jetzt von links nach rechts. Um stattdessen von rechts nach links zu suchen, verwenden Sie <code>InStr(a, b,, -1, -2)</code>.</li>
<li>Beachten Sie, dass eine <em>StartPos</em> von -1 in AutoHotkey v2 das letzte Zeichen und in AutoHotkey v1 das vorletzte Zeichen repräsentiert. Wenn das obige Beispiel aus v1 stammt (und nicht aus v2.0-a033 - v2.0-a136), sollte der neue Code <code>InStr(a, b, -2, -2)</code> sein.</li>
</ul>
<p><a href="commands/KeyWait.htm">KeyWait</a> gibt nun 0 zurück, wenn die Wartezeit abgelaufen ist, ansonsten 1. ErrorLevel wurde entfernt.</p>
<p><a href="commands/MouseClick.htm">MouseClick</a> und <a href="commands/MouseClickDrag.htm">MouseClickDrag</a> sind nicht mehr von der Systemeinstellung zum Vertauschen der Maustasten betroffen; "Left" ist immer die primäre Taste und "Right" immer die sekundäre.</p>
<p><a href="commands/MsgBox.htm">MsgBox</a> wurde syntaktisch geändert, um die häufig benutzten Parameter zu priorisieren und die Benutzerfreundlichkeit zu verbessern. Informationen zur Verwendung finden Sie unter <a href="#msgbox">MsgBox</a> weiter unten.</p>
<p><a href="commands/NumPut.htm">NumPut</a>/<a href="commands/NumGet.htm">NumGet</a>: Übergibt man eine Variable direkt, wird die Adresse des internen Zeichenkettenpuffers der Variable nicht länger verwendet. Daher kann eine Variable, die eine Adresse enthält, direkt übergeben werden (während in v1 so etwas wie <code>var+0</code> notwendig war). Für Puffer, die vom Skript reserviert werden, wird das neue <code>Buffer</code>-Objekt gegenüber einer Variable bevorzugt; es kann ein beliebiges Objekt verwendet werden, solange es über die Eigenschaften <code>Ptr</code> und <code>Size</code> verfügt.</p>
<p>Die Parameter von NumPut wurden neu angeordnet, um die Angabe einer Sequenz von Werten zu ermöglichen, jeweils mit ihren entsprechenden (jetzt zwingend notwendigen) Typen davor. Zum Beispiel: <code>NumPut("ptr", a, "int", b, "int", c, addrOrBuffer, offset)</code>. Typ ist jetzt auch für NumGet zwingend notwendig. (Im Vergleich zu DllCall entsprechen die Eingabeparameter von NumPut den Parametern der DLL-Funktion, während der Rückgabetypparameter von NumGet der Rückgabetypzeichenkette der DLL-Funktion entspricht.)</p>
<p>Der Gebrauch von <code>Object(obj)</code> und <code>Object(ptr)</code>, um zwischen einer Referenz und einem Pointer zu konvertieren, wurde auf separate Funktionen, <code>ObjPtrAddRef(obj)</code> und <code>ObjFromPtrAddRef(ptr)</code>, verlagert. Es gibt auch Versionen von diesen Funktionen, die die Referenzanzahl nicht inkrementieren:  <code>ObjPtr(obj)</code> und <code>ObjFromPtr(ptr)</code>.</p>
<p>Das OnClipboardChange-Label wird nicht mehr automatisch aufgerufen, wenn es vorhanden ist. Benutzen Sie stattdessen die <a href="commands/OnClipboardChange.htm">OnClipboardChange</a>-Funktion, die es seit v1.1.20 gibt. Sie benötigt nun ein Funktionsobjekt, keinen Namen.</p>
<p><a href="commands/OnError.htm">OnError</a> benötigt nun ein Funktionsobjekt, keinen Namen. Siehe auch <a href="#error-handling">Fehlerbehandlung</a> weiter unten.</p>
<p>Der OnExit-Befehl wurde entfernt; benutzen Sie stattdessen die <a href="commands/OnExit.htm">OnExit</a>-Funktion, die es seit v1.1.20 gibt. Sie benötigt nun ein Funktionsobjekt, keinen Namen. A_ExitReason wurde ebenfalls entfernt; dessen Wert erhält man jetzt über einen Parameter der OnExit-Callback-Funktion.</p>
<p><a href="commands/OnMessage.htm">OnMessage</a> hat nicht mehr den Eine-Funktion-pro-Meldung-Modus, der verwendet wurde, wenn ein Funktionsname (Zeichenkette) übergeben wurde; es akzeptiert jetzt nur noch eine Funktion per Referenz. Verwenden Sie <code>OnMessage(x, MeineFunk)</code>, wobei <em>MeineFunk</em> der Name einer Funktion ist (ohne Anführungszeichen), aber beachten Sie, dass das v1-Äquivalent <code>OnMessage(x, Func("MeineFunk"))</code> wäre, das im Gegensatz zu <code>OnMessage(x, "MeineFunk")</code> anderen Funktionen erlaubt, die Meldung x weiter zu überwachen. Um die Überwachung der Meldung zu beenden, verwenden Sie <code>OnMessage(x, MeineFunk, 0)</code>, da <code>OnMessage(x, "")</code> und <code>OnMessage(x)</code> nun Fehler sind. Bei Misserfolg wird OnMessage eine Ausnahme auslösen.</p>
<p><a href="commands/Pause.htm">Pause</a> wird nicht länger von <a href="commands/_MaxThreadsPerHotkey.htm">#MaxThreadsPerHotkey</a> ausgenommen, wenn es auf der ersten Zeile eines Hotkeys verwendet wird, daher eignet sich <code>#p::Pause</code> nicht mehr zum Umschalten der Pause. Daher wird <code>Pause()</code> jetzt nur noch den aktuellen Thread pausieren (für Kombinationen wie ListVars/Pause), während <code>Pause(v)</code> jetzt immer mit dem darunterliegenden Thread agiert. <code>v</code> muss 0, 1 oder -1 sein. Der zweite Parameter wurde entfernt.</p>
<p><a href="commands/PixelSearch.htm">PixelSearch</a> und <a href="commands/PixelGetColor.htm">PixelGetColor</a> nutzen RGB- statt BGR-Farbwerte, um konsistent mit anderen Funktionen zu sein. Beide Funktionen lösen eine Ausnahme aus, wenn ein Problem auftritt, und setzen keinen ErrorLevel mehr. PixelSearch gibt 1 (true) zurück, wenn die Farbe gefunden wurde. Der Slow-Modus von PixelSearch wurde entfernt, da er auf den meisten modernen Systemen aufgrund einer Inkompatibilität mit der Desktopgestaltung unbrauchbar ist.</p>
<p><a href="commands/PostMessage.htm">PostMessage</a>: Siehe <a href="#SendMessage">SendMessage</a> weiter unten.</p>
<p><a href="commands/Random.htm">Random</a> wurde überarbeitet, um den Zufallszahlengenerator des Betriebssystems zu nutzen, einige Beschränkungen zu beseitigen und die Verwendung zu vereinfachen.</p>
<ul>
<li>Es wird nun der volle 64-Bit-Bereich von vorzeichenbehafteten Integer-Werten unterstützt (früher war es 32-Bit).</li>
<li>Floating-Point-Zahlen werden auf Basis eines zufälligen 53-Bit-Integers anstelle eines zufälligen 32-Bit-Integers generiert und sollten größer gleich Min und kleiner als Max sein (aber Floating-Point-Rundungsfehler können theoretisch dazu führen, dass sie gleich Max sind).</li>
<li>Die Parameter konnten bereits in beliebiger Reihenfolge angegeben werden, aber jetzt wird, wenn man nur den ersten Parameter angibt, die andere Grenze auf 0 anstelle von 2147483647 gesetzt. <code>Random(9)</code> beispielsweise gibt eine Zahl zwischen 0 und 9 zurück.</li>
<li>Wenn beide Parameter weggelassen werden, ist der Rückgabewert eine Floating-Point-Zahl im Bereich von 0.0 bis 1.0 (wobei 1.0 nahezu nie erreicht wird), anstelle eines Integers im Bereich von 0 bis 2147483647.</li>
<li>Das System setzt den Zufallszahlengenerator automatisch und bietet keine Möglichkeit, ihn manuell zu seeden, daher gibt es keinen Ersatz für den <em>NeuerStartwert</em>-Parameter.</li>
</ul>
<p>Die <a href="commands/RegExMatch.htm">RegExMatch</a>-Optionen O und P wurden entfernt; der O-Modus (Objekt) ist nun fest integriert. Das RegExMatch-Objekt unterstützt nun die Enumeration (For-Schleife). Die Syntax des Match-Objekts hat sich geändert:</p>
<ul>
<li>__Get wird verwendet, um die Kurzsyntax <code>Match.TeilMust</code> zu implementieren, wobei <em>TeilMust</em> der Name eines Teilsuchmusters (erfassten Gruppe) ist. Da __Get nicht mehr aufgerufen wird, wenn eine Eigenschaft <em>geerbt</em> wird, können die folgenden Teilsuchmusternamen nicht mehr mit der Kurzsyntax verwendet werden: Pos, Len, Name, Count, Mark. (Zum Beispiel gibt <code>Match.Len</code> immer die Länge der gesamten Übereinstimmung zurück, nicht eine erfasste Zeichenkette.)</li>
<li>Ursprünglich hatte das Match-Objekt Methoden anstelle von Eigenschaften, so dass Eigenschaften für Teilsuchmusternamen reserviert werden konnten. Da das neue Sprachverhalten impliziert, dass <code>Match.Name</code> standardmäßig eine Funktion zurückgeben würde, wurden die Methoden mit Eigenschaften ersetzt oder ergänzt:
<ul>
<li>Pos, Len und Name sind jetzt Eigenschaften und Methoden.</li>
<li>Name benötigt jetzt 1 Parameter, um Verwirrung zu vermeiden (<code>Match.Name</code> löst einen Fehler aus).</li>
<li>Count und Mark sind jetzt nur noch Eigenschaften.</li>
<li>Value wurde entfernt; nutzen Sie <code>Match.0</code> oder <code>Match[]</code> anstelle von <code>Match.Value()</code>, und <code>Match[N]</code> anstelle von <code>Match.Value(N)</code>.</li>
</ul>
</li>
</ul>
<p>RegisterCallback wurde in <a href="commands/CallbackCreate.htm">CallbackCreate</a> umbenannt und zugunsten für Closures verbessert:</p>
<ul>
<li>Es unterstützt jetzt <a href="objects/Functor.htm">Funktionsobjekte</a> (und keine Funktionsnamen mehr).</li>
<li>EventInfo-Parameter entfernt (nutzen Sie stattdessen ein Closure oder eine Bound-Funktion).</li>
<li>Das spezielle Verhalten von variadischen Callback-Funktionen wurde entfernt und die <code>&amp;</code>-Option hinzugefügt (Adresse der Parameterliste übergeben).</li>
<li><code>CallbackFree(Adresse)</code> hinzugefügt, um den Callback-Speicher freizugeben und das dazugehörige Funktionsobjekt freizugeben.</li>
</ul>
<p>Registry-Funktionen (<a href="commands/RegRead.htm">RegRead</a>, <a href="commands/RegWrite.htm">RegWrite</a>, <a href="commands/RegDelete.htm">RegDelete</a>): Die in v1.1.21 eingeführte Syntax ist nun die einzige Syntax. RootSchlüssel und UnterSchlüssel wurden zusammengefasst. Schreiben Sie <code>RootSchlüssel\Schlüssel</code> statt <code>RootSchlüssel, Schlüssel</code>. Um eine Verbindung zu einer Remote-Registry aufzubauen, muss <code>\\ComputerName\RootSchlüssel\Schlüssel</code> statt <code>\\ComputerName:RootSchlüssel, Schlüssel</code> benutzt werden.</p>
<p>Die Parameter von RegWrite wurden neu angeordnet, so dass <em>Wert</em> der erste Parameter ist, wie bei IniWrite (aber dies hat keinen Einfluss auf den Einzelparametermodus, wo <em>Wert</em> der einzige Parameter war).</p>
<p>Wenn <em>SchlüsselName</em> fehlt und das aktuelle Element einer Registry-Schleife ein Unterschlüssel ist, wird RegDelete, RegRead und RegWrite nun Werte innerhalb dieses Unterschlüssels abarbeiten; das heißt, dass <em>SchlüsselName</em> in diesem Fall standardmäßig <code>A_LoopRegKey "\" A_LoopRegName</code> ist (beachten Sie, dass A_LoopRegKey und A_LoopRegSubKey zusammengefasst worden sind). Früher verhielten sie sich wie folgt:</p>
<ul>
<li>RegRead las einen Wert mit dem gleichen Namen wie der Unterschlüssel, wenn einer im übergeordneten Schlüssel vorhanden war.</li>
<li>RegWrite gab einen Fehler zurück.</li>
<li>RegDelete löschte den Unterschlüssel.</li>
</ul>
<p>RegDelete, RegRead und RegWrite erlauben nun die Angabe von <em>WertName</em> ohne <em>SchlüsselName</em>:</p>
<ul>
<li>Wenn das aktuelle Element einer Registry-Schleife ein Unterschlüssel ist, gilt für <em>WertName</em> standardmäßig leer (der Standardwert des Unterschlüssels), außerdem muss <em>WertTyp</em> angegeben werden.</li>
<li>Wenn das aktuelle Element einer Registry-Schleife ein Wert ist, gilt für <em>WertName</em> und <em>WertTyp</em> standardmäßig der Name und Typ des Wertes, die einzeln oder beide überschrieben werden können.</li>
</ul>
<p>Ansonsten wird RegDelete mit leerem oder fehlendem <em>WertName</em> den Standardwert des Schlüssels (nicht den Schlüssel selbst) nun löschen, um konsistent mit RegWrite, RegRead und A_LoopRegName zu sein. Das Schlüsselwort "AHK_DEFAULT" hat keine besondere Bedeutung mehr. Mit <a href="commands/RegDeleteKey.htm">RegDeleteKey</a> (neu) kann ein Schlüssel gelöscht werden.</p>
<p><a href="commands/RegRead.htm">RegRead</a> hat wie IniRead jetzt einen <em>Standardwert</em>-Parameter.</p>
<p>RegRead hatte einen undokumentierten 5-Parameter-Modus, wo man den Werttyp nach der Ausgabevariable angeben konnte. Dieser wurde entfernt.</p>
<p><a href="commands/Reload.htm">Reload</a> unternimmt nichts mehr, wenn das Skript aus stdin gelesen wurde.</p>
<p><a href="commands/Run.htm">Run</a> und <a href="commands/Run.htm">RunWait</a> ignorieren ab sofort die <code>UseErrorLevel</code>-Option, da ErrorLevel entfernt wurde. Verwenden Sie stattdessen Try/Catch. <a href="Variables.htm#LastError">A_LastError</a> wird bedingungslos gesetzt und kann nach dem Abfangen/Unterdrücken einer Ausnahme überprüft werden. RunWait gibt den Exitcode zurück.</p>
<p><a href="commands/Send.htm">Send</a> (und dessen Varianten) interpretieren jetzt <code>{LButton}</code> und <code>{RButton}</code> auf eine Weise, die mit Hotkeys und <a href="commands/Click.htm">Click</a> konsistent ist. Das heißt, dass LButton die primäre Taste und RButton die sekundäre Taste ist, auch wenn der Benutzer die Maustasten via Systemsteuerung vertauscht hat.</p>
<p id="SendMessage">Die wParam- und lParam-Parameter von <a href="commands/SendMessage.htm">SendMessage</a> und <a href="commands/PostMessage.htm">PostMessage</a> müssen nun Integer oder Objekte mit einer Ptr-Eigenschaft sein; es wird eine Ausnahme ausgelöst, wenn ihnen eine nicht-numerische Zeichenkette oder Floating-Point-Zahl zugewiesen wird. Früher wurde eine Zeichenkette via Adresse übergeben, wenn der Ausdruck mit <code>"</code> begann, aber andere Zeichenketten wurden zwangsweise in Integern umgewandelt. Die Adresse einer Variable (ehemals <code>&amp;var</code>, nun <code>StrPtr(var)</code>) zu übergeben, aktualisiert nicht länger die Länge der Variable (nutzen Sie stattdessen <code>VarSetStrCapacity(&amp;var, -1)</code>).</p>
<p>SendMessage und PostMessage lösen jetzt bei Misserfolg (oder Zeitüberschreitung) eine Ausnahme aus und setzen nicht länger ErrorLevel. SendMessage gibt die Antwort der Meldung zurück.</p>
<p><a href="commands/SetTimer.htm">SetTimer</a> unterstützt nicht länger Label- oder Funktionsnamen, aber da es jetzt einen Ausdruck akzeptiert und Funktionen direkt per Name referenziert werden können, sieht die Verwendung sehr ähnlich aus: <code>SetTimer MeineFunk</code>. Wie es bei allen Funktionen, die ein Objekt akzeptieren, der Fall ist, erlaubt SetTimer jetzt Ausdrücke, die ein Objekt zurückgeben (zuvor war eine Variablenreferenz erforderlich).</p>
<p><a href="commands/Sort.htm">Sort</a> hat die folgenden Änderungen erhalten:</p>
<ul>
<li>Der <em>VarName</em>-Parameter wurde aus Flexibilitätsgründen in einzelne Eingabe-/Ausgabeparameter aufgeteilt. Sort wird jetzt wie folgt genutzt: <code>Ausgabe := Sort(Eingabe [, Optionen, Funktion])</code>.</li>
<li>Wenn zwei Elemente gleich sind, wird jetzt automatisch die ursprüngliche Reihenfolge der Elemente als Tie-Breaker verwendet, um stabilere Ergebnisse zu gewährleisten.</li>
<li>Die <code>C</code>-Option akzeptiert jetzt auch ein Suffix, das dem <em>GroßKleinSensitiv</em>-Parameter anderer Funktionen entspricht (zusätzlich zu <code>CL</code>): <code>CLocale CLogical COn C1 COff C0</code>. Neu ist vor allem die Unterstützung des "logischen" Vergleichsmodus.</li>
</ul>
<p id="Sound"><a href="commands/Sound.htm">Sound-Funktionen</a>: SoundGet und SoundSet wurden überarbeitet, um sie besser an die Fähigkeiten der Vista+ Sound-APIs anzupassen, auf Kosten der XP-Unterstützung.</p>
<ul>
<li>Nicht unterstützte Regler wurden entfernt.</li>
<li>Altmodische Mixerkomponenten wurden entfernt.</li>
<li>Komponenten können jetzt via Name und/oder Index angesprochen werden.</li>
<li>Geräte können jetzt via Name+Präfix und/oder Index angesprochen werden.</li>
<li>Beide Funktionen wurden in Volume- und Mute-Funktionen aufgeteilt.</li>
<li><a href="commands/SoundGetName.htm">SoundGetName</a> wurde hinzugefügt, um Geräte- oder Komponentennamen abzurufen.</li>
<li><a href="commands/SoundGetInterface.htm">SoundGetInterface</a> wurde hinzugefügt, um COM-Interfaces abzurufen.</li>
</ul>
<p><a href="commands/StrGet.htm">StrGet</a>: Wenn der Wert in <em>Länge</em> negativ ist, wird sein absoluter Wert die genaue Anzahl der Zeichen bestimmen, die umgewandelt werden sollen, einschließlich aller binären Nullen, die die Zeichenkette enthalten könnte - das heißt, dass das Ergebnis immer eine Zeichenkette mit exakt dieser Länge sein wird. Wenn der Wert in <em>Länge</em> positiv ist, wird die Zeichenkette wie in v1 bei der ersten binären Null enden.</p>
<p><a href="commands/StrGet.htm">StrGet</a>/<a href="commands/StrPut.htm">StrPut</a>: Der <em>Adresse</em>-Parameter kann ein Objekt mit den Eigenschaften <code>Ptr</code> und <code>Size</code> sein, wie z. B. das neue <code>Buffer</code>-Objekt. Das Lesen/Schreiben wird automatisch via <code>Size</code> limitiert (in Bytes). Wenn zudem <em>Length</em> angegeben ist, darf es nicht <em>Size</em> überschreiten (multipliziert mit 2 bei UTF-16).</p>
<p>Der Rückgabewert von StrPut ist nun in Bytes, so dass er direkt an Buffer() übergeben werden kann.</p>
<p><a href="commands/StrReplace.htm">StrReplace</a> hat jetzt einen <em>GroßKleinSensitiv</em>-Parameter anstelle von <em>AusgabeVarAnzahl</em>, der um einen Parameter nach rechts verschoben wurde, mit <em>Limit</em> danach.</p>
<p><a href="commands/Suspend.htm">Suspend</a>: Die erste Zeile eines Hotkeys oder Hotstrings dazu bringen, Suspend aufzurufen, führt nicht länger dazu, dass der Hotkey oder Hotstring automatisch von Sperrung befreit wird. Verwenden Sie stattdessen <code>#SuspendExempt</code> oder die <code>S</code>-Option. Der Permit-Parameter ist nicht länger gültig.</p>
<p><a href="commands/Switch.htm">Switch</a> führt jetzt standardmäßig einen Groß-/Kleinschreibung-sensitiven Vergleich für Zeichenketten durch und hat einen <em>GroßKleinSensitiv</em>-Parameter, der den Groß-/Kleinschreibung-Sensitivitätsmodus überschreibt und einen Zeichenkettenvergleich (anstelle eines numerischen Vergleichs) erzwingt. Früher war es nur Groß-/Kleinschreibung-sensitiv, wenn StringCaseSense auf On geändert wurde.</p>
<p><a href="commands/SysGet.htm">SysGet</a> hat jetzt nur noch numerische Unterbefehle; alle anderen Unterbefehle wurden in Funktionen aufgeteilt. Einzelheiten finden Sie unter <a href="#sub-commands">Unterbefehle</a> weiter unten.</p>
<p>TrayTip-Syntax wurde geändert zu <code>TrayTip [Text, Titel, Optionen]</code>. <em>Optionen</em> ist eine Zeichenkette bestehend aus eine oder mehreren Optionen, deren Groß-/Kleinschreibung egal ist und mit Leer- oder Tabulatorzeichen voneinander getrennt sind. Die Optionen sind <code>Iconx</code>, <code>Icon!</code>, <code>Iconi</code>, <code>Mute</code> und/oder nach wie vor ein beliebiger numerischer Wert. TrayTip wird jetzt auch angezeigt, wenn <em>Text</em> weggelassen wird (das nun im Gegensatz zu v1 seltener aus Versehen passieren kann). Der <em>Sekunden</em>-Parameter ist nicht mehr vorhanden (er funktionierte nicht in Windows Vista oder höher). Skripte können die Flags NIIF_USER (0x4) und NIIF_LARGE_ICON (0x20) kombiniert verwenden (0x24), um die große Version des Tray-Symbols in die Benachrichtigung zu integrieren. NIIF_USER (0x4) kann auch allein für das kleine Symbol verwendet werden, allerdings sind die Ergebnisse möglicherweise nicht über alle Betriebssysteme hinweg konsistent.</p>
<p>#Warn UseUnsetLocal und UseUnsetGlobal wurden entfernt, da das Lesen einer ungesetzten Variable nun einen Fehler auslöst. <a href="commands/IsSet.htm">IsSet</a> kann verwendet werden, um den Fehler zu vermeiden, und <a href="commands/Try.htm">Try</a>/<a href="commands/Catch.htm">Catch</a> oder <a href="commands/OnError.htm">OnError</a> können verwendet werden, um ihn zu behandeln.</p>
<p><a href="commands/_Warn.htm#VarUnset">#Warn VarUnset</a> wurde hinzugefügt; es verwendet standardmäßig MsgBox. Wenn nicht deaktiviert, wird eine Warnung für die erste nicht-dynamische Referenz auf jede Variable ausgegeben, die niemals als Ziel einer direkten, nicht-dynamischen Zuweisung oder des Referenzoperators (&amp;) verwendet oder direkt an IsSet übergeben wird.</p>
<p><a href="commands/_Warn.htm#Unreachable">#Warn Unreachable</a> betrachtet Zeilen, die nach einem <code>Exit</code>-Aufruf folgen, nicht mehr als unerreichbar, da Exit jetzt eine normale Funktion ist.</p>
<p>#Warn ClassOverwrite wurde entfernt, da nicht-untergeordnete Klassen nicht mehr durch Zuweisung überschrieben werden können. (Allerdings können sie nun implizit von einer lokalen Variable überschattet werden; dies kann mit #Warn LocalSameAsGlobal erkannt werden.)</p>
<p><a href="commands/WinActivate.htm">WinActivate</a> sendet jetzt <code>{Alt up}</code> nach dessen erstem fehlgeschlagenen Versuch, ein Fenster zu aktivieren. Tests zufolge wird dadurch die Chance verringert, dass die Taskleistenschaltflächen aufblinken. Weitere Einzelheiten finden Sie in der Dokumentation.</p>
<p>Die Parameterreihenfolge von <a href="commands/WinSetTitle.htm">WinSetTitle</a> und <a href="commands/WinMove.htm">WinMove</a> ist nun im Einklang mit anderen Fensterfunktionen; das heißt, dass <em>FensterTitel, FensterText, IgnoriereTitel, IgnoriereText</em> immer zusammen sind (am Ende der Parameterliste), um das Einprägen der Parameter zu fördern.</p>
<p>Der <em>FensterTitel</em>-Parameter, welcher von verschiedenen Funktionen verwendet wird, kann nun eine HWND-Nummer (muss ein reiner Integer sein) oder ein Objekt mit einer <code>Hwnd</code>-Eigenschaft akzeptieren, wie z. B. ein Gui-Objekt. <code>DetectHiddenWindows</code> wird in solchen Fällen ignoriert.</p>
<p><a href="commands/WinMove.htm">WinMove</a> erteilt dem Wort <code class="no-highlight">DEFAULT</code> nicht länger eine Spezialbehandlung. Lassen Sie den Parameter stattdessen weg oder verwenden Sie eine leere Zeichenkette (funktioniert sowohl in v1 als auch in v2).</p>
<p><a href="commands/WinWait.htm">WinWait</a>, <a href="commands/WinWaitClose.htm">WinWaitClose</a>, <a href="commands/WinWaitActive.htm">WinWaitActive</a> und <a href="commands/WinWaitActive.htm">WinWaitNotActive</a> geben einen Wert ungleich Null zurück, wenn sie aufgehört haben zu warten (Zeitlimit nicht überschritten wurde). ErrorLevel wurde entfernt. WinWait und WinWaitActive geben die HWND-Nummer des gefundenen Fensters zurück. WinWaitClose setzt nun das Zuletzt Gefundene Fenster; das heißt, wenn WinWaitClose das Zeitlimit überschritten hat, gibt es False zurück und bewirkt, dass <code>WinExist()</code> dessen Zuletzt Gefundene Fenster zurückgibt. Eine 0 für das Zeitlimit anzugeben ist nicht länger dasselbe wie, als würde man 0.5 angeben; stattdessen wird die kleinstmögliche Wartezeit erzeugt.</p>
<p><strong>Unsortiert:</strong></p>
<p>Eine negative <em>StartPos</em> bei <a href="commands/InStr.htm">InStr</a>, <a href="commands/SubStr.htm">SubStr</a>, <a href="commands/RegExMatch.htm">RegExMatch</a> und <a href="commands/RegExReplace.htm">RegExReplace</a> wird als Position ausgehend vom Ende interpretiert. Position -1 ist das letzte Zeichen und Position 0 ist ungültig (während in v1 Position 0 das letzte Zeichen war).</p>
<p>Funktionen, die bislang On/Off oder On/Off/Toggle (aber keine anderen Zeichenketten) akzeptierten, benötigen nun stattdessen 1/0/-1. On und Off werden typischerweise mit <code>True</code> bzw. <code>False</code> ersetzt. Variablen, die On/Off zurückgegeben haben, geben jetzt 1/0 zurück, was in Ausdrücken nützlicher ist.</p>
<ul>
<li><a href="commands/_UseHook.htm">#UseHook</a> und <a href="commands/_MaxThreadsBuffer.htm">#MaxThreadsBuffer</a> erlauben <code>1</code>, <code>0</code>, <code>True</code> und <code>False</code>. (Im Gegensatz zu den anderen unterstützen sie eigentlich keine Ausdrücke.)</li>
<li><a href="commands/ListLines.htm">ListLines</a> erlaubt eine leere Zeichenkette oder einen booleschen Wert.</li>
<li><a href="commands/ControlSetChecked.htm">ControlSetChecked</a>, <a href="commands/ControlSetEnabled.htm">ControlSetEnabled</a>, <a href="commands/Pause.htm">Pause</a>, <a href="commands/Suspend.htm">Suspend</a>, <a href="commands/WinSetAlwaysOnTop.htm">WinSetAlwaysOnTop</a> und <a href="commands/WinSetEnabled.htm">WinSetEnabled</a> erlauben <code>1</code>, <code>0</code> und <code>-1</code>.</li>
<li><a href="Variables.htm#DetectHiddenWindows">A_DetectHiddenWindows</a>, <a href="Variables.htm#DetectHiddenText">A_DetectHiddenText</a>, und <a href="Variables.htm#StoreCapsLockMode">A_StoreCapsLockMode</a> benutzen boolesche Werte (so wie die entsprechenden Funktionen auch).</li>
</ul>
<p>Die folgenden Funktionen geben einen reinen Integer anstelle einer hexadezimalen Zeichenkette zurück:</p>
<ul>
<li><a href="commands/ControlGetStyle.htm">ControlGetExStyle</a></li>
<li><a href="commands/ControlGetHwnd.htm">ControlGetHwnd</a></li>
<li><a href="commands/ControlGetStyle.htm">ControlGetStyle</a></li>
<li><a href="commands/MouseGetPos.htm">MouseGetPos</a></li>
<li><a href="commands/WinActive.htm">WinActive</a></li>
<li><a href="commands/WinExist.htm">WinExist</a></li>
<li><a href="commands/WinGetID.htm">WinGetID</a></li>
<li><a href="commands/WinGetIDLast.htm">WinGetIDLast</a></li>
<li><a href="commands/WinGetList.htm">WinGetList</a> (innerhalb des Arrays)</li>
<li><a href="commands/WinGetStyle.htm">WinGetStyle</a></li>
<li><a href="commands/WinGetStyle.htm">WinGetStyleEx</a></li>
<li><a href="commands/WinGetControlsHwnd.htm">WinGetControlsHwnd</a> (innerhalb des Arrays)</li>
</ul>
<p><a href="Variables.htm#ScriptHwnd">A_ScriptHwnd</a> gibt ebenfalls einen reinen Integer zurück.</p>
<h4 id="dllcall">DllCall</h4>
<p>Wenn ein Typ-Parameter eine Variable ist, wird immer der Inhalt dieser Variable verwendet, niemals ihr Name. Mit anderen Worten werden anführungszeichenlose Typennamen nicht mehr unterstützt - die Namen der Typen müssen in Anführungszeichen gesetzt werden.</p>
<p>Wenn DllCall die Länge einer Zeichenkette, die als Str oder WStr übergeben wurde, aktualisiert, erkennt es nun, wenn die Zeichenkette nicht korrekt null-terminiert wurde (was wahrscheinlich darauf hinweist, dass ein Pufferüberlauf stattgefunden hat), und beendet in diesem Fall das Programm mit einer Fehlermeldung, da eine sichere Ausführung nicht mehr garantiert werden kann.</p>
<p><code>AStr</code> (ohne irgendwelche Suffixe) darf nur noch für Eingabeparameter verwendet werden. Da der Puffer immer nur so groß wie die Eingabezeichenkette sein kann, war AStr für Ausgabeparameter meist nicht sinnvoll. Dies würde für WStr statt AStr gelten, wenn AutoHotkey für ANSI kompiliert ist, aber offizielle v2-Versionen werden immer nur für Unicode kompiliert.</p>
<p>Wenn eine Funktion eine neue Adresse in einen <code>Str*</code>-, <code>AStr*</code>- oder <code>WStr*</code>-Parameter schreibt, wird DllCall nun die neue Zeichenkette der entsprechenden Variable zuweisen, falls eine bereitgestellt wurde, anstatt nur die Länge der ursprünglichen Zeichenkette zu aktualisieren (die sich wahrscheinlich nicht geändert hat). Parameter dieses Typs werden normalerweise nicht verwendet, um die Eingabezeichenkette zu ändern, sondern um eine Zeichenkette an eine neue Adresse zurückzugeben.</p>
<p>DllCall akzeptiert nun ein Objekt für jeden <code>Ptr</code>-Parameter und den <em>Funktion</em>-Parameter; das Objekt muss eine <code>Ptr</code>-Eigenschaft haben. Für Puffer, die vom Skript reserviert werden, wird das neue <code>Buffer</code>-Objekt gegenüber einer Variable bevorzugt. Im Falle von <code>Ptr*</code> wird der neue Wert des Parameters wieder der <code>Ptr</code>-Eigenschaft des Objekts zugewiesen. Dies ermöglicht Konstrukte wie <code>DllCall(..., "Ptr*", unk := IUnknown.new())</code>, was Wiederholungen im Vergleich zu <code>DllCall(..., "Ptr*", punk), unk := IUnknown.new(punk)</code> reduziert, und kann verwendet werden, um sicherzustellen, dass jede Ausgabe der Funktion ordnungsgemäß freigegeben wird (selbst wenn eine Ausnahme aufgrund des Rückgabetyps <code>HRESULT</code> ausgelöst wird, obwohl die Funktion in diesem Fall normalerweise keinen Nicht-Null-Pointer ausgeben würde).</p>
<p>DllCall verlangt nun, dass die Werte von Parametern numerischen Typs numerisch sind, und löst eine Ausnahme aus, wenn eine nicht-numerische oder leere Zeichenkette übergeben wurde. Insbesondere wenn das Suffix * oder P für Ausgabeparameter verwendet wird, dann muss die Ausgabevariable initialisiert werden.</p>
<p>Der Ausgabewert (falls vorhanden) von numerischen Parametern mit dem Suffix * oder P wird ignoriert, wenn das Skript eine einfache Variable übergibt, die eine Zahl enthält. Um den Ausgabewert zu erhalten, übergeben Sie eine <code>VarRef</code> wie <code>&amp;meineVar</code> oder ein Objekt mit einer <code>Ptr</code>-Eigenschaft.</p>
<p>Der neue Rückgabetyp <code>HRESULT</code> löst eine Ausnahme aus, wenn die Funktion fehlschlägt (<code>int &lt; 0</code> oder <code>uint &amp; 0x80000000</code>). Dies sollte nur bei Funktionen verwendet werden, die tatsächlich ein <code>HRESULT</code> zurückgeben.</p>
<h4 id="loop-sub-commands">Loop-Unterbefehle</h4>
<p>Der Unterbefehl muss direkt geschrieben werden; er darf weder in Anführungszeichen stehen noch eine Variable oder ein Ausdruck sein. Alle anderen Parameter sind Ausdrücke. Alle Loop-Unterbefehle unterstützen nun OTB.</p>
<p>Entfernt:</p>
<pre class="no-highlight">Loop, DateiMuster [, OrdnerEinbeziehen?, Rekursiv?]
Loop, RootSchlüssel [, Schlüssel, UnterschlüsselEinbeziehen?, Rekursiv?]
</pre>
<p>Benutzen Sie stattdessen folgendes (seit v1.1.21 verfügbar):</p>
<pre>Loop Files, DateiMuster [, Modus]
Loop Reg, RootSchlüssel\Schlüssel [, Modus]
</pre>
<p>Das Komma nach dem zweiten Wort ist jetzt optional.</p>
<p><a href="commands/LoopReg.htm#vars">A_LoopRegKey</a> enthält nun den Root-Schlüssel und Unterschlüssel, außerdem wurde A_LoopRegSubKey entfernt.</p>
<h4 id="inputbox">InputBox</h4>
<pre>Obj := InputBox([Text, Titel, Optionen, Standardwert])
</pre>
<p>Der <em>Optionen</em>-Parameter akzeptiert eine Zeichenkette mit null oder mehr nicht-Groß-/Kleinschreibung-sensitiven Optionen, jeweils getrennt mit einem Leer- oder Tabulatorzeichen, analog zu den Gui-Steuerelement-Optionen. Die folgende Zeichenkette würde alle unterstützten Optionen enthalten: <code>x0 y0 w100 h100 T10.0 Password*</code>. <code>T</code> ist Timeout (Zeitlimit); <code>Password</code> stimmt mit der gleichwertigen Edit-Steuerelement-Option überein.</p>
<p>Die Breiten- und Höhenoptionen bestimmen jetzt die Größe des Client-Bereichs (das ist der Bereich ohne Titelleiste und Fensterrahmen); das heißt, dass sie weniger abhängig vom Windows-Design sind.</p>
<p>Der Titel wird leer sein, wenn der <em>Titel</em>-Parameter eine leere Zeichenkette ist. Der Titel wird standardmäßig <a href="Variables.htm#ScriptName">A_ScriptName</a> sein, wenn der Parameter komplett fehlt, um konsistent mit optionalen Parametern von benutzerdefinierten Funktionen zu sein.</p>
<p><em>Obj</em> ist ein Objekt mit den Eigenschaften <code>Result</code> (enthält "OK", "Cancel" oder "Timeout") und <code>Value</code>.</p>
<h4 id="msgbox">MsgBox</h4>
<pre>Ergebnis := MsgBox([Text, Titel, Optionen])
</pre>
<p>Der <em>Optionen</em>-Parameter akzeptiert eine Zeichenkette mit null oder mehr nicht-Groß-/Kleinschreibung-sensitiven Optionen, jeweils getrennt mit einem Leer- oder Tabulatorzeichen, analog zu den Gui-Steuerelement-Optionen.</p>
<ul>
<li><code>Iconx</code>, <code>Icon?</code>, <code>Icon!</code> und <code>Iconi</code> setzen das Symbol.</li>
<li><code class="no-highlight">Default</code>, unmittelbar gefolgt von einem Integer, macht die <em>n</em>-te Schaltfläche zur Standardschaltfläche.</li>
<li><code>T</code>, unmittelbar gefolgt von einem Integer oder einer Floating-Point-Zahl, bestimmt das Timeout in Sekunden.</li>
<li><code>Owner</code>, unmittelbar gefolgt von einer HWND-Nummer, bestimmt das übergeordnete Fenster, und überschreibt die <code>+OwnDialogs</code>-Gui-Option.</li>
<li>Folgende Zeichenketten (schließen sich gegenseitig aus) bestimmen die Auswahl der Schaltflächen: <code>OK</code>, <code>OKCancel</code>, <code>AbortRetryIgnore</code>, <code>YesNoCancel</code>, <code>YesNo</code>, <code>RetryCancel</code>, <code>CancelTryAgainContinue</code>, oder einfach die via Schrägstrich getrennten Initialen (<code>o/c</code>, <code>y/n</code>, etc.), oder einfach die Initialen ohne Schrägstrich.</li>
<li>Beliebiger numerischer Wert, so wie bei v1. Numerische Werte können mit Zeichenkettenoptionen kombiniert werden, oder <em>Optionen</em> kann ein reiner Integer sein.</li>
</ul>
<p>Der Rückgabewert ist der Name der Schaltfläche, ohne Leerzeichen. Diese Zeichenketten sind dieselben, die bei IfMsgBox in v1 benutzt wurden.</p>
<p>Der Titel wird leer sein, wenn der <em>Titel</em>-Parameter eine leere Zeichenkette ist. Der Titel wird standardmäßig <a href="Variables.htm#ScriptName">A_ScriptName</a> sein, wenn der Parameter komplett fehlt, um konsistent mit optionalen Parametern von benutzerdefinierten Funktionen zu sein.</p>
<h4 id="sub-commands">Unterbefehle</h4>
<p>Unterbefehle von Control, ControlGet, Drive, DriveGet, WinGet, WinSet und Process wurden durch einzelne Funktionen ersetzt, und die Hauptbefehle wurden entfernt. Namen und Benutzung wurden bei mehreren Funktionen geändert. Diese Funktionen werden jetzt wie folgt benutzt:</p>
<pre><em>; Die "..." sind die optionalen Parameter Steuerelement, FensterTitel, etc.</em>

Bool  := ControlGetChecked(...)
Bool  := ControlGetEnabled(...)
Bool  := ControlGetVisible(...)
Int   := ControlGetIndex(...)  ; Für Tab, LB, CB, DDL
Str   := ControlGetChoice(...)
Arr   := ControlGetItems(...)
Int   := ControlGetStyle(...)
Int   := ControlGetExStyle(...)
Int   := ControlGetHwnd(...)

         ControlSetChecked(TrueFalseToggle, ...)
         ControlSetEnabled(TrueFalseToggle, ...)
         ControlShow(...)
         ControlHide(...)
         ControlSetStyle(Wert, ...)
         ControlSetExStyle(Wert, ...)
         ControlShowDropDown(...)
         ControlHideDropDown(...)
         ControlChooseIndex(Index, ...)  ; Deckt auch Tab ab
Index := ControlChooseString(Zkette, ...)

Index := ControlFindItem(Zkette, ...)
Index := ControlAddItem(Zkette, ...)
         ControlDeleteItem(Index, ...)

Int   := EditGetLineCount(...)
Int   := EditGetCurrentLine(...)
Int   := EditGetCurrentCol(...)
Str   := EditGetLine(N [, ...])
Str   := EditGetSelectedText(...)
         EditPaste(Zkette, ...)

Str   := ListViewGetContent([Optionen, ...])

         DriveEject([Laufw])
         DriveRetract([Laufw])
         DriveLock(Laufw)
         DriveUnlock(Laufw)
         DriveSetLabel(Laufw [, Label])

Str   := DriveGetList([Typ])
Str   := DriveGetFilesystem(Laufw)
Str   := DriveGetLabel(Laufw)
Str   := DriveGetSerial(Laufw)
Str   := DriveGetType(Pfad)
Str   := DriveGetStatus(Pfad)
Str   := DriveGetStatusCD(Laufw)
Int   := DriveGetCapacity(Pfad)
Int   := DriveGetSpaceFree(Pfad)

<em>; Die "..." sind die optionalen Parameter FensterTitel, etc.</em>

Int   := WinGetID(...)
Int   := WinGetIDLast(...)
Int   := WinGetPID(...)
Str   := WinGetProcessName(...)
Str   := WinGetProcessPath(...)
Int   := WinGetCount(...)
Arr   := WinGetList(...)
Int   := WinGetMinMax(...)
Arr   := WinGetControls(...)
Arr   := WinGetControlsHwnd(...)
Int   := WinGetTransparent(...)
Str   := WinGetTransColor(...)
Int   := WinGetStyle(...)
Int   := WinGetExStyle(...)

         WinSetTransparent(N [, ...])
         WinSetTransColor("Farbe [N]" [, ...]),
         WinSetAlwaysOnTop([TrueFalseToggle := -1, ...])
         WinSetStyle(Wert [, ...])
         WinSetExStyle(Wert [, ...])
         WinSetEnabled(Wert [, ...])
         WinSetRegion(Wert [, ...])

         WinRedraw(...)
         WinMoveBottom(...)
         WinMoveTop(...)

PID   := ProcessExist([PID_oder_Name])
PID   := ProcessClose(PID_oder_Name)
PID   := ProcessWait(PID_oder_Name [, Timeout])
PID   := ProcessWaitClose(PID_oder_Name [, Timeout])

         ProcessSetPriority(Priority [, PID_oder_Name])
</pre>
<p><a href="commands/ProcessExist.htm">ProcessExist</a>, <a href="commands/ProcessClose.htm">ProcessClose</a>, <a href="commands/ProcessWait.htm">ProcessWait</a> und <a href="commands/ProcessWaitClose.htm">ProcessWaitClose</a> setzen kein ErrorLevel mehr; stattdessen geben sie die PID zurück.</p>
<p>Keine der anderen Funktionen setzt ErrorLevel. Stattdessen lösen sie bei Misserfolg eine Ausnahme aus. In den meisten Fällen ist ein Misserfolg darauf zurückzuführen, dass das Zielfenster oder -steuerelement nicht gefunden wurde.</p>
<p>HWND-Nummern und Styles werden immer als reiner Integer zurückgegeben, nicht als hexadezimale Zeichenketten.</p>
<p><a href="commands/ControlChooseIndex.htm">ControlChooseIndex</a> akzeptiert 0, um das aktuelle Element/alle Elemente abzuwählen. Es ersetzt "Control Choose", unterstützt aber auch Tab-Steuerelemente.</p>
<p>"ControlGet Tab" wurde mit <a href="commands/ControlGetIndex.htm">ControlGetIndex</a> zusammengeführt, das auch mit ListBox, ComboBox und DDL funktioniert. Bei Tab-Steuerelementen gibt es 0 zurück, wenn kein Tab ausgewählt ist (selten aber gültig). <a href="commands/ControlChooseIndex.htm">ControlChooseIndex</a> erlaubt keine 0 für Tab-Steuerelemente, da Anwendungen in der Regel nicht damit umgehen können.</p>
<p><a href="commands/ControlGetItems.htm">ControlGetItems</a> ersetzt "ControlGet List" für ListBox und ComboBox. Es gibt ein Array zurück.</p>
<p><a href="commands/DriveEject.htm">DriveEject</a> und <a href="commands/DriveEject.htm">DriveRetract</a> verwenden jetzt DeviceIoControl anstelle von mciSendString. DriveEject ist dadurch in der Lage, Nicht-CD/DVD-Laufwerke auszuwerfen, die eine "Auswerfen"-Option im Explorer haben (also Wechsellaufwerke, nicht aber externe Festplatten).</p>
<p><a href="commands/ListViewGetContent.htm">ListViewGetContent</a> ersetzt "ControlGet List" für ListView und wird momentan genauso verwendet wie zuvor.</p>
<p><a href="commands/WinGetList.htm">WinGetList</a>, <a href="commands/WinGetControls.htm">WinGetControls</a> und <a href="commands/WinGetControlsHwnd.htm">WinGetControlsHwnd</a> geben Arrays zurück, keine via Zeilenumbruchszeichen getrennte Liste.</p>
<p><a href="commands/WinSetTransparent.htm">WinSetTransparent</a> behandelt <code>""</code> als <code>"Off"</code> und nicht als <code>0</code> (was das Fenster unsichtbar und unklickbar machen würde).</p>
<p>Abkürzungen wie Topmost, Trans, FS und Cap wurden entfernt.</p>
<p>Die folgenden Funktionen waren ehemals Unterbefehle von <a href="commands/SysGet.htm">SysGet</a>:</p>
<pre>Vorhanden := MonitorGet([N, Links, Oben, Rechts, Unten])
Vorhanden := MonitorGetWorkArea([N, Links, Oben, Rechts, Unten])
Anzahl    := MonitorGetCount()
Primär    := MonitorGetPrimary()
Name      := MonitorGetName(N)
</pre>
<h3 id="new-functions">Neue Funktionen</h3>
<p><code>Buffer(Größe, FüllByte)</code> (Aufruf der Buffer-Klasse) erzeugt ein <code>Buffer</code>-Objekt und gibt es zurück, für das ein Speicherblock in <em>Größe</em> Bytes reserviert ist, der nur initialisiert ist, wenn <em>FüllByte</em> angegeben ist. <code>BufferObj.Ptr</code> ermittelt die Adresse und <code>BufferObj.Size</code> ermittelt oder setzt die Größe in Bytes (inklusive Neureservierung des Speicherblocks). Es kann ein beliebiges Objekt mit den Eigenschaften Ptr und Size an <a href="commands/NumPut.htm">NumPut</a>, <a href="commands/NumGet.htm">NumGet</a>, <a href="commands/StrPut.htm">StrPut</a>, <a href="commands/StrGet.htm">StrGet</a>, <a href="objects/File.htm#RawRead">File.RawRead</a>, <a href="objects/File.htm#RawWrite">File.RawWrite</a> und <a href="commands/FileAppend.htm">FileAppend</a> übergeben werden. Es kann ein beliebiges Objekt mit einer <code>Ptr</code>-Eigenschaft an <a href="commands/DllCall.htm">DllCall</a>-Parametern vom Typ <code>Ptr</code>, <a href="commands/SendMessage.htm">SendMessage</a> und <a href="commands/PostMessage.htm">PostMessage</a> übergeben werden.</p>
<p><code>CaretGetPos([&amp;X, &amp;Y])</code> ermittelt die aktuellen Koordinaten des Textcursors. Dadurch wird sichergestellt, dass die X- und Y-Koordinaten immer übereinstimmen und dass es kein Caching gibt, das zu unerwartetem Verhalten führt (wenn A_CaretX/Y beispielsweise einen Wert zurückgibt, der nicht im aktuellen CoordMode liegt).</p>
<p><code>ClipboardAll([Daten, Größe])</code> erstellt ein Objekt, das alles, was in der Zwischenablage ist, enthält (und akzeptiert optional Daten, die vorher aus der Zwischenablage abgerufen wurden, anstatt den aktuellen Inhalt der Zwischenablage zu verwenden). Die Methoden zum Lesen und Schreiben von Dateidaten der Zwischenablage sind unterschiedlich. Das Datenformat ist das gleiche, außer dass die Datengröße immer 32-Bit ist, so dass die Daten zwischen 32-Bit- und 64-Bit-Builds portierbar sind. Einzelheiten finden Sie in der v2-Dokumentation.</p>
<p><code>ComCall(offset, comobj, ...)</code> ist äquivalent zu <code>DllCall(NumGet(NumGet(comobj.ptr) + offset * A_Index), "ptr", comobj.ptr, ...)</code>, allerdings ist der Rückgabetyp standardmäßig "hresult" und nicht "int".</p>
<p><a href="commands/ComObject.htm">ComObject</a> (ehemals ComObjCreate) und <a href="commands/ComObjQuery.htm">ComObjQuery</a> geben jetzt ein Wrapper-Objekt zurück, auch dann, wenn eine IID angegeben ist. ComObjQuery lässt zu, dass der erste Parameter ein beliebiges Objekt mit einer <code>Ptr</code>-Eigenschaft sein kann.</p>
<p><a href="commands/ControlGetClassNN.htm">ControlGetClassNN</a> gibt die ClassNN-Bezeichnung eines bestimmten Steuerelements zurück.</p>
<p><a href="commands/ControlSend.htm">ControlSendText</a>, das das Äquivalent zu ControlSendRaw ist, aber den {Text}- statt {Raw}-Modus verwendet.</p>
<p><code>DirExist(Pfad)</code>, so ähnlich wie FileExist. Beachten Sie, dass <code>InStr(FileExist(Muster), "D")</code> nur mitteilt, ob die <em>zuerst</em> gefundene Datei ein Ordner ist, nicht ob ein Ordner existiert.</p>
<p><code>Float(v)</code>: Siehe <a href="#types">Typen</a> weiter oben.</p>
<p><code>InstallKeybdHook(Installieren := true, Erzwingen := false)</code> und <code>InstallMouseHook(Installieren := true, Erzwingen := false)</code> ersetzen die entsprechenden Direktiven, um die Flexibilität zu erhöhen.</p>
<p><code>Integer(v)</code>: Siehe <a href="#types">Typen</a> weiter oben.</p>
<p id="isXXX"><a href="commands/Is.htm">isXXX</a>: Der altmodische Befehl "if Var is Typ" wurde entfernt und in mehreren Funktionen aufgeteilt: isAlnum, isAlpha, isDigit, isFloat, isInteger, isLower, isNumber, isSpace, isUpper, isXDigit. Abgesehen von isFloat, isInteger und isNumber lösen alle eine Ausnahme aus, wenn der Parameter keine Zeichenkette ist, da eine implizite Konvertierung in eine Zeichenkette zu kontraproduktiven Ergebnissen führen kann.</p>
<p><code>IsSet(var)</code>, <code>IsSetRef(&amp;var)</code>: Gibt True zurück, wenn die Variable einen Wert zugewiesen bekommen hat (auch dann, wenn dieser Wert eine leere Zeichenkette ist), ansonsten False. Bei False würde der Versuch, die Variable innerhalb eines Ausdrucks zu lesen, einen Fehler auslösen.</p>
<p><code>Menu()</code>/<code>MenuBar()</code> gibt ein neues Menu/MenuBar-Objekt zurück, das folgende Elemente, die den v1-Menu-Unterbefehlen entsprechen, enthält. Methoden: <a href="objects/Menu.htm#Add">Add</a>, <a href="objects/Menu.htm#AddStandard"><strong>Add</strong>Standard</a>, <a href="objects/Menu.htm#Check">Check</a>, <a href="objects/Menu.htm#Delete">Delete</a>, <a href="objects/Menu.htm#Disable">Disable</a>, <a href="objects/Menu.htm#Enable">Enable</a>, <a href="objects/Menu.htm#Insert">Insert</a>, <a href="objects/Menu.htm#Rename">Rename</a>, <a href="objects/Menu.htm#SetColor"><strong>Set</strong>Color</a>, <a href="objects/Menu.htm#SetIcon"><strong>Set</strong>Icon</a>, <a href="objects/Menu.htm#Show">Show</a>, <a href="objects/Menu.htm#ToggleCheck">ToggleCheck</a>, <a href="objects/Menu.htm#ToggleEnable">ToggleEnable</a>, <a href="objects/Menu.htm#Uncheck">Uncheck</a>. Eigenschaften: <a href="objects/Menu.htm#ClickCount">Click<strong>Count</strong></a>, <a href="objects/Menu.htm#Default">Default</a>, <a href="objects/Menu.htm#Handle">Handle</a> (ersetzt MenuGetHandle). <a href="Variables.htm#TrayMenu">A_TrayMenu</a> gibt auch ein Menu-Objekt zurück. Es gibt keinen UseErrorLevel-Modus, keine globalen Menünamen, und kein explizites Löschen des Menüs selbst (dies geschieht, wenn alle Referenzen freigegeben sind; die <a href="objects/Menu.htm#Delete">Delete</a>-Methode ist äquivalent zu DeleteAll von v1). Labels werden nicht unterstützt, nur Funktionsobjekte. Die <a href="objects/Menu.htm#AddStandard">AddStandard</a>-Methode fügt die vordefinierten Menüpunkte hinzu und ermöglicht, dass sie wie benutzerdefinierte Menüpunkte individuell geändert werden können. Im Gegensatz zu v1 wird das Win32-Menü nur zerstört, wenn das Objekt gelöscht wird.</p>
<p><code>MenuFromHandle(Handle)</code> gibt das Menu-Objekt eines dazugehörigen Win32-Menü-Handles zurück, wenn es von AutoHotkey erstellt wurde.</p>
<p><code>Number(v)</code>: Siehe <a href="#types">Typen</a> weiter oben.</p>
<p><code>Persistent(Persistieren := true)</code> ersetzt die entsprechende Direktive und erhöht die Flexibilität.</p>
<p><code>RegDeleteKey("RootSchlüssel\UnterSchlüssel")</code> löscht einen Registry-Schlüssel. (RegDelete löscht jetzt nur noch Werte, außer wenn alle Parameter in einer Registry-Schleife weggelassen werden.)</p>
<p><a href="commands/Send.htm#SendText">SendText</a>, das das Äquivalent zu SendRaw ist, aber den {Text}- statt {Raw}-Modus verwendet.</p>
<p><code>StrCompare(Zkette1, Zkette2 [, GroßKleinSensitiv := false])</code> gibt -1 (Zkette1 kleiner als Zkette2), 0 (gleich) oder 1 (größer als) zurück. <em>GroßKleinSensitiv</em> kann "Locale" sein.</p>
<p><code>String(v)</code>: Siehe <a href="#types">Typen</a> weiter oben.</p>
<p><code>StrPtr(Zkette)</code> gibt die Adresse einer Zeichenkette zurück. Im Gegensatz zum Adressoperator von v1 kann diese Funktion zusammen mit direkt geschriebenen Zeichenketten und temporären Zeichenketten verwendet werden.</p>
<p><code>SysGetIPAddresses()</code> gibt ein Array mit IP-Adressen zurück, was das Äquivalent zu den entfernten A_IPAddress-Variablen ist. Jede Referenz auf <code>A_IPAddress%N%</code> rief alle Adressen ab, aber gab nur eine zurück, so dass das Abrufen mehrerer Adressen exponentiell länger als nötig dauerte. Das zurückgegebene Array kann keine oder mehr Elemente enthalten.</p>
<p><code>TraySetIcon([DateiName, SymbolNummer, Einfrieren])</code> ersetzt "Menu Tray, Icon".</p>
<p><code>VarSetStrCapacity(&amp;Var [, NeueKapazität])</code> ersetzt das v1-VarSetCapacity, allerdings ist es nur für die Verwendung mit UTF-16-Zeichenketten vorgesehen (z. B. um eine mehrfache Verkettung zu optimieren); daher werden <em>NeueKapazität</em> und der Rückgabewert als Zeichen und nicht als Bytes behandelt.</p>
<p><code>VerCompare(A, B)</code> vergleicht zwei Versionszeichenketten mit dem gleichen Algorithmus wie <a href="commands/_Requires.htm">#Requires</a>.</p>
<p><code>WinGetClientPos([&amp;X, &amp;Y, &amp;W, &amp;H, FensterTitel, ...])</code> ermittelt die Position und Größe des Clientbereichs eines Fensters, in Bildschirmkoordinaten.</p>
<h3 id="new-directives">Neue Direktiven</h3>
<p><code>#DllLoad [DateiOderVerzName]</code>: Lädt eine DLL- oder EXE-Datei, bevor das Skript mit der Ausführung beginnt.</p>
<h3 id="built-in-variables">Interne Variablen</h3>
<p><a href="Variables.htm#AhkPath">A_AhkPath</a> gibt immer den Pfad der aktuellen ausführbaren Datei bzw. des Interpreters zurück, egal ob das Skript kompiliert ist oder nicht. Früher wurde der Pfad des kompilierten Skripts zurückgegeben, wenn eine BIN-Datei als Basisdatei verwendet wurde, aber v2.0-Releases enthalten keine BIN-Dateien mehr.</p>
<p><a href="Variables.htm#IsCompiled">A_IsCompiled</a> gibt 0 statt "" zurück, wenn das Skript nicht kompiliert ist.</p>
<p><a href="Variables.htm#OSVersion">A_OSVersion</a> wird immer eine Zeichenkette im Format <code>Haupt.Neben.Build</code> zurückgeben, wie z. B. <code>6.1.7601</code> für Windows 7 SP1. A_OSType wurde entfernt, da nur NT-basierte Systeme unterstützt wurden.</p>
<p><a href="Variables.htm#TimeSincePriorHotkey">A_TimeSincePriorHotkey</a> gibt "" statt -1 zurück, wenn <a href="Variables.htm#PriorHotkey">A_PriorHotkey</a> "" ist. <a href="Variables.htm#TimeSinceThisHotkey">A_TimeSinceThisHotkey</a> gibt "" statt -1 zurück, wenn <a href="Variables.htm#ThisHotkey">A_ThisHotkey</a> "" ist.</p>
<p>Alle internen "virtuellen" Variablen haben jetzt das <code>A_</code>-Präfix (Einzelheiten finden Sie unten). Alle vordefinierten Variablen, denen dieses Präfix fehlt (wie z. B. <code>Object</code>), sind lediglich globale Variablen. Die Unterscheidung kann wichtig sein, da es derzeit nicht möglich ist, eine virtuelle Variable zu referenzieren (außer wenn sie direkt an eine interne Funktion übergeben wird); <a href="Variables.htm#Args">A_Args</a> ist jedoch keine virtuelle Variable.</p>
<p>Interne Variablen, die Zahlen zurückgeben, geben diese jetzt als <a href="Concepts.htm#numbers">Integer</a> statt als <a href="Concepts.htm#strings">Zeichenkette</a> zurück.</p>
<p>Umbenannt:</p>
<ul>
<li>A_LoopFileFullPath → <a href="commands/LoopFiles.htm#LoopFilePath">A_LoopFilePath</a> (gibt einen relativen Pfad zurück, wenn der Parameter von Loop relativ war, daher war "FullPath" irreführend)</li>
<li>A_LoopFileLongPath → <a href="commands/LoopFiles.htm#LoopFileFullPath">A_LoopFileFullPath</a></li>
<li>Clipboard → <a href="misc/A_Clipboard.htm">A_Clipboard</a></li>
</ul>
<p>Entfernt:</p>
<ul>
<li>ClipboardAll (ersetzt durch die <a href="commands/ClipboardAll.htm">ClipboardAll</a>-Funktion)</li>
<li>ComSpec (nutzen Sie stattdessen <a href="Variables.htm#ComSpec">A_ComSpec</a>)</li>
<li>ProgramFiles (nutzen Sie stattdessen <a href="Variables.htm#ProgramFiles">A_ProgramFiles</a>)</li>
<li>A_AutoTrim</li>
<li>A_BatchLines</li>
<li>A_CaretX, A_CaretY (nutzen Sie stattdessen <a href="commands/CaretGetPos.htm">CaretGetPos</a>)</li>
<li>A_DefaultGui, A_DefaultListView, A_DefaultTreeView</li>
<li>A_ExitReason</li>
<li>A_FormatFloat</li>
<li>A_FormatInteger</li>
<li>A_Gui, A_GuiControl, A_GuiControlEvent, A_GuiEvent, A_GuiX, A_GuiY, A_GuiWidth, A_GuiHeight (alle ersetzt durch Parameter von <a href="objects/GuiOnEvent.htm">Ereignis-Handlern</a>)</li>
<li>A_IPAddress1, A_IPAddress2, A_IPAddress3, A_IPAddress4 (nutzen Sie stattdessen <a href="commands/SysGetIPAddresses.htm">SysGetIPAddresses</a>)</li>
<li>A_IsUnicode (v2 ist immer Unicode; es kann mit <code>StrLen(Chr(0xFFFF))</code> ersetzt oder mit <code>global A_IsUnicode := 1</code> neu definiert werden)</li>
<li>A_StringCaseSense</li>
<li>A_ThisLabel</li>
<li>A_ThisMenu, A_ThisMenuItem, A_ThisMenuItemPos (nutzen Sie stattdessen die <a href="objects/Menu.htm#Add">Parameter des Menüpunkt-Callbacks</a>)</li>
<li>A_LoopRegSubKey (<a href="commands/LoopReg.htm#vars">A_LoopRegKey</a> enthält nun den Root-Schlüssel und Unterschlüssel)</li>
<li>True und False (existieren noch, sind aber jetzt Schlüsselwörter, keine Variablen)</li>
</ul>
<p>Hinzugefügt:</p>
<ul>
<li><a href="Variables.htm#AllowMainWindow">A_AllowMainWindow</a> (Lesen/Schreiben; ersetzt "Menu Tray, MainWindow/NoMainWindow")</li>
<li><a href="Variables.htm#HotkeyInterval">A_HotkeyInterval</a> (ersetzt #HotkeyInterval)</li>
<li><a href="Variables.htm#HotkeyModifierTimeout">A_HotkeyModifierTimeout</a> (ersetzt #HotkeyModifierTimeout)</li>
<li><a href="Variables.htm#InitialWorkingDir">A_InitialWorkingDir</a> (siehe <a href="#default-settings">Standardeinstellungen</a> weiter unten)</li>
<li><a href="Variables.htm#MaxHotkeysPerInterval">A_MaxHotkeysPerInterval</a> (ersetzt #MaxHotkeysPerInterval)</li>
<li><a href="Variables.htm#MenuMaskKey">A_MenuMaskKey</a> (ersetzt #MenuMaskKey)</li>
</ul>
<p>Den folgenden internen Variablen können Werte zugewiesen werden:</p>
<ul>
<li><a href="Variables.htm#ControlDelay">A_ControlDelay</a></li>
<li><a href="Variables.htm#CoordMode">A_CoordMode..</a></li>
<li><a href="Variables.htm#DefaultMouseSpeed">A_DefaultMouseSpeed</a></li>
<li><a href="Variables.htm#DetectHiddenText">A_DetectHiddenText</a> (gibt nun auch 1 oder 0 statt "On" oder "Off" zurück)</li>
<li><a href="Variables.htm#DetectHiddenWindows">A_DetectHiddenWindows</a> (gibt nun auch 1 oder 0 statt "On" oder "Off" zurück)</li>
<li><a href="Variables.htm#EventInfo">A_EventInfo</a></li>
<li><a href="Variables.htm#FileEncoding">A_FileEncoding</a> (diese Variable gibt nun "CP0" anstelle von "" zurück, außerdem kann ihr ein Integer ohne CP-Präfix zugewiesen werden)</li>
<li><a href="Variables.htm#IconHidden">A_IconHidden</a></li>
<li><a href="Variables.htm#IconTip">A_IconTip</a> (außerdem spiegelt es nun immer den Tooltip wider, auch wenn es Standard oder leer ist)</li>
<li><a href="Variables.htm#Index">A_Index</a>: Bei endlichen Schleifen wird ein hier gespeicherter Wert die Anzahl der Durchläufe beeinflusst. (Die globale Ausrichtung der internen Variablen hat zur Folge, dass eine Enumerator-Funktion den Index setzen könnte, der von einer For-Schleife gesehen wird.)</li>
<li><a href="Variables.htm#KeyDelay">A_KeyDelay</a></li>
<li><a href="Variables.htm#KeyDelayPlay">A_KeyDelayPlay</a></li>
<li><a href="Variables.htm#KeyDelay">A_KeyDuration</a></li>
<li><a href="Variables.htm#KeyDelayPlay">A_KeyDurationPlay</a></li>
<li><a href="Variables.htm#LastError">A_LastError</a>: Ruft die Win32-SetLastError()-Funktion auf. Zudem wird nun ein vorzeichenloser Wert zurückgegeben.</li>
<li><a href="Variables.htm#ListLines">A_ListLines</a></li>
<li><a href="Variables.htm#MouseDelay">A_MouseDelay</a></li>
<li><a href="Variables.htm#MouseDelay">A_MouseDelayPlay</a></li>
<li><a href="Variables.htm#RegView">A_RegView</a></li>
<li><a href="Variables.htm#ScriptName">A_ScriptName</a>: Ändert den Standardtitel von Dialogfenstern.</li>
<li><a href="Variables.htm#SendLevel">A_SendLevel</a></li>
<li><a href="Variables.htm#SendMode">A_SendMode</a></li>
<li><a href="Variables.htm#StoreCapsLockMode">A_StoreCapsLockMode</a> (gibt nun auch 1 oder 0 statt "On" oder "Off" zurück)</li>
<li><a href="Variables.htm#TitleMatchMode">A_TitleMatchMode</a></li>
<li><a href="Variables.htm#TitleMatchModeSpeed">A_TitleMatchModeSpeed</a></li>
<li><a href="Variables.htm#WinDelay">A_WinDelay</a></li>
<li><a href="Variables.htm#WorkingDir">A_WorkingDir</a>: Das gleiche wie, als würde man <a href="commands/SetWorkingDir.htm">SetWorkingDir</a> aufrufen.</li>
</ul>
<h3 id="built-in-objects">Interne Objekte</h3>
<p>File-Objekte benötigen nun zwingend die Eigenschaftssyntax zum Aufrufen von Eigenschaften und die Methodensyntax zum Aufrufen von Methoden. Zum Beispiel ist <code>File.Pos(n)</code> ungültig. Es wird eine Ausnahme ausgelöst, wenn zu wenige oder zu viele Parameter vorhanden sind oder wenn eine schreibgeschützte Eigenschaft einen Wert zugewiesen bekommt.</p>
<p><code>File.Tell()</code> wurde entfernt.</p>
<p><code>Func.IsByRef()</code> funktioniert nun mit internen Funktionen.</p>
<h2 id="gui">Gui</h2>
<p>Gui, GuiControl und GuiControlGet wurden durch <a href="objects/Gui.htm#Call">Gui()</a> und <a href="objects/Gui.htm">Gui</a>/<a href="objects/GuiControl.htm">GuiControl</a>-Objekte ersetzt, die in der Regel flexibler, konsistenter und leichter zu bedienen sind.</p>
<p>Eine GUI wird normalerweise nicht via Name/Nummer angesteuert (allerdings kann sie weiterhin mit <code>GuiObj.Name</code> benannt werden). Stattdessen wird ein GUI-Objekt (und Fenster) explizit durch Instanziierung der <code>Gui</code>-Klasse erstellt, wie in <code>GuiObj := Gui()</code>. Dieses Objekt hat Methoden und Eigenschaften, die die Gui-Unterbefehle ersetzen. <code>GuiObj.Add()</code> gibt ein GuiControl-Objekt zurück, das über Methoden und Eigenschaften verfügt, die die GuiControl- und GuiControlGet-Befehle ersetzen. Man kann dieses Objekt in eine Variable speichern, oder <code>GuiObj["Name"]</code> oder <code>GuiCtrlFromHwnd(hwnd)</code> benutzen, um das Objekt abzurufen. Es wird auch als Parameter übergeben, wenn ein Event-Handler (der Ersatz für ein g-Label) aufgerufen wird.</p>
<p>Die Verwendung dieser Methoden und Eigenschaften ist nicht 1:1. Viele Teile wurden überarbeitet, um konsistenter und flexibler zu sein und um Fehler oder Einschränkungen zu beheben.</p>
<p>Es gibt keine Standard-GUIs, da das zu bearbeitende Gui- oder GuiControl-Objekt immer angegeben ist. LV/TV/SB-Funktionen wurden durch Methoden (des GuiControl-Objekts) ersetzt, so dass es viel einfacher ist, mehrere ListViews/TreeViews zu verwenden.</p>
<p>Es gibt keine internen Variablen, die Informationen über Ereignisse enthalten. Die Informationen werden als Parameter an eine Funktion/Methode übergeben, die das Ereignis behandelt, einschließlich dessen GUI oder Steuerelement.</p>
<p>Steuerelement können weiterhin benannt und via Name angesteuert werden. Allerdings ist das nur ein Name (benutzbar mit <code>GuiObj["Name"]</code> und <code>GuiObj.Submit()</code>), nicht eine zugewiesene Variable, daher müssen keine globalen oder statischen Variablen deklariert oder erstellt werden. Der Wert wird niemals automatisch in eine Variable gespeichert, aber er ist via <code>GuiCtrl.Value</code> abrufbar. <code>GuiObj.Submit()</code> gibt ein neues assoziatives Array zurück, das die Namen der Steuerelemente als Schlüssel enthält.</p>
<p>Die v<em>Name</em>-Option setzt nun nur noch den Namen des Steuerelements auf <em>Name</em>.</p>
<p>Die +Hwnd<em>VarName</em>-Option wurde zugunsten von <code>GuiCtrl.Hwnd</code> entfernt.</p>
<p>Es gibt keine "g-Labels" oder Labels/Funktionen mehr, die automatisch GUI-Ereignisse behandeln. Das Skript muss jedes gewünschte Ereignis registrieren, indem es die <a href="objects/GuiOnEvent.htm">OnEvent</a>-Methode des Gui oder GuiControl aufruft. Anstatt z. B. <code>if (A_GuiEvent = "I" &amp;&amp; InStr(ErrorLevel, "F", true))</code> in einem g-Label zu prüfen, würde das Skript einen Handler für das <code>ItemFocus</code>-Ereignis registrieren: <code>MeineLV.OnEvent("ItemFocus", MeineFunktion)</code>. <em>MeineFunktion</em> würde nur bei dem ItemFocus-Ereignis aufgerufen werden. Es ist nicht erforderlich, <code>AltSubmit</code> anzuwenden, um zusätzliche Ereignisse zu ermöglichen.</p>
<p>Arrays werden überall dort verwendet, wo zuvor eine via Vertikalstrich getrennte Liste verwendet wurde, z. B. um die Listeneinträge für eine ListBox zu bestimmen, wenn diese erstellt wird, wenn Einträge hinzugefügt werden oder wenn die ausgewählten Einträge abgerufen werden.</p>
<p>Skripte können eine Klasse definieren, die <code>Gui</code> erweitert und ihre eigenen Ereignisse behandelt, wobei die gesamte GUI-Logik in sich geschlossen bleibt.</p>
<h3 id="gui-sub-commands">Gui-Unterbefehle</h3>
<p><strong>Gui New</strong> → <a href="objects/Gui.htm#Call">Gui()</a>. Eine leere Zeichenkette als Titel führt dazu, dass das Gui nicht den Standardtitel, sondern einen leeren Titel bekommen wird.</p>
<p><strong>Gui Add</strong> → <a href="objects/Gui.htm#Add">GuiObj.Add() oder GuiObj.Add<em>Steuerelement</em>()</a>; z. B. <code>GuiObj.Add("Edit")</code> oder <code>GuiObj.AddEdit()</code>.</p>
<p><strong>Gui Show</strong> → <a href="objects/Gui.htm#Show">GuiObj.Show()</a>, aber ohne <em>Titel</em>-Parameter. Der Titel kann via Gui()-Parameter oder via GuiObj.Title angegeben werden. Der initiale Fokus wird immer noch auf das erste eingabefähige Steuerelement mit dem WS_TABSTOP-Style gesetzt (gemäß der Standardmeldungsverarbeitung des Systems), es sei denn, es handelt sich um ein Button-Steuerelement, dann wird der Fokus jetzt auf die Standardschaltfläche verschoben.</p>
<p><strong>Gui Submit</strong> → <a href="objects/Gui.htm#Submit">GuiObj.Submit()</a>. Funktioniert wie zuvor, außer dass Submit() ein neues Objekt erstellt und zurückgibt, das alle "zugewiesenen Variablen" enthält.</p>
<p><strong>Gui Destroy</strong> → <a href="objects/Gui.htm#Destroy">GuiObj.Destroy()</a>. Das Objekt existiert weiterhin (bis es vom Skript freigegeben wird), kann aber nicht verwendet werden. Es muss eine neue GUI erstellt werden (falls erforderlich). Das Fenster wird auch zerstört, wenn das Objekt gelöscht wird, aber das Objekt wird "am Leben gehalten", während das Fenster sichtbar ist.</p>
<p><strong>Gui Font</strong> → <a href="objects/Gui.htm#SetFont">GuiObj.SetFont()</a>. Mit GuiCtrl.SetFont() ist es auch möglich, die Schriftart eines Steuerelements direkt zu setzen.</p>
<p><strong>Gui Color</strong> → <a href="objects/Gui.htm#BackColor">GuiObj.BackColor</a> setzt/ermittelt die Hintergrundfarbe. <em>Steuerelementfarbe</em> (der zweite Parameter) wird nicht unterstützt, aber bei allen Steuerelementen, die diesen Parameter zuvor unterstützten, kann der Hintergrund via <code>+Background</code>-Option geändert werden. Im Gegensatz zu "Gui Color" hat GuiObj.BackColor keinen Einfluss auf Progress-Steuerelemente oder deaktivierte/schreibgeschützte TreeView- (mit -Theme), Edit-, DDL- oder ComboBox-Steuerelemente.</p>
<p><strong>Gui Margin</strong> → die Eigenschaften <a href="objects/Gui.htm#MarginX">GuiObj.MarginX</a> und <a href="objects/Gui.htm#MarginY">GuiObj.MarginY</a>.</p>
<p><strong>Gui Menu</strong> → <a href="objects/Gui.htm#MenuBar">GuiObj.MenuBar</a> setzt oder gibt ein MenuBar-Objekt, das mit <code>MenuBar()</code> erstellt wurde, zurück.</p>
<p><strong>Gui Cancel/Hide/Minimize/Maximize/Restore</strong> → gleichnamige Gui-Methoden.</p>
<p><strong>Gui Flash</strong> → <a href="objects/Gui.htm#Flash">GuiObj.Flash()</a>, aber benutzen Sie <code>false</code> statt <code>Off</code>.</p>
<p><strong>Gui Tab</strong> → <a href="objects/GuiControl.htm#UseTab">TabStrlmnt.UseTab()</a>. Wie zuvor stimmt es standardmäßig mit einem Präfix des Tabnamens überein. Übergeben Sie True im zweiten Parameter, um eine Übereinstimmung mit dem gesamten Tabnamen zu bewirken, aber im Gegensatz zum "Exakt"-Modus aus v1 ist sie nicht-Groß-/Kleinschreibung-sensitiv.</p>
<h3 id="events">Ereignisse</h3>
<p>Einzelheiten zu allen explizit unterstützten GUI- und GUI-Steuerelement-Ereignissen finden Sie unter <a href="objects/GuiOnEvent.htm#Events">Ereignisse (OnEvent)</a>.</p>
<p>Das Size-Ereignis übergibt 0,-1 oder 1 (um konsistent mit <a href="commands/WinGetMinMax.htm">WinGetMinMax</a> zu sein) statt 0, 1 oder 2.</p>
<p>Das ContextMenu-Ereignis kann für jedes Steuerelement oder für die ganze GUI registriert werden.</p>
<p>Das DropFiles-Ereignis tauscht die Parameter <em>DateiArray</em> und <em>Ctrl</em>, um konsistent mit ContextMenu zu sein.</p>
<p>Die Ereignisse ContextMenu und DropFiles verwenden Clientkoordinaten statt Fensterkoordinaten (Client ist auch die <a href="commands/CoordMode.htm">CoordMode</a>-Standardeinstellung in v2).</p>
<p>Die folgenden steuerelementspezifischen Ereignisse wurden zwar entfernt, aber sie können weiterhin mithilfe von <a href="objects/GuiOnNotify.htm">GuiCtrl.OnNotify()</a> und einem geeigneten numerischen Benachrichtigungscode (definiert im Windows SDK) erkannt werden: K, D, d, A, S, s, M, C, E und die 1 und 2 von MonthCal.</p>
<p>Steuerelementspezifische Ereignisse übergeben den Ereignisnamen nicht als Parameter (GUI-Ereignisse taten dies nie).</p>
<p>Custom-Ereignisse N und Normal wurden ersetzt mit <a href="objects/GuiOnNotify.htm">GuiCtrl.OnNotify()</a> und <a href="objects/GuiOnCommand.htm">GuiCtrl.OnCommand()</a>, die bei allen Steuerelementen benutzt werden können.</p>
<p>Link-Ereignis Click übergibt "Ctrl, ID oder Index, HREF" statt "Ctrl, Index, HREF oder ID", und wird HREF nicht automatisch ausführen, wenn ein Click-Callback registriert ist.</p>
<p>ListView-Ereignisse Click, DoubleClick und ContextMenu (ausgelöst durch Rechtsklick) geben nun das Element zurück, welches angeklickt wurde (oder 0, wenn nicht), anstatt das fokussierte Element.</p>
<p>ListView-Ereignis I wurde in mehrere benannten Ereignisse aufgeteilt. Das f-Ereignis (Fokus verloren) wurde ausgeschlossen, weil es nun via F (ItemFocus) repräsentiert wird.</p>
<p>ListView-Ereignis e (ItemEdit) wird ignoriert, wenn der Benutzer das Editieren abbricht.</p>
<p>Slider-Ereignis Change wird konsistenter ausgelöst als das g-Label von v1; das heißt, dass es standardmäßig keine Änderungen via Mausrad mehr ignoriert. Einzelheiten finden Sie unter <a href="commands/GuiControls.htm#slider-change">Erkennen von Änderungen (Slider)</a>.</p>
<p>Der BS_NOTIFY-Style wird nun automatisch je nach Bedarf bei Button-, CheckBox- und Radio-Steuerelementen hinzugefügt. Dieser Style wird nicht mehr standardmäßig auf Radio-Steuerelementen angewendet.</p>
<p>Focus (ehemals F) und LoseFocus (ehemals f) werden von mehreren (aber nicht von allen) Steuerelementtypen unterstützt.</p>
<p>Wenn man den Text eines Edit-Steuerelements mithilfe von Edit.Value oder Edit.Text setzt, wird das Change-Ereignis des Steuerelements nicht ausgelöst, während GuiControl das g-Label des Steuerelements auslösen würde.</p>
<p>LV/TV.Add/Modify unterdrücken jetzt elementverändernde Ereignisse, so dass solche Ereignisse nur durch Benutzeraktion oder SendMessage ausgelöst werden können.</p>
<h3 id="removed">Entfernt</h3>
<p>+Delimiter<br>
+Hwnd<em>AusgabeVar</em>(nutzen Sie stattdessen <a href="objects/Gui.htm#Hwnd">GuiObj.Hwnd</a> oder <a href="objects/GuiControl.htm#Hwnd">GuiCtrl.Hwnd</a>)<br>
+Label<br>
+LastFoundExist<br>
Gui GuiName: Default</p>
<h3 id="control-options">Steuerelement-Optionen</h3>
<p>+/-Background wird konsistenter interpretiert und unterstützt. Alle Steuerelemente, die "Gui Color" unterstützt haben, unterstützen jetzt <code>+Background<i>Farbe</i></code> und <code>+BackgroundDefault</code> (Synonym zu <code>-Background</code>), nicht nur ListView/TreeView/StatusBar/Progress.</p>
<p><a href="objects/Gui.htm#Add">GuiObj.Add</a> nutzt standardmäßig <code>y+m</code>/<code>x+m</code> anstatt <code>yp</code>/<code>xp</code>, wenn <code>xp</code>/<code>yp</code> oder <code>xp+0</code>/<code>yp+0</code> verwendet wird. Sprich, das Steuerelement wird unterhalb/auf der rechten Seite des vorherigen Steuerelements platziert, anstatt auf genau derselben Position. Wenn ein Offset ungleich Null verwendet wird, ist das Verhalten das gleiche wie in v1. Um genau dieselbe Position zu nutzen, gibt man gleichzeitig <code>xp yp</code> an.</p>
<p>Nach <code>x+m</code> und <code>y+m</code> kann optional ein zusätzlicher Offset erfolgen, wie z. B. <code>x+m+10</code> (<code>x+m10</code> wäre auch gültig, aber schlechter lesbar).</p>
<p><code>Choose</code> dient nicht länger als redundante (undokumentierte) Möglichkeit, den Wert für MonthCal anzugeben. Verwenden Sie einfach wie bisher den <em>Text</em>-Parameter.</p>
<h3 id="guicontrolget">GuiControlGet</h3>
<h4 id="empty-sub-command">Leerer Unterbefehl</h4>
<p>GuiControlGets leerer Unterbefehl hatte zwei Modi: Standardmodus, und Textmodus, wo der vierte Parameter das Wort <code>Text</code> war. Wenn ein Steuerelementtyp keinen einzigen "Wert" hatte, gab GuiControlGet standardmäßig das Ergebnis von <a href="https://msdn.microsoft.com/library/ms633520">GetWindowText</a> zurück (das nicht immer sichtbarer Text ist). Einige Steuerelemente hatten keinen sichtbaren Text oder unterstützten dessen Abruf nicht, folglich ignorierten sie den vierten Parameter. Im Gegensatz dazu gibt <a href="objects/GuiControl.htm#Text">GuiCtrl.Text</a> den Anzeigetext, versteckten Text (den gleichen Text, der von ControlGetText zurückgegeben wird) oder überhaupt nichts zurück.</p>
<p>Die folgende Tabelle zeigt das nächstmögliche Äquivalent (Eigenschaft oder Funktion) zu jedem Modus von GuiControlGet und den dazugehörigen Steuerelementtyp.</p>
<table class="info">
<tr><th>Steuerelement</th><th>Standard</th><th>Text</th><th>Hinweise</th></tr>
<tr><td>ActiveX</td><td>.Value</td><td>.Text</td><td>Text ist versteckt. Siehe unten.</td></tr>
<tr><td>Button</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>CheckBox</td><td>.Value</td><td>.Text</td><td></td></tr>
<tr><td>ComboBox</td><td>.Text</td><td>ControlGetText()</td><td>Benutzen Sie Value anstelle von Text, wenn AltSubmit benutzt wurde (aber Value gibt 0 zurück, wenn Text mit keinem Listenelement übereinstimmt). Text führt eine Korrektur der Groß-/Kleinschreibung durch, während ControlGetText den Inhalt des Eingabefeldes zurückgibt.</td></tr>
<tr><td>Custom</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>DateTime</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>DDL</td><td colspan="2">.Text</td><td>Benutzen Sie Value anstelle von Text, wenn AltSubmit benutzt wurde.</td></tr>
<tr><td>Edit</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>GroupBox</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>Hotkey</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Link</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>ListBox</td><td>.Text</td><td>ControlGetText()</td><td>Benutzen Sie Value anstelle von Text, wenn AltSubmit benutzt wurde. Text gibt den Text des ausgewählten Elements zurück, während ControlGetText den versteckten Text zurückgibt. Siehe unten.</td></tr>
<tr><td>ListView</td><td colspan="2">.Text</td><td>Text ist versteckt.</td></tr>
<tr><td>MonthCal</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Picture</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Progress</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Radio</td><td>.Value</td><td>.Text</td><td></td></tr>
<tr><td>Slider</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>StatusBar</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>Tab</td><td>.Text</td><td>ControlGetText()</td><td>Benutzen Sie Value anstelle von Text, wenn AltSubmit benutzt wurde. Text gibt den Text des ausgewählten Tabs zurück, während ControlGetText den versteckten Text zurückgibt.</td></tr>
<tr><td>Text</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>TreeView</td><td colspan="2">.Text</td><td>Text ist versteckt.</td></tr>
<tr><td>UpDown</td><td colspan="2">.Value</td><td></td></tr>
</table>
<p>ListBox: Bei einer Mehrfachauswahl-ListBox gibt Text und Value ein Array zurück, anstelle einer Liste, deren Elemente mit senkrechten Strichen getrennt sind.</p>
<p>ActiveX: <a href="objects/GuiControl.htm#Value">GuiCtrl.Value</a> gibt jedes Mal das gleiche Objekt zurück, während GuiControlGet jedes Mal ein neues Wrapperobjekt erstellt. Demzufolge ist es nicht mehr erforderlich, eine Referenz zum ActiveX-Objekt beizubehalten, um eine <a href="commands/ComObjConnect.htm">ComObjConnect</a>-Verbindung aufrecht zu erhalten.</p>
<h4 id="other-sub-commands">Andere Unterbefehle</h4>
<p><strong>Pos</strong> → <a href="objects/GuiControl.htm#GetPos">GuiCtrl.GetPos()</a></p>
<p><strong>Focus</strong> → <a href="objects/Gui.htm#FocusedCtrl">GuiObj.FocusedCtrl</a>; gibt ein GuiControl-Objekt anstelle der ClassNN-Bezeichnung zurück.</p>
<p><strong>FocusV</strong> → <code>GuiObj.FocusedCtrl.Name</code></p>
<p><strong>Hwnd</strong> → <a href="objects/GuiControl.htm#Hwnd">GuiCtrl.Hwnd</a>; gibt einen reinen Integer zurück, nicht eine hexadezimale Zeichenkette.</p>
<p><strong>Enabled/Visible/Name</strong> → gleichnamige GuiCtrl-Eigenschaften.</p>
<h3 id="guicontrol">GuiControl</h3>
<h4 id="blank-and-text-sub-commands">(Leer) und Text-Unterbefehle</h4>
<p>Die folgende Tabelle zeigt das nächstmögliche Äquivalent (Eigenschaft oder Funktion) zu jedem Modus von GuiControl und den dazugehörigen Steuerelementtyp.</p>
<table class="info">
<tr><th>Steuerelement</th><th>(Leer)</th><th>Text</th><th>Hinweise</th></tr>
<tr><td>ActiveX</td><td colspan="2">N/A</td><td>Befehl war wirkungslos.</td></tr>
<tr><td>Button</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>CheckBox</td><td>.Value</td><td>.Text</td><td></td></tr>
<tr><td>ComboBox</td><td>.Delete/Add/Choose</td><td>.Text</td><td></td></tr>
<tr><td>Custom</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>DateTime</td><td>.Value</td><td>.SetFormat()</td><td></td></tr>
<tr><td>DDL</td><td colspan="2">.Delete/Add/Choose</td><td></td></tr>
<tr><td>Edit</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>GroupBox</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>Hotkey</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Link</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>ListBox</td><td colspan="2">.Delete/Add/Choose</td><td></td></tr>
<tr><td>ListView</td><td colspan="2">N/A</td><td>Befehl war wirkungslos.</td></tr>
<tr><td>MonthCal</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Picture</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Progress</td><td colspan="2">.Value</td><td>Benutzen Sie den <code>+=</code>-Operator anstelle des <code>+</code>-Präfixes.</td></tr>
<tr><td>Radio</td><td>.Value</td><td>.Text</td><td></td></tr>
<tr><td>Slider</td><td colspan="2">.Value</td><td>Benutzen Sie den <code>+=</code>-Operator anstelle des <code>+</code>-Präfixes.</td></tr>
<tr><td>StatusBar</td><td colspan="2">.Text oder SB.SetText()</td><td></td></tr>
<tr><td>Tab</td><td colspan="2">.Delete/Add/Choose</td><td></td></tr>
<tr><td>Text</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>TreeView</td><td colspan="2">N/A</td><td>Befehl war wirkungslos.</td></tr>
<tr><td>UpDown</td><td colspan="2">.Value</td><td>Benutzen Sie den <code>+=</code>-Operator anstelle des <code>+</code>-Präfixes.</td></tr>
</table>
<h4 id="other-sub-commands-1">Andere Unterbefehle</h4>
<p><strong>Move</strong> → <a href="objects/GuiControl.htm#Move">GuiCtrl.Move(x, y, w, h)</a></p>
<p><strong>MoveDraw</strong> → GuiCtrl.Move(x, y, w, h), <a href="objects/GuiControl.htm#Redraw">GuiCtrl.Redraw()</a></p>
<p><strong>Focus</strong> → <a href="objects/GuiControl.htm">GuiCtrl.Focus()</a>, das nun WM_NEXTDLGCTL statt SetFocus verwendet, so dass eine Schaltfläche bei ihrer Fokussierung vorübergehend als Standardschaltfläche definiert ist, was mit dem Tabben zum Steuerelement konsistent ist.</p>
<p><strong>Enable/Disable</strong> → setzen Sie <a href="objects/GuiControl.htm#Enabled">GuiCtrl.Enabled</a></p>
<p><strong>Hide/Show</strong> → setzen Sie <a href="objects/GuiControl.htm#Visible">GuiCtrl.Visible</a></p>
<p><strong>Choose</strong> → <a href="objects/GuiControl.htm#Choose">GuiCtrl.Choose(n)</a>, wobei n ein reiner Integer ist. Der <code>|n</code>- oder <code>||n</code>-Modus wird nicht unterstützt (nutzen Sie stattdessen ControlChoose, wenn nötig).</p>
<p><strong>ChooseString</strong> → <a href="objects/GuiControl.htm#Choose">GuiCtrl.Choose(s)</a>, wobei s kein reiner Integer ist. Der <code>|n</code>- oder <code>||n</code>-Modus wird nicht unterstützt Wenn die Zeichenkette mit mehreren Elementen aus einer Mehrfachauswahl-ListBox übereinstimmt, wird Choose() sie alle auswählen, nicht nur das Erste.</p>
<p><strong>Font</strong> → <a href="objects/GuiControl.htm#SetFont">GuiCtrl.SetFont()</a></p>
<p><strong>+/-Option</strong> → <a href="objects/GuiControl.htm#Opt">GuiCtrl.Opt("+/-Option")</a></p>
<h3 id="other-changes">Sonstige Änderungen</h3>
<p>Progress-Gui-Steuerelemente haben nicht länger standardmäßig den PBS_SMOOTH-Style aktiv; das heißt, dass sich ihr Style jetzt nach dem Style des Systems richtet.</p>
<p>Die Standardabstände und Steuerelementgrößen (insbesondere bei Button-Steuerelementen) können leicht von v1 abweichen, wenn DPI größer als 100% ist.</p>
<p>Picture-Steuerelemente löschen ihr aktuelles Bild nicht mehr, wenn das Setzen eines neuen Bildes via <code>GuiCtrl.Value := "neues Bild.png"</code> fehlschlägt. Es ist jedoch erlaubt, das aktuelle Bild mit <code>GuiCtrl.Value := ""</code> zu entfernen.</p>
<h2 id="error-handling">Fehlerbehandlung</h2>
<p><a href="commands/OnError.htm">OnError</a> wird jetzt bei kritischen Fehlern aufgerufen, bevor das Skript beendet wird. Obwohl sich das Skript möglicherweise nicht in einem Zustand befindet, bei dem es sicher ausgeführt werden kann, wird der Versuch unternommen, um konsistent mit OnExit zu sein.</p>
<p>Laufzeitfehler setzen <code>Exception.What</code> nicht mehr auf die aktuell laufende benutzerdefinierte Funktion oder Subroutine (dies geschieht aber immer noch, wenn <code>Error()</code> ohne den zweiten Parameter aufgerufen wird). Dadurch wird der Zweck von <code>What</code> klarer: Ein Funktionsname weist auf einen Misserfolg dieser Funktion hin (nicht auf einen Misserfolg beim Aufruf der Funktion oder bei der Evaluierung ihrer Parameter). <code>What</code> ist leer bei Ausdrucksevaluierungs- und Kontrollflussfehlern (einige andere können auch leer sein).</p>
<p>Exception-Objekte, die von Laufzeitfehlern ausgelöst werden, können jetzt als Instanzen der neuen Error-Klasse oder einer spezifischeren Unterklasse identifiziert werden. Error-Objekte haben eine <code>Stack</code>-Eigenschaft, die einen Stack-Trace enthält. Wenn der <em>What</em>-Parameter den Namen einer laufenden Funktion spezifiziert, werden <em>File</em> und <em>Line</em> jetzt auf Basis dessen gesetzt, welche Zeile diese Funktion aufgerufen hat.</p>
<p>Die Try-Catch-Syntax wurde geändert, damit das Skript gezielt bestimmte Error-Klassen abfangen kann. Weitere Informationen finden Sie unter <a href="#catch">Catch</a> unten.</p>
<h3 id="continuable-errors">Fortsetzbare Fehler</h3>
<p>In den meisten Fällen bieten die Fehlerdialogfenster jetzt die Möglichkeit, den aktuellen Thread fortzusetzen (anstatt den Thread zu beenden). COM-Fehler beenden jetzt den Thread, wenn Sie sich gegen eine Fortsetzung entscheiden (anstatt das komplette Skript zu beenden).</p>
<p>Skripte sollten sich nicht darauf verlassen: Wenn der Fehler von einer internen Funktion ausgelöst wurde, wird beim Fortsetzen ein "" zurückgegeben. Wenn der Fehler vom Ausdrucksevaluator ausgelöst wurde (z. B. bei einer ungültigen dynamischen Referenz oder einer Division durch Null), wird der Ausdruck abgebrochen und "" zurückgegeben (wenn er als Parameter einer Kontrollanweisung verwendet wird).</p>
<p>In einigen Fällen unterstützt der Code keine Fortsetzung, dann sollte die Option zur Fortsetzung nicht angezeigt werden. Die Option wird ebenfalls nicht angezeigt, wenn ein kritischer Fehler auftritt; solche Fehler sind darauf ausgelegt, das Skript zu beenden.</p>
<p><a href="commands/OnError.htm">OnError</a>-Callbacks akzeptieren jetzt einen zweiten Parameter, der einen der folgenden Werte enthält:</p>
<ul>
<li>"Return": Die Rückgabe von -1 setzt den Thread fort, während 0 und 1 wie zuvor funktionieren.</li>
<li>"Exit": Fortsetzung wird nicht unterstützt. Die Rückgabe ungleich Null stoppt weitere Verarbeitungsvorgänge, beendet aber dennoch den Thread.</li>
<li>"ExitApp": Dies ist ein kritischer Fehler. Die Rückgabe ungleich Null stoppt weitere Verarbeitungsvorgänge, aber das Skript wird dennoch terminiert.</li>
</ul>
<h3 id="errorlevel">ErrorLevel</h3>
<p>ErrorLevel wurde entfernt. Skripte werden häufig (oder üblicherweise) ohne Fehlerprüfung geschrieben, so dass die Vorgehensweise zum Setzen von ErrorLevel bei Fehlern oft unentdeckt bleibt. Eine sofortige Fehlermeldung mag ein wenig konfrontativ erscheinen, ist aber in der Regel hilfreicher.</p>
<p>Dort, wo früher ErrorLevel gesetzt wurde, um einen Fehlerzustand anzuzeigen, wird stattdessen eine Ausnahme mit einer (normalerweise) hilfreicheren Fehlermeldung ausgelöst.</p>
<p>Befehle wie "Process Exist", die mit ErrorLevel einen Wert zurückgegeben haben, geben jetzt einfach diesen Wert (z. B. <code>PID := ProcessExist()</code>) oder etwas Nützlicheres (z. B. <code>HWND := GroupActivate(Gruppe)</code>) zurück.</p>
<p>In einigen Fällen wurde ErrorLevel als sekundärer Rückgabewert verwendet.</p>
<ul>
<li><a href="commands/Sort.htm">Sort</a> mit der U-Option gibt nicht länger die Anzahl der entfernten Duplikate zurück.</li>
<li><code>Input</code> wurde entfernt. Es wurde von InputHook abgelöst. Es genügen ein paar Codezeilen, um einen passablen Ersatz zu kreieren, der ein InputHook-Objekt mit den Ergebnissen zurückgibt, anstatt ErrorLevel und eine AusgabeVar zu verwenden.</li>
<li><a href="commands/InputBox.htm">InputBox</a> gibt ein Objekt mit den Eigenschaften <code>Result</code> (OK, Cancel oder Timeout) und <code>Value</code> zurück.</li>
</ul>
<p>File-Funktionen, die zuvor die Anzahl der Misserfolge in ErrorLevel gespeichert haben, speichern diese Information nun in die <code>Extra</code>-Eigenschaft des ausgelösten Exception-Objekts.</p>
<p><a href="commands/SendMessage.htm">SendMessage</a>-Zeitüberschreitung ist in der Regel ein anomaler Zustand und bewirkt, dass ein <code>TimeoutError</code> ausgelöst wird. <code>TargetError</code> und <code>OSError</code> können unter anderen Bedingungen ausgelöst werden.</p>
<p>Die <code>UseErrorLevel</code>-Modi von den Funktionen <a href="commands/Run.htm">Run</a> und <a href="commands/Hotkey.htm">Hotkey</a> wurden entfernt. Dieser Modus wurde eingeführt, als es noch kein <code>Try</code>/<code>Catch</code> gab. Menu und Gui hatten diesen Modus ebenfalls, wurden aber mit Objekten ersetzt (die ErrorLevel nicht verwenden).</p>
<h3 id="expressions-1">Ausdrücke (Expressions)</h3>
<p>Es wird ein Ladezeitfehler bei mehr Fehlern als in v1 ausgelöst, wie z. B.:</p>
<ul>
<li>Leere runde Klammern (außer neben einem Funktionsnamen); z. B. <code>x ()</code></li>
<li>Ein Präfixoperator, der auf der falschen Seite benutzt wird oder dem ein Operand fehlt; z. B. <code>x!</code></li>
<li>Binäroperator mit weniger als zwei Operanden.</li>
<li>Ternäroperator mit weniger als drei Operanden.</li>
<li>Ziel der Zuweisung ist keine beschreibbare Variable oder Eigenschaft.</li>
</ul>
<p>Eine Ausnahme wird ausgelöst, wenn einer der folgenden Fehler auftritt (anstatt den Fehler zu ignorieren oder eine leere Zeichenkette zu erzeugen):</p>
<ul>
<li>Wenn man versucht, eine Berechnung mit einem nicht-numerischen Wert durchzuführen. (Numerische Zeichenketten sind in Ordnung.)</li>
<li>Division durch Null oder andere ungültig/nicht-unterstützte Eingaben wie z. B. <code>(-1)**1.5</code>. Beachten Sie, dass einige Fälle neuerdings als ungültig erkannt werden, wie z. B. <code>0**0</code> und <code>a&lt;&lt;b</code> oder <code>a&gt;&gt;b</code>, wobei <code>b</code> außerhalb des Bereichs 0 bis 63 liegt.</li>
<li>Fehler beim Reservieren von Speicher für den Rückgabewert einer internen Funktion, für eine Verkettung oder für das Ergebnis eines Ausdrucks.</li>
<li>Stapelunterlauf (üblicherweise durch einen Syntaxfehler ausgelöst).</li>
<li>Versuchte Zuweisung zu etwas, das keine Variable (oder kein Array-Element) ist.</li>
<li>Versuchte Zuweisung zu einer schreibgeschützten Variable.</li>
<li>Versuchte Doppeldereferenzierung mit einem leeren Namen, wie z. B. <code>fn(%leer%)</code>.</li>
<li>Fehler beim Ausführen eines dynamischen Funktions- oder Methodenaufrufs.</li>
<li>Ein Methoden-/Eigenschaftsaufruf schlägt fehl, weil der Wert diese Methode/Eigenschaft nicht implementiert. (Bei assoziativen Arrays in v1 kann nur ein Methodenaufruf diesen Fehler verursachen.)</li>
<li>Eine Objektzuweisung schlägt fehl, weil ein Fehler bei der Speicherreservierung aufgetreten ist.</li>
</ul>
<p>Einige der Bedingungen oben werden in v1 erkannt, aber nicht mitten in einem Ausdruck; zum Beispiel wird <code>A_AhkPath := x</code> in v1 erkannt, während <code>y := x, A_AhkPath := x</code> nur in v2 erkannt werden kann.</p>
<p>Die alleinige Verwendung der Operatoren <code>+=</code>, <code>-=</code>, <code>--</code> und <code>++</code> behandelt eine leere Variable nicht mehr als 0. Dies unterscheidet sich von v1, wo eine leere Variable als 0 behandelt wurde, wenn sie allein verwendet wurde, aber nicht inmitten eines Ausdrucks oder mit einem Komma bei mehreren Anweisungen.</p>
<h3 id="functions-1">Funktionen</h3>
<p>Funktionen lösen bei Misserfolg grundsätzlich eine Ausnahme aus. Genauer gesagt:</p>
<ul>
<li>
<p>Fehler aufgrund fehlerhafter Verwendung von <a href="commands/DllCall.htm">DllCall</a>, <a href="commands/RegExMatch.htm">RegExMatch</a> und <a href="commands/RegExReplace.htm">RegExReplace</a> traten aufgrund ihrer Komplexität recht häufig auf und sind (wie viele Fehler) leichter zu erkennen und zu debuggen, wenn sofort eine Fehlermeldung angezeigt wird.</p>
</li>
<li>
<p><a href="commands/Math.htm">Mathematische Funktionen</a> lösen eine Ausnahme aus, wenn einer ihrer Eingabewerte nicht-numerisch ist, oder wenn die Operation ungültig ist (z. B. Division durch Null).</p>
</li>
<li>
<p>Funktionen mit einem <em>FensterTitel</em>-Parameter (mit Ausnahmen, wie z. B. den ahk_group-Modus von <a href="commands/WinClose.htm">WinClose</a>) lösen eine Ausnahme aus, wenn das Zielfenster oder -steuerelement nicht gefunden wird.</p>
</li>
</ul>
<p>Ausnahmen werden für einige Fehler ausgelöst, die zuvor nicht erkannt wurden, und einige Bedingungen, die fälschlicherweise als Fehler markiert wurden (bisher durch Setzen von ErrorLevel), wurden behoben.</p>
<p>Einige Fehlermeldungen wurden geändert.</p>
<h3 id="catch">Catch</h3>
<p>Die Syntax für <a href="commands/Catch.htm">Catch</a> wurde geändert, um die Möglichkeit zu bieten, bestimmte Error-Klassen abzufangen und den Rest gewähren zu lassen (um die Kontrolle an ein anderes Catch weiter oben auf dem Aufrufstapel zu übergeben oder den Fehler zu melden und den Thread zu beenden). Früher erforderte dies das Abfangen von ausgelösten Werten aller Typen, und dann die Überprüfung des Typs und das erneute Auslösen. Zum Beispiel:</p>
<pre><em>; Alt (verwendet veraltete v2.0-a-Regeln zur Veranschaulichung, da v1 kein `is` oder keine Error-Klassen hatte)</em>
try
    SendMessage Mld,,, "Strlmnt1", "Das Fenster"
catch Fehler
    if Fehler is TimeoutError
        MsgBox "Das Fenster reagiert nicht"
    else
        throw Fehler

<em>; Neu</em>
try
    SendMessage Mld,,, "Strlmnt1", "Das Fenster"
catch TimeoutError
    MsgBox "Das Fenster reagiert nicht"
</pre>
<p>Variationen:</p>
<ul>
<li><code>catch</code> fängt eine Error-Instanz ab.</li>
<li><code>catch as Fehler</code> fängt eine Error-Instanz ab, die an "Fehler" übergeben wird.</li>
<li><code>catch ValueError as Fehler</code> fängt eine ValueError-Instanz ab, die an "Fehler" übergeben wird.</li>
<li><code>catch ValueError, TypeError</code> fängt beide Typen ab.</li>
<li><code>catch ValueError, TypeError as Fehler</code> fängt beide Typen ab und übergibt die Instanz an "Fehler".</li>
<li><code>catch Any</code> fängt alles ab.</li>
<li><code>catch (MeinError as Fehler)</code> erlaubt runde Klammern, wie die meisten anderen Kontrollanweisungen.</li>
</ul>
<p>Wenn <code>try</code> ohne <code>finally</code> oder <code>catch</code> verwendet wird, verhält es sich so, als hätte es ein <code>catch</code> mit einem leeren Block. Das hört sich zwar nach v1 an, aber <code>catch</code> allein fängt jetzt nur noch Instanzen von <code>Error</code> ab. In den meisten Fällen ist <code>try</code> allein zur Unterdrückung eines Errors gedacht, so dass keine Änderungen vorgenommen werden müssen. Das direkte Äquivalent des v1-Codes <code>try irgendwas()</code> ist in v2 jedoch:</p>
<pre>try irgendwas()
catch Any
{}
</pre>
<p>Die Priorisierung des Fehlertyps gegenüber dem Namen der Ausgabevariablen könnte zu besserem Code ermutigen; also den erwarteten Fehler wie beabsichtigt zu behandeln, ohne dabei unerwartete Fehler, die hätten gemeldet werden sollen, zu unterdrücken oder falsch zu behandeln.</p>
<p>Da Werte aller Typen ausgelöst werden können, ist jede Klasse für den Filter gültig (z. B. <code>String</code> oder <code>Map</code>). Die Klassenprototypen werden jedoch beim Laden des Skripts aufgelöst und müssen als vollständiger Klassenname und nicht als beliebiger Ausdruck angegeben werden (ähnlich wie <code>y</code> in <code>class x extends y</code>).</p>
<p>Während eine <code>catch</code>-Anweisung ausgeführt wird, kann <code>throw</code> ohne Parameter verwendet werden, um die Ausnahme erneut auszulösen (wodurch die Notwendigkeit vermieden wird, eine Ausgangsvariable nur für diesen Zweck anzugeben). Dies wird sogar innerhalb eines verschachtelten <code>try</code>...<code>finally</code> unterstützt, aber nicht innerhalb eines verschachtelten <code>try</code>...<code>catch</code>. <code>throw</code> muss nicht physisch im Körper der <code>catch</code>-Anweisung enthalten sein; sie kann von einer aufgerufenen Funktion verwendet werden.</p>
<p>Nach dem letzten <code>catch</code> kann ein <code>else</code> vorhanden sein; es wird ausgeführt, wenn innerhalb von <code>try</code> keine Ausnahme ausgelöst wird.</p>
<h2 id="keyboard-mouse-hotkeys-and-hotstrings">Tastatur, Maus, Hotkeys und Hotstrings</h2>
<p>Es sind weniger VK-zu-SC- und SC-zu-VK-Belegungen hartkodiert, was theoretisch die Kompatibilität mit unkonventionellen benutzerdefinierten Tastaturlayouts verbessert.</p>
<p>Die Tastennamen "Return" und "Break" wurden entfernt. Verwenden Sie stattdessen "Enter" und "Pause".</p>
<p>Die Existenz von <kbd>AltGr</kbd> auf jedem Tastaturlayout wird jetzt immer durch Lesen des Flags KLLF_ALTGR aus der Tastaturlayout-DLL erkannt. (Unicode-Versionen von AutoHotkey v1.1.28+ verwenden diese Methode bereits.) Die Fallback-Methoden zur Erkennung von <kbd>AltGr</kbd> über den Tastatur-Hook wurden entfernt.</p>
<p>Mausrad-Hotkeys setzen <a href="Variables.htm#EventInfo">A_EventInfo</a> auf den gemeldeten Delta-Wert vom Maustreiber, anstatt diesen Wert durch 120 zu teilen. In der Regel ist das ein mit 120 multiplizierter Wert, aber einige Maustreiber können eine Mausraddrehung in höherer Auflösung melden.</p>
<p>Hotstrings behandeln nun <kbd>Umschalt</kbd>+<kbd>Backspace</kbd> wie <kbd>Backspace</kbd>, anstatt es innerhalb des Hotstring-Zwischenspeichers in <code>`b</code> zu übersetzen.</p>
<p>Hotstrings verwenden nicht das letzte, sondern das erste Doppelpunktpaar (<code class="no-highlight">::</code>) als Trennung, wenn mehrere Doppelpunktpaare vorhanden sind. Mit anderen Worten: Doppelpunkte (wenn sie an einen anderen Doppelpunkt angrenzen) müssen mit einem Escapezeichen versehen werden, um Text in v2 zu triggern, während sie in v1 im Ersatztext mit einem Escapezeichen versehen werden müssen. Beachten Sie, dass bei einer ungeraden Anzahl von aufeinanderfolgenden Doppelpunkten das bisherige Verhalten den letzten Doppelpunkt nicht als Teil eines Paares angesehen hatte. Zum Beispiel bleibt das Verhalten bei <code class="no-highlight">::1:::2</code> (<code class="no-highlight">1</code> → <code class="no-highlight">:2</code>) unverändert, während sich <code class="no-highlight">::3::::4</code> wie <code class="no-highlight">3</code> → <code class="no-highlight">::4</code> statt wie <code class="no-highlight">3::</code> → <code class="no-highlight">4</code> verhält.</p>
<p>Hotstrings escapen nicht länger Doppelpunktpaare, daher ist es nun möglich, einen einzelnen Doppelpunkt am Ende des Hotstring-Triggers mit einem Escapezeichen zu versehen. Zum Beispiel ist <code class="no-highlight">::5`:::6</code> nun <code class="no-highlight">5:</code> → <code class="no-highlight">6</code> statt eines Fehlers, und <code class="no-highlight">::7`::::8</code> nun <code class="no-highlight">7:</code> → <code class="no-highlight">:8</code> statt <code class="no-highlight">7::</code> → <code class="no-highlight">8</code>. Am besten versieht man in solchen Fällen alle direkt geschriebenen Doppelpunkte mit einem Escapezeichen, um Verwirrung zu vermeiden (aber ein einzelner isolierter Doppelpunkt muss nicht mit einem Escapezeichen versehen werden).</p>
<p>Hotstrings mit Fortsetzungsbereichen verwenden nun standardmäßig den Text- statt Raw-Modus.</p>
<p>Hotkeys maskieren die Win/Alt-Taste nur noch beim Loslassen, wenn sie logisch unten ist und der Hotkey die Win/Alt-Taste benötigt (mit <code>#</code>/<code>!</code> oder einem benutzerdefinierten Präfix). Das heißt, dass Hotkeys, die die Win/Alt-Taste nicht benötigen, Win/Alt-Up nicht mehr maskieren, wenn die Win/Alt-Taste physisch unten ist. Dadurch können Hotkeys, die <code>{Blind}{LWin up}</code> senden, das Startmenü aktivieren (was bei Verwendung einer neubelegten Taste wie <code>AppsKey::RWin</code> bereits möglich war).</p>
<h2 id="other">Sonstiges</h2>
<p>Die Unterstützung von Windows 2000 und Windows XP wurde gestrichen.</p>
<p>AutoHotkey überschreibt nicht länger die Systemeinstellung <code>ForegroundLockTimeout</code>, wenn es gestartet wird.</p>
<ul>
<li>Dies geschah durch Aufrufen von <code>SystemParametersInfo</code> mit der <code>SPI_SETFOREGROUNDLOCKTIMEOUT</code>-Aktion, die alle Anwendungen für die aktuelle Benutzersitzung beeinflusst. Diese Einstellung bleibt nach dem Abmelden nicht bestehen, war aber für einige Benutzer dennoch unerwünscht.</li>
<li>Benutzerfehlerberichte (und einfache Logik) weisen darauf hin, dass damit, wenn es funktioniert, der Fokus von Programmen gestohlen werden kann, die nicht speziell dafür ausgelegt sind.</li>
<li>Tests unter Windows 10 zufolge ergaben, dass es keinerlei Effekt auf irgendwas hatte; <code>SetForegroundWindow</code>-Aufrufe schlugen immer fehl, und andere von WinActivate eingesetzte Workarounds waren erforderlich und wirksam, unabhängig vom Timeout. <code>SPI_GETFOREGROUNDLOCKTIMEOUT</code> wurde von einem separaten Prozess verwendet, um zu verifizieren, ob die Änderung einen Effekt hatte (was manchmal nicht der Fall war).</li>
<li>Es kann leicht in einem Skript repliziert werden:
<pre>DllCall("SystemParametersInfo", "int", 0x2001, "int", 0, "ptr", 0, "int", 2)</pre>
</li>
</ul>
<p>RegEx-Zeilenumbruchsübereinstimmung benutzt standardmäßig (*ANYCRLF) und (*BSR_ANYCRLF); `r und `n werden zusammen mit `r`n erkannt. Die `a-Option aktiviert bedingungslos (*BSR_UNICODE).</p>
<p>RegEx-Callout-Funktionen können nun variadisch sein. Callouts, die über eine <code>pcre_callout</code>-Variable angegeben werden, können beliebige aufrufbare Objekte sein, oder <code>pcre_callout</code> selbst kann direkt als Funktion (vielleicht eine verschachtelte Funktion) definiert werden. Da die <a href="#scope">Funktions- und Variablennamensräume zusammengelegt wurden</a>, kann ein Callout-Muster wie <code>(?C:fn)</code> auch auf eine lokale oder globale Variable verweisen, die ein Funktionsobjekt enthält, nicht nur auf eine benutzerdefinierte Funktion.</p>
<p>Skripte, die von der Standardeingabe (stdin) gelesen werden (z. B. mit <code>AutoHotkey.exe *</code>), fügen nicht mehr das ursprüngliche Arbeitsverzeichnis in <a href="Variables.htm#ScriptFullPath">A_ScriptFullPath</a> oder in den Titel des Hauptfensters ein, aber es wird als <a href="Variables.htm#ScriptDir">A_ScriptDir</a> und zum Finden des lokalen Lib-Ordners verwendet.</p>
<p>Einstellungen, die via Auto-Execute-Thread geändert werden, werden jetzt sofort zu Standardeinstellungen (für Threads, die nach diesem Punkt gestartet werden), und nicht erst nach 100 ms und dann erneut, wenn der Auto-Execute-Thread sein Ende erreicht hat.</p>
<p>Folgende Limitierungen wurden durch Zuhilfenahme dynamischer Speicherreservierungen aufgehoben:</p>
<ul>
<li>Maximale Länge einer Zeile oder eines Fortsetzungsbereichs von 16383 Zeichen.</li>
<li>Maximal 512 Token pro Ausdruck (MAX_TOKENS).<br>
Arrays innerhalb des Ausdrucksevaluators, die in Abhängigkeit von MAX_TOKENS dimensioniert wurden, basieren jetzt auf vorberechneten Schätzungen der erforderlichen Größen; in Sachen Leistung sollten keine Unterschiede feststellbar sein, aber der Stack-Verbrauch ist in den meisten Fällen etwas geringer. Dies könnte die maximale Rekursionstiefe von benutzerdefinierten Funktionen erhöhen.</li>
<li>Maximal 512 Variablen- oder Funktionsreferenzen pro Argument (aber MAX_TOKENS war ohnehin restriktiver für Ausdrücke).</li>
<li>Maximal 255 angegebene Parameterwerte pro Funktionsaufruf (aber MAX_TOKENS war ohnehin restriktiver).</li>
</ul>
<p><a href="commands/ListVars.htm">ListVars</a> zeigt jetzt statische Variablen getrennt von lokalen Variablen an. Globale Variablen, die innerhalb der Funktion deklariert sind, werden auch als statische Variablen aufgelistet (dies ist ein Nebeneffekt neuer Implementierungsdetails, wird aber beibehalten, da es in Skripten mit vielen globalen Variablen nützlich sein könnte).</p>
<p>Die (undokumentierte?) "lockere" Variablenoptimierung wurde entfernt, um die Codegröße und die Wartungskosten zu reduzieren. Diese Optimierung verbesserte die Leistung von Skripten mit mehr als 100000 Variablen.</p>
<p><a href="Program.htm#tray-icon">Tray-Menü</a>: Das Wort "This" wurde aus "Reload This Script" und "Edit This Script" entfernt, um konsistent mit "Pause Script" und den Menüoptionen des Hauptfensters zu sein.</p>
<p>YYYYMMDDHH24MISS-Zeitstempelwerte werden jetzt als ungültig eingestuft, wenn ihre Länge nicht eine gerade Zahl im Bereich von 4 bis 14 ist.</p>
<h3 id="persistence">Persistenz</h3>
<p>Skripte sind "<a href="commands/Persistent.htm">persistent</a>", wenn mindestens eine der folgenden Bedingungen zutrifft:</p>
<ul>
<li>Mindestens ein Hotkey oder Hotstring wurde im Skript definiert.</li>
<li>Mindestens eine <a href="objects/Gui.htm">Gui</a> (oder das <a href="Program.htm#main-window">Hauptfenster</a> des Skripts) ist sichtbar.</li>
<li>Mindestens ein <a href="commands/SetTimer.htm">Timer</a> läuft gerade.</li>
<li>Mindestens eine <a href="commands/OnClipboardChange.htm">OnClipboardChange</a>-Callback-Funktion wurde gesetzt.</li>
<li>Mindestens ein <a href="commands/InputHook.htm">InputHook</a> ist aktiv.</li>
<li><code>Persistent()</code> oder <code>Persistent(true)</code> wurde aufgerufen und nicht durch Aufrufen von <code>Persistent(false)</code> rückgängig gemacht.</li>
</ul>
<p>Wenn eines der folgenden Dinge eintritt und keine der oben genannten Bedingungen zutrifft, wird das Skript terminiert.</p>
<ul>
<li>Der letzte Skript-Thread endet.</li>
<li>Eine <a href="objects/Gui.htm">Gui</a> wurde geschlossen oder zerstört.</li>
<li>Das <a href="Program.htm#main-window">Hauptfenster</a> des Skripts wurde geschlossen (aber wenn es zerstört wird, wird das Skript wie früher unabhängig von der Persistenz beendet).</li>
<li>Ein <a href="commands/InputHook.htm">InputHook</a> ohne <a href="commands/InputHook.htm#OnEnd">OnEnd</a>-Callback endet.</li>
</ul>
<p>Aus Gründen der Flexibilität macht <a href="commands/OnMessage.htm">OnMessage</a> das Skript nicht automatisch persistent.</p>
<p>v1-Skripte sind hingegen "persistent", wenn mindestens eine der folgenden Bedingungen zutrifft:</p>
<ul>
<li>Mindestens ein Hotkey oder Hotstring wurde im Skript definiert.</li>
<li>Gui oder OnMessage() kommt irgendwo im Skript vor.</li>
<li>Der Tastatur- oder Maus-Hook ist installiert.</li>
<li>Input wurde aufgerufen.</li>
<li>#Persistent wurde genutzt.</li>
</ul>
<h3 id="threads">Threads</h3>
<p><a href="misc/Threads.htm">Threads</a> beginnen mit einem unterbrechungsfreien Timeout von 17 ms statt 15 ms. 15 war zu niedrig, da der systeminterne Taktzähler in Schritten von mindestens 15 oder 16 aktualisiert wurde; das heißt, wenn der Taktzähler genau zum falschen Zeitpunkt aktualisiert wurde, konnte der Thread unterbrechbar werden, obwohl praktisch keine Zeit vergangen war.</p>
<p>Threads, die unterbrechungsfrei beginnen, bleiben nun so lange bestehen, bis mindestens eine Zeile ausgeführt wurde, auch dann, wenn das unterbrechungsfreie Timeout zuerst abläuft (z. B. wenn das System den Prozess unmittelbar nach dem Start des Threads sperrt, um einem anderen Prozess CPU-Zeit zu geben).</p>
<p><a href="commands/_MaxThreads.htm">#MaxThreads</a> und <a href="commands/_MaxThreadsPerHotkey.htm">#MaxThreadsPerHotkey</a> machen keine Ausnahmen mehr für Subroutinen, deren erste Zeile einer der folgenden Befehle ist: <a href="commands/ExitApp.htm">ExitApp</a>, <a href="commands/Pause.htm">Pause</a>, <a href="commands/Edit.htm">Edit</a>, <a href="commands/Reload.htm">Reload</a>, <a href="commands/KeyHistory.htm">KeyHistory</a>, <a href="commands/ListLines.htm">ListLines</a>, <a href="commands/ListVars.htm">ListVars</a> oder <a href="commands/ListHotkeys.htm">ListHotkeys</a>.</p>
<h3 id="default-settings">Standardeinstellungen</h3>
<ul>
<li>#NoEnv ist das Standardverhalten, daher wurde die Direktive selbst entfernt. Verwenden Sie stattdessen <a href="commands/EnvGet.htm">EnvGet</a>, wenn eine entsprechende interne Variable nicht verfügbar ist.</li>
<li><a href="commands/SendMode.htm">SendMode</a> benutzt standardmäßig Input statt Event.</li>
<li><a href="commands/SetTitleMatchMode.htm">Titelübereinstimmungsmodus</a> benutzt standardmäßig 2 statt 1.</li>
<li>SetBatchLines wurde entfernt, um alle Skripte mit voller Geschwindigkeit ausführen zu lassen (in v1 entspricht das SetBatchLines -1).</li>
<li>Das Arbeitsverzeichnis ist standardmäßig <a href="Variables.htm#ScriptDir">A_ScriptDir</a>. <a href="Variables.htm#InitialWorkingDir">A_InitialWorkingDir</a> enthält das Arbeitsverzeichnis, das vom Prozess, der AutoHotkey gestartet hat, gesetzt wurde.</li>
<li>Standardmäßig gilt bei allen Skripten das <a href="commands/_SingleInstance.htm">#SingleInstance</a>-Nachfrageverhalten; #SingleInstance selbst aktiviert den Force-Modus. <code>#SingleInstance Prompt</code> kann auch explizit verwendet werden, um Klarheit zu schaffen oder um eine frühere Direktive außer Kraft zu setzen.</li>
<li><a href="commands/CoordMode.htm">CoordMode</a> benutzt standardmäßig Client statt Window (seit v1.1.05 verfügbar).</li>
<li>Der Standardzeichensatz für Skriptdateien (aber nicht für Dateien, die <em>vom</em> Skript gelesen werden) ist jetzt UTF-8 anstelle von ANSI (CP0). Dies kann wie bisher mit dem Befehlszeilenparameter /CP überschrieben werden.</li>
</ul>
<h3 id="command-line">Befehlszeile</h3>
<p>Befehlszeilenargumente werden nicht mehr in einem Pseudo-Array mit nummerierten globalen Variablen gespeichert; stattdessen sollte die globale Variable <a href="Variables.htm#Args">A_Args</a> (in v1.1.27 hinzugefügt) verwendet werden.</p>
<p>Die Optionen /R und /F wurden entfernt. Verwenden Sie stattdessen /restart und /force.</p>
<p>/validate sollte anstelle von /iLib verwendet werden, wenn mit AutoHotkey.exe ein Skript auf Syntaxfehler geprüft wird, da der Mechanismus zum Auto-Inkludieren von Funktionsbibliotheken entfernt wurde.</p>
<p>/ErrorStdOut wird jetzt in einem der folgenden Fälle als einer der Parameter des Skripts behandelt, nicht intern:</p>
<ul>
<li>Wenn das Skript kompiliert wird, sofern kein /script verwendet wird.</li>
<li>Wenn es ein Suffix hat, das nicht mit <code>=</code> beginnt (wo früher das Suffix ignoriert wurde).</li>
</ul>

</body>
</html>